# 백준 14226번: 이모티콘 (BFS - 최단 거리 탐색)
# -----------------------------------------------------
# ✅ 문제 설명:
# - 화면에 이모티콘 1개가 있는 상태에서, 3가지 연산을 수행할 수 있다.
#   1) `복사`: 화면에 있는 이모티콘을 클립보드에 복사한다.
#   2) `붙여넣기`: 클립보드에 있는 모든 이모티콘을 화면에 추가한다.
#   3) `삭제`: 화면에 있는 이모티콘 하나를 삭제한다.
# - 목표는 화면에 정확히 N개의 이모티콘을 만드는 최소 시간을 구하는 것.
#
# ✅ 입력 형식:
# - 첫 번째 줄에 정수 N (2 ≤ N ≤ 1000) 가 주어진다.
#
# ✅ 출력 형식:
# - 이모티콘을 N개 만들기 위한 최소 연산 횟수를 출력한다.
#
# ✅ 입출력 예제:
# 🔹 예제 입력 1:
#   2
# 🔹 예제 출력 1:
#   2
#
# 🔹 예제 입력 2:
#   4
# 🔹 예제 출력 2:
#   4
# -----------------------------------------------------

import sys
from collections import deque

N = int(sys.stdin.readline())

# ✅ 방문 배열을 2차원으로 선언: visited[x][y] → (현재 화면의 이모티콘 개수, 클립보드 개수)
visited = [[False] * 1001 for _ in range(1001)]

def bfs():
    queue = deque([(1, 0, 0)])  # ✅ 시작 값 (현재 이모티콘 개수: 1, 클립보드: 0, 시간: 0)
    visited[1][0] = True  # ✅ (현재 화면 1, 클립보드 0) 방문 체크
    
    while queue:
        x, y, z = queue.popleft()

        # ✅ 목표 개수 N에 도달하면 최소 시간 반환
        if x == N:
            return z

        # ✅ 가능한 연산 수행 (복사, 붙여넣기, 삭제)
        # 1️⃣ 화면의 이모티콘을 클립보드에 복사 (이전 클립보드 값 무시)
        if not visited[x][x]:  # ✅ (현재 화면의 이모티콘 수, 새로운 클립보드 값)
            queue.append((x, x, z + 1))
            visited[x][x] = True

        # 2️⃣ 클립보드에 저장된 이모티콘을 화면에 붙여넣기 (단, y > 0일 때만 가능)
        if y > 0 and x + y <= 1000 and not visited[x + y][y]:  
            queue.append((x + y, y, z + 1))
            visited[x + y][y] = True

        # 3️⃣ 현재 화면에서 이모티콘 1개 삭제 (단, x > 0일 때만 가능)
        if x > 0 and not visited[x - 1][y]:
            queue.append((x - 1, y, z + 1))
            visited[x - 1][y] = True

# ✅ BFS 실행 후 결과 출력
print(bfs())

# -----------------------------------------------------
# ✅ 백준 제출용 최종 정답 코드 🚀
# - `sys.stdin.readline()`을 활용하여 빠르게 입력 처리.
# - `visited` 배열을 2차원으로 선언하여 BFS 탐색을 최적화.
# - `queue.popleft()`를 사용하여 BFS 탐색을 수행 (FIFO).
#
# ✅ 2단계에서 틀렸던 점:
# 1️⃣ **방문 체크 오류 (`visited[dx]` → `visited[dx][dy]`)**
#    - 기존 코드에서 `visited[dx]`로 방문 체크하여 2차원 배열을 올바르게 활용하지 못함.
#    - 해결 방법: `visited[x][y]`를 2차원 배열로 선언하고, `visited[dx][dy]`로 방문 체크 수행.
#
# 2️⃣ **"붙여넣기" 연산에서 `y=0`일 때 실행됨**
#    - 기존 코드에서 `x + y` 연산(붙여넣기)이 `y=0`일 때도 수행되어 불필요한 탐색 발생.
#    - 해결 방법: `if y > 0 and 0 <= x + y <= 1000:` 조건 추가하여 올바른 연산 수행.
#
# ✅ 요청한 BFS 힌트:
# 🔹 **BFS를 활용한 최단 거리 탐색 개념**
#    - BFS는 "가장 먼저 도달하는 경로가 최단 거리"를 보장.
#    - 모든 이동을 `queue`에 저장하고, 가장 먼저 도착한 경우를 최단 거리로 반환.
#
# 🔹 **BFS 탐색 과정 예제 (`N=6`)**
#    ```plaintext
#    1️⃣ (1, 0) → (1, 1)  # 복사
#    2️⃣ (1, 1) → (2, 1)  # 붙여넣기
#    3️⃣ (2, 1) → (4, 1)  # 붙여넣기
#    4️⃣ (4, 1) → (5, 1)  # +1
#    5️⃣ (5, 1) → (6, 1)  # +1
#    ```
#    - 도착 시 `최소 이동 횟수 = 5` 반환
#
# ✅ 최종 코드에서 수정한 점:
# - `visited`를 2차원 배열로 변경하여 중복 탐색 방지.
# - BFS를 활용하여 최단 경로를 찾도록 `queue.popleft()` 방식 사용.
# - `visited[x][y]`로 방문 체크를 수행하여 올바른 BFS 탐색 구현.
# -----------------------------------------------------
