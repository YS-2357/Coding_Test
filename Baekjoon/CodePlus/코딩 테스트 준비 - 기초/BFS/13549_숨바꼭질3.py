# 백준 13549번: 숨바꼭질 3 (BFS - 0-1 가중치 최단 경로 탐색)
# -----------------------------------------------------
# ✅ 문제 설명:
# - 수빈이는 현재 점 N에 위치해 있고, 동생은 점 M에 위치해 있다.
# - 수빈이는 1초 후 3가지 선택을 할 수 있다:
#   1) `N - 1` (1초 후 왼쪽으로 이동)
#   2) `N + 1` (1초 후 오른쪽으로 이동)
#   3) `N * 2` (0초 후 순간이동)
# - 동생의 위치 M으로 가장 빠르게 이동하는 최소 시간을 구하는 문제.
#
# ✅ 입력 형식:
# - 첫 번째 줄에 정수 N, M (0 ≤ N, M ≤ 100,000) 가 주어진다.
#
# ✅ 출력 형식:
# - 수빈이가 M에 도착하는 데 걸리는 최소 시간을 출력한다.
#
# ✅ 입출력 예제:
# 🔹 예제 입력 1:
#   5 17
# 🔹 예제 출력 1:
#   2
# -----------------------------------------------------

from collections import deque

N, M = map(int, input().split())
visited = [False] * 100001  # 방문 체크 배열

def bfs():
    if N == M:
        return 0  # 시작과 목표가 같으면 0초

    queue = deque([(N, 0)])  # (현재 위치, 경과 시간)
    visited[N] = True  # 시작점 방문 체크

    while queue:
        prev, count = queue.popleft()  # 현재 위치와 걸린 시간

        if prev == M:
            return count  # 목표 도착 시 최소 시간 반환

        # 이동 가능한 3가지 경우 탐색
        for move in (prev * 2, prev - 1, prev + 1):
            if 0 <= move < 100001 and not visited[move]:
                visited[move] = True  # 방문 체크
                
                if move == prev * 2:
                    queue.appendleft((move, count))  # 순간이동(0초)은 우선 탐색 (deque 앞에 추가)
                else:
                    queue.append((move, count + 1))  # +1, -1 이동은 1초 걸리므로 뒤에 추가

    return -1  # 도달 불가능한 경우 (이 문제에서는 발생하지 않음)

print(bfs())

# -----------------------------------------------------
# ✅ 백준 제출용 최종 정답 코드 🚀
# - `sys.stdin.readline()`을 활용하여 빠르게 입력 처리 가능 (현재는 `input()` 사용)
# - `visited` 배열을 활용하여 BFS 탐색 중복을 방지.
# - `deque.appendleft()`를 사용하여 순간이동(0초)을 우선적으로 처리하여 최적화.
#
# ✅ 2단계에서 틀렸던 점:
# 1️⃣ **`0 <= move <= 100001` → `IndexError` 발생 가능**
#    - 기존 코드에서는 `<= 100001`로 되어 있어 `visited[100001]` 접근 시 오류 발생.
#    - 해결 방법: `0 <= move < 100001`로 수정하여 안전하게 탐색.
#
# 2️⃣ **BFS에서 순간이동(0초)를 최우선 처리하지 않음**
#    - 기존 코드에서는 모든 이동을 같은 우선순위로 처리하여 불필요한 연산 발생.
#    - 해결 방법: `move == prev * 2` 인 경우 `queue.appendleft()`로 우선 탐색.
#
# ✅ 요청한 BFS 힌트:
# 🔹 **BFS를 활용한 최단 거리 탐색 개념**
#    - 일반적인 BFS에서는 `queue.append()`를 사용하여 `FIFO(First In, First Out)` 방식으로 탐색.
#    - 이 문제는 **가중치 0(순간이동)과 가중치 1(이동)이 혼합된 최단 경로 문제**이므로,
#      `deque.appendleft()`를 사용하여 가중치 0을 우선 탐색.
#
# 🔹 **BFS 탐색 과정 예제 (`N=5, M=17`)**
#    ```
#    1️⃣ (5) → (10, 0초) → (9, 1초) → (11, 1초)
#    2️⃣ (10) → (20, 0초) → (18, 1초)
#    3️⃣ (20) → (40, 0초) → (19, 1초)
#    4️⃣ (40) → (80, 0초) → (17, 1초)  → 도착 🎯
#    ```
#    결과: `2초` (5 → 10 → 20 → 17)
#
# ✅ 최종 코드에서 수정한 점:
# - `visited`를 사용하여 중복 탐색 방지.
# - `deque.appendleft()`를 활용하여 순간이동을 우선 탐색하여 최적화.
# - 도착 지점에서 즉시 종료 (`if prev == M: return count`).
# -----------------------------------------------------
