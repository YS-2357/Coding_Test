# 백준 1697번: 숨바꼭질 (BFS - 최단 거리 탐색)
# -----------------------------------------------------
# ✅ 문제 설명:
# - 수빈이는 현재 점 N에 위치해 있고, 동생은 점 K에 위치해 있다.
# - 수빈이는 1초 후 3가지 선택을 할 수 있다:
#   1) `N - 1` (1초 후 왼쪽으로 이동)
#   2) `N + 1` (1초 후 오른쪽으로 이동)
#   3) `N * 2` (1초 후 순간이동)
# - 동생의 위치 K로 가장 빠르게 이동하는 최소 시간을 구하는 문제.
#
# ✅ 입력 형식:
# - 첫 번째 줄에 정수 N, K (0 ≤ N, K ≤ 100,000) 가 주어진다.
#
# ✅ 출력 형식:
# - 수빈이가 K에 도착하는 데 걸리는 최소 시간을 출력한다.
#
# ✅ 입출력 예제:
# 🔹 예제 입력 1:
#   5 17
# 🔹 예제 출력 1:
#   4
# -----------------------------------------------------

import sys
from collections import deque

# ✅ 입력 처리
N, K = map(int, sys.stdin.readline().split())
visited = [False] * 100001  # 방문 체크 배열
moves = [(lambda x: x + 1), (lambda x: x - 1), (lambda x: x * 2)]  # 가능한 이동 연산

# ✅ BFS 탐색 함수 (최단 거리 계산)
def bfs(start, end):
    if start == end:  # ✅ 시작 위치와 목표 위치가 같으면 0초 소요
        return 0
    
    queue = deque([(start, 0)])  # ✅ 시작 위치와 이동 횟수 저장
    visited[start] = True  # ✅ 방문 체크
    
    while queue:
        x, count = queue.popleft()  # ✅ 현재 위치, 이동 횟수 꺼내기
        
        for move in moves:
            nx = move(x)  # ✅ 다음 위치 계산
            
            if 0 <= nx < 100001 and not visited[nx]:  # ✅ 범위 내에서 방문하지 않은 곳이면 이동
                if nx == end:  # ✅ 목표 위치에 도달하면 즉시 반환
                    return count + 1
                queue.append((nx, count + 1))
                visited[nx] = True  # ✅ 방문 체크
  return -1

# ✅ 결과 출력
print(bfs(N, K))

# -----------------------------------------------------
# ✅ 백준 제출용 최종 정답 코드 🚀
# - `sys.stdin.readline()`을 활용하여 빠르게 입력 처리.
# - `visited` 배열을 사용하여 BFS 탐색을 최적화.
# - `moves` 리스트를 활용하여 코드 가독성을 향상.
# - `queue.popleft()`를 사용하여 BFS 탐색을 수행 (FIFO).
#
# ✅ 2단계에서 틀렸던 점:
# 1️⃣ **`queue` 초기화 오류 (`TypeError` 발생)**
#    - 기존 코드에서 `queue = deque([start, 0])`을 사용하여 잘못된 리스트 초기화가 발생.
#    - 해결 방법: `queue = deque([(start, 0)])`로 변경하여 튜플 형태로 저장.
#
# 2️⃣ **BFS 탐색 중 목표 지점에 도착해도 루프가 계속 실행됨**
#    - 기존 코드에서는 목표 지점에 도착한 후에도 추가 탐색이 진행될 가능성이 있었음.
#    - 해결 방법: `if nx == end:` 조건을 만족하면 즉시 `return count + 1`로 종료.
#
# 3️⃣ **`return None` 발생 가능성**
#    - 기존 코드에서는 `while queue:` 루프가 끝나도 반환값이 없었음.
#    - 해결 방법: 예외 처리를 위해 `return -1`을 추가하여 모든 경우를 대비.
#
# ✅ BFS 탐색 원리:
# - BFS는 "최단 경로" 문제를 해결할 때 사용된다.
# - `queue`를 활용하여 가장 먼저 도달한 경우가 최단 거리임을 보장한다.
#
# ✅ BFS 탐색 과정 예제 (`N=5`, `K=17`):
#    ```
#    1️⃣ (5,0) → (6,1), (4,1), (10,1) 탐색
#    2️⃣ (6,1) → (7,2), (5,2), (12,2) 탐색
#    3️⃣ (10,1) → (11,2), (9,2), (20,2) 탐색
#    4️⃣ (9,2) → (10,3), (8,3), (18,3) 탐색
#    5️⃣ (17,4) 도착 🎯 → 이동 횟수: `4`
#    ```
#
# ✅ 최종 코드에서 수정한 점:
# - `queue` 초기화 오류 수정 (`deque([(start, 0)])`)
# - BFS 종료 조건 추가 (`if nx == end: return count + 1`)
# - 예외 처리를 위한 `return -1` 추가
# - `visited` 배열을 활용하여 중복 방문을 방지
# -----------------------------------------------------
