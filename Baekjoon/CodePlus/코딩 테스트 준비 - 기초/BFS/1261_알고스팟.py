# 1261_알고스팟.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - N×M 크기의 미로에서 (1,1) → (N,M)까지 이동하는 최단 경로 찾기.
# - 이동 중 벽(1)이 있는 경우 부수고 이동해야 하며, 벽(0)은 그대로 이동 가능.
# - 벽을 최소한으로 부수고 (N,M)에 도착할 때의 최소 벽 부수기 횟수를 구하는 문제.
#
# ✅ 입력 형식:
# - 첫 줄에 `M, N (1 ≤ M, N ≤ 100)`이 주어진다.
# - 이후 `N`개의 줄에 `M`개의 0 또는 1로 이루어진 미로가 주어진다.
#   - `0`: 이동 가능 (벽 없음)
#   - `1`: 이동 불가능 (벽 있음, 부숴야 이동 가능)
#
# ✅ 출력 형식:
# - 시작점 `(1,1)`에서 도착점 `(N,M)`까지 이동하는 **최소 벽 부수기 횟수**를 출력.
#
# ✅ 입출력 예제:
# 🔹 예제 입력 1:
#   3 3
#   011
#   111
#   110
# 🔹 예제 출력 1:
#   2
# -----------------------------------------------------

import sys
from collections import deque

# 방향 벡터 (상, 하, 좌, 우)
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

# 입력 받기 (M: 가로, N: 세로)
M, N = map(int, sys.stdin.readline().split())

# 미로 정보 입력 (0: 이동 가능, 1: 벽)
maze = [list(map(int, sys.stdin.readline().strip())) for _ in range(N)]

# 가중치 저장 배열 (최소 벽 부수기 횟수 저장, 미방문 시 -1)
dist = [[-1] * M for _ in range(N)]

# BFS 탐색을 위한 deque 초기화
queue = deque([(0, 0)])  # 시작점 (0,0)
dist[0][0] = 0  # 시작점 가중치 초기화

# 0-1 BFS 수행
while queue:
    x, y = queue.popleft()  # 현재 위치 (x, y)

    # 네 방향 탐색 (상, 하, 좌, 우)
    for direction in range(4):
        nx = x + dx[direction]
        ny = y + dy[direction]

        # 미로 범위 내에 있고, 방문하지 않은 경우
        if 0 <= nx < N and 0 <= ny < M and dist[nx][ny] == -1:
            if maze[nx][ny] == 0:  # 벽이 없는 경우 (우선순위 높음)
                dist[nx][ny] = dist[x][y]
                queue.appendleft((nx, ny))  # 먼저 처리 (가중치 유지)
            else:  # 벽이 있는 경우 (우선순위 낮음)
                dist[nx][ny] = dist[x][y] + 1
                queue.append((nx, ny))  # 나중에 처리 (가중치 증가)

# 최소 벽 부수기 횟수 출력 (목표 지점)
print(dist[N-1][M-1])

# -----------------------------------------------------
# ✅ 2단계에서 틀렸던 점:
# 1️⃣ **`maze` 입력이 잘못된 형태로 저장됨**
#    - `maze = [list(map(int, sys.stdin.readline().strip()))]` (❌)
#    - ✅ **해결 방법**: `for _ in range(N)`을 사용하여 `N`개의 행을 저장하도록 변경.
#    
# 2️⃣ **우선순위 큐 사용 대신 `deque` 사용 시 가중치 처리 오류**
#    - 기존 코드에서는 벽이 있는 경우에도 `appendleft()`를 사용하여 우선 처리되었음.  
#    - ✅ **해결 방법**:  
#      - 벽이 없는 경우 (`0`): `appendleft()`로 먼저 처리  
#      - 벽이 있는 경우 (`1`): `append()`로 나중에 처리  
#      
# 3️⃣ **목표 도착 지점 `(N-1, M-1)`을 올바르게 참조해야 함**
#    - 기존 코드에서 `if x == (M-1) and y == (N-1)` (❌)  
#    - ✅ **해결 방법**: `if x == (N-1) and y == (M-1)` (✔)
#
# -----------------------------------------------------
# ✅ 요청한 BFS 힌트:
# 🔹 **가중치가 있는 BFS (0-1 BFS) 개념**
# - **일반적인 BFS**는 `queue.append()`만 사용하여 모든 이동을 동일한 가중치로 처리.  
# - **0-1 BFS**는 `deque.appendleft()`와 `deque.append()`를 함께 사용하여 가중치 순위 조정 가능.  
#
# 🔹 **BFS 탐색 과정 예제 (`3x3` 미로에서 `(0,0)` → `(2,2)`)**
# ```
# 초기 상태:
# 011
# 111
# 110
#
# 1️⃣ (0,0) → (0,1) → (1,0) → (0,2) (벽 부숨: 0 → 1)
# 2️⃣ (1,0) → (2,0) (벽 부숨: 1 → 2)
# 3️⃣ (2,0) → (2,1) → (2,2) (도착, 벽 부숨: 2)
# 🔹 결과: `2`
# ```
#
# -----------------------------------------------------
# ✅ 최종 코드에서 수정한 점:
# ✅ `dist` 배열을 사용하여 최소 벽 부수기 횟수 저장
# ✅ 우선순위를 `queue.appendleft()`와 `queue.append()`로 조정
# ✅ `if x == (N-1) and y == (M-1)` 조건을 정확하게 수정
# ✅ 입력을 빠르게 처리하기 위해 `sys.stdin.readline()` 사용
# -----------------------------------------------------
