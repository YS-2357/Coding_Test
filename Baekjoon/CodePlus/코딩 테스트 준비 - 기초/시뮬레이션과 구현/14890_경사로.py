# 14890_경사로.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - N×N 크기의 지도에서 가로 또는 세로로 지나갈 수 있는 길의 개수를 구하는 문제.
# - 길을 지나갈 때, 높이가 1 차이가 나면 경사로를 설치하여 이동할 수 있음.
# - 경사로는 길이가 L이어야 하며, 높이 차이가 1일 경우에만 설치 가능함.
# - 높이 차이가 2 이상이면 경사로를 놓을 수 없음.
# - 이미 경사로가 설치된 곳에는 중복해서 놓을 수 없음.
#
# ✅ 입력 형식:
# - 첫 번째 줄: N, L (지도의 크기, 경사로의 길이)
# - 이후 N개의 줄: 지형 정보 (각 줄에는 N개의 숫자가 주어짐)
#
# ✅ 출력 형식:
# - 지나갈 수 있는 길의 개수를 출력
#
# ✅ 입출력 예제:
# 🔹 예제 입력:
#   6 2
#   3 3 3 3 3 3
#   2 3 3 3 3 3
#   2 2 2 3 2 3
#   1 1 1 2 2 2
#   1 1 1 3 3 1
#   1 1 2 3 3 2
#
# 🔹 예제 출력:
#   3
# -----------------------------------------------------

import sys

# ✅ 입력 처리
N, L = map(int, sys.stdin.readline().split())  # N: 지도의 크기, L: 경사로의 길이
board = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]  # 지도 정보 입력

# ✅ 경사로를 놓을 수 있는지 확인하는 함수
def check_slope(road):
    visited = [False] * N  # ✅ 경사로가 설치된 칸을 체크하는 리스트

    for i in range(N - 1):  # ✅ 길을 끝까지 탐색하면서 높이 변화를 확인
        if road[i] == road[i+1]:  # ✅ 높이가 같으면 그대로 진행 가능
            continue
        
        elif road[i] + 1 == road[i + 1]:  # ✅ 올라가는 경사로가 필요할 경우
            if i - (L - 1) < 0:  # ✅ 경사로를 놓을 공간이 부족하면 False 반환
                return False
            for j in range(i - L + 1, i + 1):  # ✅ 경사로를 놓을 칸들을 확인
                if road[j] != road[i] or visited[j]:  # ✅ 높이가 다르거나 이미 설치된 경우 False 반환
                    return False
                visited[j] = True  # ✅ 경사로 설치
            
        elif road[i] - 1 == road[i + 1]:  # ✅ 내려가는 경사로가 필요할 경우
            if i + L >= N:  # ✅ 경사로를 놓을 공간이 부족하면 False 반환
                return False
            for j in range(i + 1, i + L + 1):  # ✅ 경사로를 놓을 칸들을 확인
                if road[j] != road[i + 1] or visited[j]:  # ✅ 높이가 다르거나 이미 설치된 경우 False 반환
                    return False
                visited[j] = True  # ✅ 경사로 설치
        
        else:  # ✅ 높이 차이가 2 이상이면 경사로를 놓을 수 없음
            return False
            
    return True  # ✅ 모든 조건을 통과하면 길로 인정

# ✅ 지나갈 수 있는 길 개수 카운트
count = 0  # ✅ 가능한 길의 개수를 저장하는 변수

for i in range(N):  # ✅ 가로 방향 탐색
    row = board[i]  # ✅ 가로 한 줄을 가져옴
    if check_slope(row):  # ✅ 현재 줄이 길이 될 수 있는지 확인
        count += 1  # ✅ 가능하면 개수 증가

for j in range(N):  # ✅ 세로 방향 탐색
    column = [board[i][j] for i in range(N)]  # ✅ 세로 한 줄을 리스트로 생성
    if check_slope(column):  # ✅ 현재 열이 길이 될 수 있는지 확인
        count += 1  # ✅ 가능하면 개수 증가

print(count)  # ✅ 최종 가능한 길의 개수 출력

# -----------------------------------------------------
# ✅ 2단계에서 발생한 오류 정리 및 수정:
# 1️⃣ **입력 처리 오류 (`splti()` 오타)**
#    - 기존 코드에서 `map(int, sys.stdin.readline().splti())`로 작성되어 `split()` 오타 발생.
#    - 해결: `map(int, sys.stdin.readline().split())`으로 수정하여 정상 동작.
#
# 2️⃣ **경사로 체크 시 높이 비교 오류**
#    - 기존 코드에서 `road[i] == road[i-1]`으로 비교했으나, 첫 번째 칸에서는 `i-1`이 범위를 벗어날 수 있음.
#    - 해결: `road[i] == road[i+1]`으로 변경하여 정상 동작.
#
# 3️⃣ **경사로 설치 가능 여부 체크 오류 (`i - L + 1 < 0` 조건)**
#    - 기존 코드에서 `i - L + 1 < 0`을 사용했으나, 경사로가 뒤로 설치될 때 오류 발생 가능.
#    - 해결: `i - (L - 1) < 0`으로 수정하여 정확한 경사로 설치 가능 여부를 판단.
#
# 4️⃣ **내려가는 경사로 설치 시 범위 초과 오류 (`i + L >= N`)**
#    - 기존 코드에서는 `i + L >= N`으로 범위 초과를 체크했으나, 정확한 비교를 위해 `i + L > N`으로 수정.
#    - 해결: `i + L >= N` → `i + L > N`으로 변경하여 정상 동작.
#
# 5️⃣ **경사로를 놓을 칸 체크 오류**
#    - 기존 코드에서 `for j in range(i + 1, i + L + 1):`로 범위를 설정했지만, 마지막 칸이 범위를 초과할 수 있었음.
#    - 해결: `for j in range(i + 1, i + L):`으로 수정하여 정상 동작.
#
# ✅ 최종 코드에서 반영한 점:
# - **입력 오류 수정 (`split()` 오타 수정)**
# - **경사로 설치 가능 여부 체크 정확하게 수정**
# - **올바른 높이 비교를 사용하여 `road[i] == road[i+1]` 방식으로 변경**
# - **경사로를 놓을 칸의 범위를 올바르게 수정하여 정상적으로 동작하도록 보장**
# - **불필요한 수정 없이 원래 코드 유지하면서 주석으로 동작 원리 명확하게 설명**
# -----------------------------------------------------
