# 14503_로봇_청소기.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - 로봇 청소기가 N×M 직사각형 방의 칸을 청소하려고 한다.
# - 청소기는 빈 칸(0)과 벽(1)으로 이루어진 방 안에서 다음 규칙대로 작동한다:
#   1. 현재 칸이 아직 청소되지 않은 경우, 현재 칸을 청소한다.
#   2. 현재 방향 기준 왼쪽부터 차례대로 탐색하면서:
#       - 청소되지 않은 빈 칸이 있는 경우 → 왼쪽으로 회전 → 한 칸 전진 → 1번부터 반복
#       - 네 방향 모두 청소가 되어 있거나 벽인 경우 → 후진
#   3. 후진하려는 칸이 벽이면 작동을 멈춘다.
#
# ✅ 입력 형식:
# - 첫 줄: N(세로), M(가로)
# - 둘째 줄: 로봇의 위치 (r, c)와 방향 d (0:북, 1:동, 2:남, 3:서)
# - 이후 N줄: 방 상태 (0:빈 칸, 1:벽)
#
# ✅ 출력 형식:
# - 청소기가 청소하는 칸의 수를 출력
#
# ✅ 입출력 예제:
# 입력 예시:
# 3 3
# 1 1 0
# 1 1 1
# 1 0 1
# 1 1 1
# 출력 예시:
# 1
# -----------------------------------------------------

import sys

# ✅ N: 세로, M: 가로
N, M = map(int, sys.stdin.readline().split())

# ✅ r: 로봇 시작 행, c: 열, d: 방향
r, c, d = map(int, sys.stdin.readline().split())

# ✅ 방 상태 입력 (0: 청소 가능, 1: 벽)
room = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]

# ✅ 청소 여부 기록
cleaned = [[False] * M for _ in range(N)]

# ✅ 북 동 남 서 순으로 방향 벡터 설정
dx = [-1, 0, 1, 0]  # 행 이동
dy = [0, 1, 0, -1]  # 열 이동

# ✅ 청소한 칸 개수
count = 0

while True:
    # 1번 조건: 현재 칸이 청소되지 않았으면 청소
    if not cleaned[r][c]:
        cleaned[r][c] = True  # 청소 표시
        count += 1            # 청소 횟수 증가

    found = False  # 4방향 중 청소할 칸을 찾았는지 여부

    # 2번 조건: 4방향을 차례대로 확인 (반시계 방향으로)
    for _ in range(4):
        d = (d + 3) % 4  # 왼쪽으로 회전
        nx = r + dx[d]   # 회전한 방향으로 이동할 행
        ny = c + dy[d]   # 회전한 방향으로 이동할 열

        # 범위 내이고, 청소 안 했고, 벽이 아니라면 이동
        if 0 <= nx < N and 0 <= ny < M:
            if room[nx][ny] == 0 and not cleaned[nx][ny]:
                r, c = nx, ny  # 이동
                found = True
                break

    # 2번 조건 실패: 네 방향 모두 청소 못하면 → 후진
    if not found:
        back_dir = (d + 2) % 4  # 현재 방향의 반대 방향
        bx = r + dx[back_dir]
        by = c + dy[back_dir]

        # 후진할 칸이 벽이면 작동 종료
        if room[bx][by] == 1:
            break
        else:
            r, c = bx, by  # 벽 아니면 후진

# ✅ 정답 출력
print(count)

# -----------------------------------------------------
# ✅ 백준 제출용 최종 정답 코드 🚀
# - `sys.stdin.readline()`을 사용하여 빠르게 입력 처리.
# - 방향 회전은 `(d + 3) % 4` 를 사용하여 반시계 방향 구현.
# - 청소 상태를 `cleaned` 2차원 배열로 관리.
# - 후진 조건 시 벽 여부 검사 후 종료 여부 판단.
#
# ✅ 2단계에서 틀렸던 점 정리:
# 1️⃣ `count += 1` 줄의 **들여쓰기 오류 (IndentationError)** → 한 단계 더 들여씀.
# 2️⃣ `ny = c + dx[d]` → 오타로 `dy[d]`가 되어야 함 (의도한 열 방향이 아님).
#
# ✅ 2단계에서 요청한 힌트:
# 🔹 **로직 흐름**: 왼쪽부터 탐색, 전진/후진 조건, 방향 회전 로직.
# 🔹 **왜 DFS/BFS를 쓰지 않는가?**
#     - 시뮬레이션 문제로 "규칙대로 한 단계씩 움직이며 상태 변화"를 구현하는 것이 핵심.
#     - 방문 순서가 중요하지 않고, 복잡한 탐색 구조가 필요하지 않기 때문.
# -----------------------------------------------------
