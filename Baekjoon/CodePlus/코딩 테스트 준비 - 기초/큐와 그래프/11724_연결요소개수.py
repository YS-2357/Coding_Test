# 백준 11724번: 연결 요소의 개수 (그래프 탐색 - DFS)
# -----------------------------------------------------
# ✅ 문제 설명:
# - N개의 정점(1번 ~ N번)과 M개의 간선이 주어진다.
# - 주어진 무방향 그래프에서 연결 요소(Connected Component)의 개수를 구하는 문제.
#
# ✅ 입력 형식:
# - 첫 번째 줄에 정수 N, M (1 ≤ N ≤ 1,000, 0 ≤ M ≤ N × (N - 1) / 2) 가 주어진다.
# - 이후 M개의 줄에 두 정수 A, B가 주어진다. (1 ≤ A, B ≤ N)
# - 간선은 무방향이며, 같은 간선이 여러 번 주어지지 않음.
#
# ✅ 출력 형식:
# - 연결 요소의 개수를 출력.
#
# ✅ 입출력 예제:
# 🔹 예제 입력:
#   6 5
#   1 2
#   2 5
#   5 1
#   3 4
#   4 6
# 🔹 예제 출력:
#   2
# -----------------------------------------------------

import sys
from collections import deque

# ✅ 입력 처리
N, M = map(int, sys.stdin.readline().split())
graph = [[] for _ in range(N+1)]  # 그래프 인접 리스트 초기화

# ✅ 그래프 입력 (무방향 그래프)
for _ in range(M):
    A, B = map(int, sys.stdin.readline().split())  # `.split()` 추가하여 정수 변환
    graph[A].append(B)
    graph[B].append(A)

# ✅ DFS 탐색 함수 (재귀 방식)
def dfs(start):
    visited[start] = True  # 현재 노드 방문 체크
    for neighbor in graph[start]:  # 인접 노드 탐색
        if not visited[neighbor]:  # 방문하지 않은 노드만 탐색
            dfs(neighbor)

# ✅ 연결 요소 개수 계산
visited = [False] * (N+1)  # 방문 배열 초기화
count = 0  # 연결 요소 개수

for i in range(1, N+1):  # ✅ 모든 노드를 탐색하면서 방문하지 않은 경우 DFS 실행
    if not visited[i]:  # ✅ 방문하지 않은 노드를 발견하면 새로운 연결 요소
        dfs(i)
        count += 1  # ✅ 새로운 연결 요소를 찾았으므로 카운트 증가

# ✅ 결과 출력 (연결 요소 개수)
print(count)  # ✅ 최종 정답 출력

# -----------------------------------------------------
# ✅ 백준 제출용 최종 정답 코드
# - `sys.stdin.readline()`을 활용하여 빠르게 입력 처리
# - `graph`를 인접 리스트로 구현하여 탐색 최적화
# - DFS를 사용하여 연결 요소 개수를 계산함
#
# ✅ 2단계에서 틀렸던 점:
# 1️⃣ **DFS 호출 오류 (`dfs[neighbor]` → `dfs(neighbor)`)**
#    - 기존 코드에서 `dfs[neighbor]`를 사용하여 리스트 호출 오류 발생.
#    - 해결 방법: `dfs(neighbor)`로 올바르게 재귀 호출.
#
# 2️⃣ **카운트(`count += 1`) 증가 논리 오류**
#    - 기존 코드에서는 DFS 호출 시 `count += 1`이 없었음.
#    - 해결 방법: **새로운 연결 요소를 탐색할 때마다 `count += 1` 추가.**
#
# ✅ 요청한 DFS 힌트:
# 🔹 **DFS (깊이 우선 탐색) 동작 방식**
#    - 현재 노드에서 **가능한 모든 경로를 탐색**하며, 더 깊이 이동할 수 있는 경로를 우선적으로 탐색.
#    - **스택(LIFO) 방식처럼 작동**하며, 백트래킹을 사용하여 되돌아감.
#    - **예제 탐색 과정 (입력: 6 5)**
#      ```
#      1 → 2 → 5 (백트래킹) → 3 → 4 → 6
#      결과: 연결 요소 개수 = 2
#      ```
#
# 🔹 **BFS (너비 우선 탐색)로도 해결 가능**
#    - BFS를 사용하면 큐(Queue)를 활용하여 **가까운 노드부터 탐색**.
#    - BFS 탐색을 수행하면서 방문하지 않은 새로운 연결 요소를 찾으면 `count += 1` 수행.
#
# ✅ 최종 코드에서 수정한 점:
# - DFS 탐색 결과를 `print(count)`로 한 번만 출력.
# - `visited` 배열을 사용하여 중복 방문을 방지.
# - 입력을 빠르게 처리하기 위해 `sys.stdin.readline()`을 사용함.
# -----------------------------------------------------
