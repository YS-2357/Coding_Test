# 백준 2178번: 미로 탐색 (BFS - 최단 경로 탐색)
# -----------------------------------------------------
# ✅ 문제 설명:
# - N×M 크기의 미로에서 (1,1) → (N,M)까지의 최단 경로 찾기.
# - 0은 이동 불가능한 벽, 1은 이동 가능한 길.
# - 상하좌우로 이동 가능하며, 최단 경로 길이를 출력.
#
# ✅ 입력 형식:
# - 첫 번째 줄에 미로 크기 N, M (2 ≤ N, M ≤ 100)
# - 이후 N개의 줄에 M개의 숫자(0 또는 1)가 주어짐.
#
# ✅ 출력 형식:
# - (1,1) → (N,M)까지 이동하는 "최단 경로 길이" 출력.
#
# ✅ 입출력 예제:
# 🔹 예제 입력:
#   4 6
#   101111
#   101010
#   101011
#   111011
# 🔹 예제 출력:
#   15
# -----------------------------------------------------

import sys
from collections import deque

# ✅ 입력 처리
N, M = map(int, sys.stdin.readline().split())
grid = [list(map(int, sys.stdin.readline().strip())) for _ in range(N)]  # ✅ 문자열 입력을 리스트로 변환

# ✅ BFS를 위한 방향 벡터 (좌, 우, 상, 하)
dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

# ✅ BFS 탐색 함수 (최단 거리 계산)
def bfs(x, y):  
    queue = deque([(x, y)])  # ✅ 시작 좌표 추가

    while queue:
        x, y = queue.popleft()

        for direction in range(4):  # ✅ 4방향 탐색
            nx = x + dx[direction]
            ny = y + dy[direction]

            if nx == (N-1) and ny == (M-1):  # ✅ 도착점에 도착하면 최단 거리 반환
                return grid[x][y] + 1
            
            if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == 1:  # ✅ 이동 가능하면
                queue.append((nx, ny))  # ✅ 큐에 추가하여 탐색 지속
                grid[nx][ny] = grid[x][y] + 1  # ✅ 거리 정보 업데이트

# ✅ BFS 실행 및 최단 경로 출력
print(bfs(0,0))

# -----------------------------------------------------
# ✅ 백준 제출용 최종 정답 코드
# - `sys.stdin.readline()`을 활용하여 빠르게 입력 처리.
# - `grid`를 2D 리스트로 변환하여 관리.
# - BFS를 사용하여 최단 경로 탐색.
#
# ✅ 2단계에서 틀렸던 점:
# 1️⃣ **`nx`, `ny` 변수를 선언하기 전에 참조하여 `UnboundLocalError` 발생**
#    - 기존 코드에서 `nx`와 `ny`를 `for`문 이전에 검사하여 오류 발생.
#    - 해결 방법: `if nx == (N-1) and ny == (M-1)` 조건을 `for`문 내부로 이동하여 올바르게 검사.
#
# 2️⃣ **`grid[x][y] = 0` 방문 처리 방식 오류**
#    - 기존 코드에서 `grid[x][y] = 0`으로 방문 처리하여, 원래 거리 정보가 사라짐.
#    - 해결 방법: `grid[nx][ny] = grid[x][y] + 1`으로 올바르게 거리 정보를 유지하도록 변경.
#
# ✅ 요청한 BFS 힌트:
# 🔹 **BFS를 활용한 `grid` 탐색 개념**
#    - 모든 `1`을 찾아 BFS 실행하여 최단 경로를 계산.
#    - BFS 탐색 중 `1`을 `이전 거리 +1`로 변경하여 방문을 처리함.
#    - 목표 지점 `(N-1, M-1)`에 도착하면 현재 `grid` 값이 최단 거리.
#
# 🔹 **BFS 탐색 과정 예제**
#    ```
#    101111
#    101010
#    101011
#    111011
#    ```
#    1️⃣ (1,1)에서 BFS 시작 → (2,1) → (3,1) → (4,1) → ...
#    2️⃣ (N,M)에 도착하면 현재 위치의 값이 최단 거리 값이 됨.
#    🔹 결과: `15`
#
# ✅ 최종 코드에서 수정한 점:
# - `grid` 변환 방식을 `strip()`을 활용하여 올바르게 변환.
# - BFS 탐색 중 방문한 위치를 `grid[nx][ny] = grid[x][y] + 1`로 변경하여 거리 정보 유지.
# - 최단 경로를 구하는 방식이 올바르게 동작하도록 코드 수정.
# -----------------------------------------------------
