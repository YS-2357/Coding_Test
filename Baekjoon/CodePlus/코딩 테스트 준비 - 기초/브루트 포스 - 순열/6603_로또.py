# 백준 6603번: 로또
# 문제 설명:
# 6개의 수를 골라서 만들 수 있는 모든 조합을 출력하는 문제.
# - 입력으로 주어지는 숫자들은 사전순으로 정렬되어 있음.
# - 출력도 사전순으로 정렬된 조합을 한 줄에 하나씩 출력해야 함.
# - 마지막 입력이 `0`이면 종료.

# 입력 형식:
# - 여러 개의 테스트 케이스가 주어짐.
# - 각 테스트 케이스의 첫 번째 숫자는 `k (6 < k < 13)`, 이후 `k`개의 숫자가 주어짐.
# - 입력의 마지막 줄에는 `0`이 주어지며 종료.

# 출력 형식:
# - 각 테스트 케이스에서 가능한 모든 조합을 한 줄씩 출력.
# - 각 테스트 케이스가 끝날 때마다 빈 줄 출력.

# 예제 입력 1:
# 7 1 2 3 4 5 6 7
# 8 1 2 3 5 8 13 21 34
# 0
# 예제 출력 1:
# 1 2 3 4 5 6
# 1 2 3 4 5 7
# ...
# 3 5 8 13 21 34

import sys  # 빠른 입력 처리를 위한 sys 모듈 사용

# ✅ 조합을 찾는 재귀 함수 (백트래킹 활용)
def lottery(start, current):
    if len(current) == 6:  # ✅ 6개의 숫자를 선택하면 출력
        print(*current)  
        return
    
    for i in range(start, N):  # ✅ 중복 없이 숫자를 선택하는 조합 생성
        lottery(i + 1, current + [nums[i]])  # ✅ 다음 숫자를 선택하여 재귀 호출

# ✅ 입력을 처리하는 루프
first_case = True  # ✅ 첫 번째 테스트 케이스인지 확인하는 변수
while True:
    nums = list(map(int, sys.stdin.readline().split()))  # ✅ 한 줄 입력 받기
    if nums[0] == 0:  # ✅ 입력이 0이면 종료
        break
        
    if not first_case:  # ✅ 첫 번째 테스트 케이스가 아니라면 빈 줄 출력
        print()
    first_case = False  # ✅ 첫 번째 케이스 처리 완료
    
    N = nums[0]  # ✅ 첫 번째 숫자는 k (사용할 숫자의 개수)
    nums = nums[1:]  # ✅ 나머지 숫자들만 저장
    lottery(0, [])  # ✅ 조합 탐색 시작


# -----------------------------------------------------
# ❌ 내가 처음 쓴 코드부터 맞을 때까지 틀렸던 점

# 1. ✅ 불필요한 `selected` 리스트 사용
#    - 기존 코드:
#      ```python
#      if not selected[i]:
#          selected[i] = True
#          lottery(i + 1, current + [nums[i]])
#          selected[i] = False
#      ```
#    - ❌ 문제점: 조합(Combination)은 중복을 고려하지 않으므로 방문 체크 필요 없음.
#    - ✅ 수정: `selected` 제거하고 `for i in range(start, N):`만 사용.

# 2. ✅ 출력 형식 오류 (`print("\n")` 사용 문제)
#    - 기존 코드:
#      ```python
#      print("\n")
#      ```
#    - ❌ 문제점: 마지막 출력 이후에도 빈 줄이 추가됨.
#    - ✅ 수정: `if not first_case: print()` 조건을 추가하여 마지막 개행 방지.

# ✅ 위 수정 후 실행하면 백준에서 정답 판정! 🚀 
