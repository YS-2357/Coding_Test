# 백준 9095번: 1, 2, 3 더하기 (브루트포스 - 재귀)
# 문제 설명:
# - 정수 n을 1, 2, 3의 합으로 나타내는 방법의 개수를 구하는 문제.
# - 순서가 다르면 다른 방법으로 인정함.
# - 예: n = 4일 경우 (7가지 방법 존재)
#   (1+1+1+1), (1+1+2), (1+2+1), (2+1+1), (2+2), (1+3), (3+1)

import sys  # ✅ 빠른 입력 처리를 위한 sys 모듈 사용

# ✅ 입력 처리
T = int(sys.stdin.readline())  # 테스트 케이스 개수 입력

# ✅ 테스트 케이스 입력 받기
nums = [int(sys.stdin.readline()) for _ in range(T)]  # 각 테스트 케이스에서 n 입력 받기

def count_ways(n):
    """ 재귀를 사용하여 n을 1, 2, 3의 합으로 나타내는 방법의 개수를 구하는 함수 """

    # ✅ 종료 조건
    if n == 0:
        return 1  # n을 정확히 0으로 만드는 방법이 하나 존재
    if n < 0:
        return 0  # n이 음수가 되면 불가능하므로 방법 없음

    # ✅ 1, 2, 3을 각각 더하는 경우를 탐색
    return count_ways(n - 1) + count_ways(n - 2) + count_ways(n - 3)

# ✅ 각 테스트 케이스별 결과 출력
for num in nums:
    print(count_ways(num))  # ✅ n을 만들 수 있는 경우의 수 출력

# -----------------------------------------------------
# ✅ 2단계에서 내가 틀렸던 점:
# 1. ✅ 종료 조건을 명확히 하지 않아서 재귀가 무한 루프에 빠질 가능성이 있었음.
#    - 기존 코드: 종료 조건 없이 재귀가 호출됨.
#    - ✅ 해결: `if n == 0: return 1`, `if n < 0: return 0` 조건 추가.
#
# 2. ✅ 입력 방식을 잘못 사용하여 한 줄에서 여러 개 입력을 받음.
#    - 기존 코드: `nums = list(map(int, sys.stdin.readline().split()))`
#    - ✅ 해결: `nums = [int(sys.stdin.readline()) for _ in range(T)]`로 수정.
#
# ✅ 위 수정 후 실행하면 백준에서 정답 판정! 🚀
