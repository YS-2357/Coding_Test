# 백준 2133번: 타일 채우기 (다이나믹 프로그래밍 - O(N))
# -----------------------------------------------------
# ✅ 문제 설명:
# - 3×N 크기의 벽을 2×1, 1×2 타일로 채우는 경우의 수를 구하는 문제
# - N이 홀수일 경우 절대로 채울 수 없음 (출력: 0)
#
# ✅ 입력 형식:
# - 첫 번째 줄에 정수 N (1 ≤ N ≤ 30)이 주어진다.
#
# ✅ 출력 형식:
# - 3×N 크기의 벽을 타일로 채우는 경우의 수를 출력한다.
#
# ✅ 입출력 예제:
# 🔹 예제 입력 1:
#   2
# 🔹 예제 출력 1:
#   3
# -----------------------------------------------------

import sys

# ✅ 입력 처리
N = int(sys.stdin.readline())

# ✅ N이 홀수인 경우 불가능하므로 0 출력
if N % 2 == 1:
    print(0)
else:
    # ✅ DP 배열 초기화
    dp = [0] * (N + 1)
    dp[0] = 1  # ✅ 공집합 개념 (아무것도 채우지 않는 경우)
    dp[2] = 3  # ✅ 가장 작은 기본 경우 (타일을 채우는 3가지 방법 존재)

    # ✅ DP 테이블 채우기 (O(N))
    if N >= 4:
        for i in range(4, N+1, 2):
            dp[i] = 3 * dp[i-2] + 2  # ✅ 기본 패턴 (3배 증가 + 새로운 배치 추가)
            for j in range(2, i-2, 2):  # ✅ 이전 모든 패턴을 고려하여 추가 배치
                dp[i] += dp[j] * 2

    # ✅ 결과 출력
    print(dp[N])

# -----------------------------------------------------
# ✅ 2단계에서 발생했던 오류 정리 및 수정:
# 1. ✅ `dp[i] = 3 * dp[i-2]`만 사용하여 추가 배치를 고려하지 않아 틀렸음.
#    🔹 해결: `dp[i] = 3 * dp[i-2] + 2`로 수정하여 추가 패턴을 반영.
# 2. ❌ `for j in range(2, i-2, 2):`의 범위 문제는 발생하지 않았음.
#    🔹 이전에 잘못된 오류로 지적했으나, 실제로는 문제없이 동작함.
# 3. ✅ 1단계에서 점화식을 너무 자세히 제공한 문제 발생.
#    🔹 해결: 필수 개념만 제공하도록 수정하고, 점화식 유도는 사용자가 직접 하도록 유도.
#
# ✅ 3단계 최종 정답 코드 제공 완료 🚀
