# 백준 1149번: RGB거리 (다이나믹 프로그래밍 - DP)
# -----------------------------------------------------
# ✅ 문제 설명:
# - N개의 집이 일렬로 있으며, 빨강(R), 초록(G), 파랑(B) 중 하나로 색칠해야 함.
# - **서로 인접한 두 집이 같은 색을 가질 수 없음.**
# - 각 집을 특정 색으로 칠할 때의 비용이 주어질 때, 모든 집을 칠할 때의 **최소 비용**을 구하는 문제.
#
# ✅ 입력 형식:
# - 첫 번째 줄에 정수 N (2 ≤ N ≤ 1,000)이 주어진다.
# - 두 번째 줄부터 N개의 줄에 각 집을 빨강, 초록, 파랑으로 칠할 때 드는 비용이 주어진다.
#   (각 줄: R G B (1 ≤ R, G, B ≤ 1,000))
#
# ✅ 출력 형식:
# - 모든 집을 칠할 때의 최소 비용을 출력한다.
#
# ✅ 입출력 예제:
# 🔹 예제 입력 1:
#   3
#   26 40 83
#   49 60 57
#   13 89 99
#
# 🔹 예제 출력 1:
#   96
# -----------------------------------------------------

import sys

# ✅ 입력 처리
N = int(sys.stdin.readline())  # 집의 개수 입력
board = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]  # 각 집을 R, G, B로 칠할 때의 비용 입력

# ✅ DP 테이블 초기화
dp = [[0] * 3 for _ in range(N)]  # dp[i][0]: i번째 집을 빨강(R)으로 칠할 때 최소 비용
                                  # dp[i][1]: i번째 집을 초록(G)으로 칠할 때 최소 비용
                                  # dp[i][2]: i번째 집을 파랑(B)으로 칠할 때 최소 비용

# ✅ 첫 번째 집의 색칠 비용 초기화
dp[0][0] = board[0][0]  # 첫 번째 집을 빨강으로 칠할 때의 비용
dp[0][1] = board[0][1]  # 첫 번째 집을 초록으로 칠할 때의 비용
dp[0][2] = board[0][2]  # 첫 번째 집을 파랑으로 칠할 때의 비용

# ✅ DP 테이블 채우기 (Bottom-Up 방식)
for i in range(1, N):
    dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + board[i][0]  # 현재 집을 R로 칠할 경우
    dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + board[i][1]  # 현재 집을 G로 칠할 경우
    dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + board[i][2]  # 현재 집을 B로 칠할 경우

# ✅ 최소 비용 출력
print(min(dp[N-1]))  # 마지막 집의 R, G, B 중 최소 비용 선택

# -----------------------------------------------------
# ✅ 2단계에서 발생했던 오류 정리 및 수정:
# 1. ✅ `print(min(dp[N]))` → `print(min(dp[N-1]))`으로 수정 (인덱스 오류 방지).
# 2. ✅ DP 배열에서 각 집을 색칠할 때, 가능한 최소 비용을 갱신하는 방식 유지.
#
# ✅ 3단계 최종 정답 코드 제공 완료 🚀
