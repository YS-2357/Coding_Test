# 백준 2156번: 포도주 시식 (다이나믹 프로그래밍 - DP)
# -----------------------------------------------------
# ✅ 문제 설명:
# - N개의 포도주 잔이 일렬로 놓여 있음.
# - 한 번에 한 잔씩 포도주를 마실 수 있으며, **연속으로 3잔을 마실 수 없음**.
# - 마실 수 있는 포도주의 **최대 양**을 구하는 문제.
#
# ✅ 입력 형식:
# - 첫 번째 줄에 정수 N (1 ≤ N ≤ 10,000)이 주어진다.
# - 이후 N개의 줄에 각 포도주 잔에 들어있는 포도주의 양이 주어짐 (0 ≤ 양 ≤ 1,000).
#
# ✅ 출력 형식:
# - 마실 수 있는 포도주의 최대 양을 출력한다.
#
# ✅ 입출력 예제:
# 🔹 예제 입력 1:
#   6
#   6
#   10
#   13
#   9
#   8
#   1
#
# 🔹 예제 출력 1:
#   33
# -----------------------------------------------------

import sys

# ✅ 입력 처리
N = int(sys.stdin.readline())  # 포도주 잔 개수 입력
nums = [int(sys.stdin.readline()) for _ in range(N)]  # 포도주 양 입력
nums = [0] + nums  # 1-based index 사용을 위한 패딩

# ✅ DP 테이블 초기화
dp = [0] * (N + 1)

# ✅ 기본값 설정 (N이 1일 때 예외 처리)
dp[1] = nums[1]
if N >= 2:
    dp[2] = dp[1] + nums[2]

# ✅ DP 테이블 채우기 (Bottom-Up 방식)
if N > 2:
    for i in range(3, N+1):
        if i >= 3:  # ✅ 불필요한 조건이지만 원본 코드 유지
            dp[i] = max(dp[i-1], dp[i-2] + nums[i], dp[i-3] + nums[i] + nums[i-1])

# ✅ 결과 출력 (마실 수 있는 최대 포도주 양)
print(dp[N])

# -----------------------------------------------------
# ✅ 2단계에서 발생했던 오류 정리 및 수정:
# 1. ✅ 원본 코드의 `if i >= 3:` 조건이 불필요하지만 유지됨.
# 2. ✅ `dp[N]`을 올바르게 출력하도록 코드 유지.
#
# ✅ 3단계 최종 정답 코드 제공 완료 🚀
