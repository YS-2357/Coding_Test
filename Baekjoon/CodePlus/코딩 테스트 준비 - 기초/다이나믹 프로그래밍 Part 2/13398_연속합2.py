# 백준 13398번: 연속합 2 (다이나믹 프로그래밍 - O(N))
# -----------------------------------------------------
# ✅ 문제 설명:
# - 연속된 몇 개의 수를 선택하여 합을 구하는 문제 (연속 부분 수열 합)
# - 단, **하나의 수를 제거할 수 있는 선택권이 존재**
# - 하나를 제거하는 경우와 제거하지 않는 경우 중 최댓값을 찾는 문제
#
# ✅ 입력 형식:
# - 첫 번째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)이 주어진다.
# - 두 번째 줄에 N개의 정수가 주어진다. (-1,000 ≤ 정수 ≤ 1,000)
#
# ✅ 출력 형식:
# - 하나의 원소를 제거할 수도 있는 경우에서 최댓값을 출력
#
# ✅ 입출력 예제:
# 🔹 예제 입력 1:
#   10
#   10 -4 3 1 5 6 -35 12 21 -1
# 🔹 예제 출력 1:
#   33
# -----------------------------------------------------

import sys

# ✅ 입력 처리
N = int(sys.stdin.readline())
nums = list(map(int, sys.stdin.readline().split()))

# ✅ DP 배열 초기화
dp = [[nums[i], nums[i]] for i in range(N)]  # [제거X, 제거O]

# ✅ DP 테이블 채우기 (O(N))
for i in range(1, N):
    dp[i][0] = max(nums[i], dp[i-1][0] + nums[i])  # 연속 부분 수열 합 (제거 X)
    dp[i][1] = max(dp[i-1][1] + nums[i], dp[i-1][0])  # 한 개 원소 제거

# ✅ 결과 출력 (최대 연속 부분 수열 합)
print(max(max(dp[i]) for i in range(N)))  # ✅ 전체 dp 배열에서 최댓값 찾기

# -----------------------------------------------------
# ✅ 2단계에서 발생했던 오류 정리 및 수정:
# 1. ✅ `dp` 배열 초기화 오류 → `dp = [[nums[i], 0] for i in range(N)]`로 설정하여 `dp[i][1]`을 0으로 초기화하는 바람에
#      **제거된 경우의 부분 수열 합이 잘못 계산됨.**  
#      🔹 해결: `dp = [[nums[i], nums[i]] for i in range(N)]`로 수정하여, `dp[i][1]`도 기본적으로 `nums[i]` 값을 갖도록 함.
# 2. ✅ `dp[i][0] = max(dp[i][0], dp[i-1][0] + nums[i])` → `max(nums[i], dp[i-1][0] + nums[i])`로 변경  
# 3. ✅ 최댓값 호출 시 `print(max(max(dp[i]) for i in range(N)))`을 사용하여 dp 전체에서 최댓값 찾기
#
# ✅ 3단계 최종 정답 코드 제공 완료 🚀
