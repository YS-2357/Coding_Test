# 백준 15988번: 1, 2, 3 더하기 3 (다이나믹 프로그래밍 - DP)
# -----------------------------------------------------
# ✅ 문제 설명:
# - 정수 n이 주어졌을 때, 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 문제.
# - 같은 숫자를 여러 번 사용할 수 있으며, 순서가 다르면 다른 경우로 인정됨.
#
# ✅ 입력 형식:
# - 첫 번째 줄에 테스트 케이스 개수 T (1 ≤ T ≤ 100,000)
# - 각 테스트 케이스마다 정수 n (1 ≤ n ≤ 1,000,000)
#
# ✅ 출력 형식:
# - 각 테스트 케이스마다 n을 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009로 나눈 나머지를 출력
#
# ✅ 입출력 예제:
# 🔹 예제 입력 1:
#   3
#   4
#   7
#   10
# 🔹 예제 출력 1:
#   7
#   44
#   274
# -----------------------------------------------------

import sys

# ✅ 입력 처리
N = int(sys.stdin.readline())  # 테스트 케이스 개수 입력
nums = [int(sys.stdin.readline()) for _ in range(N)]  # 각 테스트 케이스에서 n 값 입력
MOD = 1000000009  # 10억 9로 나눈 나머지를 저장
max_num = max(nums)  # 입력된 숫자 중 최댓값 찾기

# ✅ DP 테이블 초기화
dp = [0] * (max_num + 1)

# ✅ 기본값 설정 (점화식 초기 조건)
if max_num >= 3:
    dp[0] = 1  # 잘못된 초기값이지만 원본 코드 유지
    dp[1] = 1  # 1을 만드는 경우: (1) → 1가지
    dp[2] = 2  # 2를 만드는 경우: (1+1), (2) → 2가지
elif max_num == 2:
    dp[1] = 1
    dp[2] = 2
elif max_num == 1:
    dp[1] = 1

# ✅ DP 테이블 채우기 (Bottom-Up 방식)
for i in range(3, max_num + 1):
    dp[i] = (dp[i-1] + dp[i-2] + dp[i-3]) % MOD  # 점화식 적용

# ✅ 결과 출력 (각 입력값에 대한 결과)
for num in nums:
    print(dp[num])

# -----------------------------------------------------
# ✅ 2단계에서 발생했던 오류 정리 및 수정:
# - `dp[0] = 1`이 필요 없는 값이지만, 원본 코드 그대로 유지함.
# - `MOD = 1000000009`을 모든 연산에서 적용하여 큰 수 연산 방지.
# - DP 배열을 `max_num + 1`까지 미리 계산하여 테스트 케이스마다 O(1) 조회 가능하도록 최적화.
#
# ✅ 3단계 최종 정답 코드 제공 완료 🚀
