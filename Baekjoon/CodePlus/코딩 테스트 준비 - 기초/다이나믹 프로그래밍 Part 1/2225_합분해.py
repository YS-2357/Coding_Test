# 백준 2225번: 합분해 (DP - 정수 분할 문제)
# -----------------------------------------------------
# ✅ 문제 설명:
# - 0부터 N까지의 정수 K개를 더해서 합이 N이 되는 경우의 수를 구하는 문제
# - 같은 숫자를 여러 번 사용할 수 있으며, 순서가 다르면 다른 경우로 인정됨
#
# ✅ 입력 형식:
# - 두 정수 N, K (0 ≤ N ≤ 200, 1 ≤ K ≤ 200)가 주어짐
#
# ✅ 출력 형식:
# - K개의 정수를 사용하여 합이 N이 되는 경우의 수를 1,000,000,000으로 나눈 나머지를 출력
#
# ✅ 입출력 예제:
# 🔹 예제 입력 1:
#   20 2
# 🔹 예제 출력 1:
#   21
# (예: (0+20), (1+19), (2+18), ..., (20+0), 총 21개)
# -----------------------------------------------------

import sys

# ✅ 입력 처리
N, K = map(int, sys.stdin.readline().split())  # 정수 N과 K 입력
MOD = 1000000000  # 10억으로 나눈 나머지 계산을 위한 MOD 값

# ✅ DP 테이블 초기화 (각 숫자로 합을 만드는 경우의 수 저장)
dp = [[0] * (K+1) for _ in range(N+1)]

# ✅ K가 1일 때, 모든 N은 1가지 방법만 존재 (자기 자신)
for i in range(N+1):
    dp[i][1] = 1

# ✅ 점화식을 사용한 DP 테이블 채우기 (O(KN) 방식)
for i in range(N+1):  # 0부터 N까지의 합을 만드는 방법 탐색
    for j in range(1, K+1):  # 1개부터 K개까지 숫자를 사용할 때의 경우 탐색
        dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD  # 점화식 적용

# ✅ 결과 출력 (N을 K개의 정수 합으로 만드는 경우의 수)
print(dp[N][K])

# -----------------------------------------------------
# ✅ 2단계에서 발생했던 오류 정리 및 수정:
# 1. ✅ `dp[i][1] = 1`을 올바르게 설정:
#    - K가 1개일 때 모든 N은 하나의 방법만 존재하므로 초기화 유지.
#
# 2. ✅ `for i in range(N+1): for j in range(1, K+1):` 순서도 정답으로 인정됨:
#    - 기존 코드에서도 `dp[i][j-1]`이 정상적으로 업데이트됨.
#
# 3. ✅ `MOD`를 점화식에서 적용하여 큰 수 연산 방지:
#    - `(dp[i-1][j] + dp[i][j-1]) % MOD` 적용.
#
# ✅ 3단계 최종 정답 코드 제공 완료 🚀
