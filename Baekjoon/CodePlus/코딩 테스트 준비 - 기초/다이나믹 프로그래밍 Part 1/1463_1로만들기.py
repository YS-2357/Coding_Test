# 백준 1463번: 1로 만들기 (다이나믹 프로그래밍 - Bottom-Up 방식)
# 문제 설명:
# 정수 X가 주어질 때, 다음 3가지 연산을 사용하여 1로 만들 수 있다.
# 1. X가 3으로 나누어 떨어지면 X //= 3
# 2. X가 2로 나누어 떨어지면 X //= 2
# 3. X에서 1을 뺄 수 있음 (X -= 1)
# 위의 연산을 최소한으로 사용하여 1로 만드는 연산 횟수를 구하는 문제.

# 입력 형식:
# - 첫 번째 줄에 정수 X (1 ≤ X ≤ 1,000,000)이 주어진다.

# 출력 형식:
# - X를 1로 만들기 위한 최소 연산 횟수를 출력한다.

# 예제 입력 1:
# 10
# 예제 출력 1:
# 3  (과정: 10 → 9 → 3 → 1)

import sys  # 빠른 입력 처리를 위한 sys 모듈 사용

# ✅ 입력 처리
N = int(sys.stdin.readline().strip())  # ✅ 정수 N 입력 받기 (1 ≤ N ≤ 1,000,000)

# ✅ DP 테이블 초기화 (0부터 N까지)
dp = [0] * (N + 1)  # ✅ dp[i] = i를 1로 만들기 위한 최소 연산 횟수

# ✅ DP 테이블 채우기 (Bottom-Up 방식)
for i in range(2, N + 1):  
    dp[i] = dp[i - 1] + 1  # ✅ 기본적으로 1을 빼는 연산 수행

    if i % 3 == 0:  
        dp[i] = min(dp[i], dp[i // 3] + 1)  # ✅ 3으로 나누는 경우 최솟값 갱신
    if i % 2 == 0:  
        dp[i] = min(dp[i], dp[i // 2] + 1)  # ✅ 2로 나누는 경우 최솟값 갱신

# ✅ 결과 출력
print(dp[N])  # ✅ N을 1로 만들기 위한 최소 연산 횟수 출력


# -----------------------------------------------------
# ❌ 내가 처음 쓴 코드부터 맞을 때까지 틀렸던 점

# 1. ✅ 재귀(DFS) 방식에서 런타임 에러 발생 (RecursionError)
#    - 기존 코드: `DFS(N)` 방식 사용
#    - ❌ 문제점: N이 커질 경우, 재귀 호출이 너무 깊어져 Python 기본 제한(1000번) 초과.
#    - ✅ 해결: `sys.setrecursionlimit()`으로 해결 가능하지만, 비효율적이므로 `Bottom-Up DP` 방식으로 변경.

# 2. ✅ 메모이제이션 방식 문제
#    - 기존 코드: `dp[N] = DFS(N - 1) + 1`
#    - ❌ 문제점: `DFS(N // 3)`, `DFS(N // 2)`를 제대로 저장하지 않고 다시 호출하여 비효율적.
#    - ✅ 해결: `dp` 배열을 직접 채우며 최솟값을 유지.

# 3. ✅ `Bottom-Up DP`로 해결 후 성능 최적화
#    - 기존 코드: `if N % 3 != 0` 등을 조건으로 사용하여 불필요한 연산 발생.
#    - ✅ 해결: `if i % 3 == 0:` 조건을 사용하여 필요할 때만 나누기 연산 수행.

# ✅ 위 수정 후 실행하면 백준에서 정답 판정! 🚀 
