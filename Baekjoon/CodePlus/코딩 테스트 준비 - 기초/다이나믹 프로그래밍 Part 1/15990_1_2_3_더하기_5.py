# 백준 15990번: 1, 2, 3 더하기 5 (다이나믹 프로그래밍 - DP)
# 문제 설명:
# - 정수 n을 1, 2, 3의 합으로 나타내는 방법의 개수를 구하는 문제
# - 단, 같은 숫자가 연속해서 사용될 수 없음
# - 즉, 예를 들어 (1 + 1 + 2) 같은 경우는 허용되지 않음
# - 결과를 1,000,000,009로 나눈 나머지를 출력해야 함

import sys

# ✅ 상수 설정: 모듈러 연산을 위한 상수
MOD = 1000000009

# ✅ 입력 처리
N = int(sys.stdin.readline())  # 테스트 케이스 개수 입력
nums = [int(sys.stdin.readline()) for _ in range(N)]  # 테스트 케이스 입력
max_num = max(nums)  # 입력된 숫자 중 최댓값을 기준으로 DP 테이블 크기 설정

# ✅ DP 테이블 초기화 (dp[n][k]는 n을 만들 때 마지막 숫자가 k로 끝나는 경우의 수)
dp = [[0] * 4 for _ in range(max_num + 1)]  # 0부터 max_num까지 DP 테이블 생성

# ✅ 기본값 설정 (점화식 초기 조건)
dp[1][0] = 1
dp[1][1] = 1  # 1만 사용

dp[2][0] = 1
dp[2][2] = 1  # 2만 사용

dp[3][0] = 3
dp[3][1] = 1  # 1 + 2
dp[3][2] = 1  # 2 + 1
dp[3][3] = 1  # 3만 사용

# ✅ DP 테이블 채우기 (Bottom-Up 방식)
for i in range(4, max_num + 1):
    dp[i][1] = (dp[i - 1][2] + dp[i - 1][3]) % MOD  # 마지막이 1로 끝나는 경우
    dp[i][2] = (dp[i - 2][1] + dp[i - 2][3]) % MOD  # 마지막이 2로 끝나는 경우
    dp[i][3] = (dp[i - 3][1] + dp[i - 3][2]) % MOD  # 마지막이 3으로 끝나는 경우
    dp[i][0] = (dp[i][1] + dp[i][2] + dp[i][3]) % MOD  # 총 방법의 수 계산

# ✅ 결과 출력 (입력된 숫자에 대해 정답 출력)
for num in nums:
    print(dp[num][0])

# -----------------------------------------------------
# ✅ 2단계에서 발생했던 오류 정리 및 수정:
# 1. ✅ `dp` 테이블 크기 문제 해결:
#    - 기존 코드에서는 `dp = [[0] * 4 for _ in range(N + 1)]` 사용 → 입력 최대값보다 작은 크기가 생성될 수 있음
#    - `max_num = max(nums)`을 사용하여 **입력된 숫자 중 최댓값을 기준으로 DP 테이블 크기 설정**
#
# 2. ✅ `dp[i][0]`의 초기값 문제 해결:
#    - 기존 코드에서는 `dp[1][0]` 등 수동으로 설정했으나, `dp[i][0] = dp[i][1] + dp[i][2] + dp[i][3]`으로 자동 계산되도록 변경
#
# 3. ✅ `for i in range(4, N + 1):` → `for i in range(4, max_num + 1):` 수정:
#    - 기존 코드에서는 DP 계산 범위를 `N`으로 제한하여 일부 값이 계산되지 않는 문제 발생
#    - `max_num + 1`로 변경하여 **입력된 숫자 중 가장 큰 값까지 미리 DP 계산**
#
# 4. ✅ `print(dp[i][0])` → `print(dp[num][0])` 수정:
#    - 기존 코드에서는 마지막 `i` 값만 출력하는 문제 발생
#    - `num`을 사용하여 **각 입력값에 대해 개별적으로 정답 출력**

# ✅ 3단계 최종 정답 코드 제공 완료 🚀
