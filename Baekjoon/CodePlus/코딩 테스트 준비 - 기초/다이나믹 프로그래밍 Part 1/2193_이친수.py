# 백준 2193번: 이친수 (다이나믹 프로그래밍 - DP)
# 문제 설명:
# - 이친수는 0으로 시작하지 않으며, 1이 두 번 연속 나타날 수 없음
# - 길이가 N인 이친수의 개수를 구하는 문제
# - 결과는 정수로 출력

import sys

# ✅ 입력 처리
N = int(sys.stdin.readline())

# ✅ DP 테이블 초기화 (dp[i][0]: 끝자리가 0, dp[i][1]: 끝자리가 1)
dp = [[0] * 2 for _ in range(N+1)]

# ✅ 초기값 설정 (N = 1, 2일 때 직접 출력)
if N == 1:
    print(1)
    exit()
elif N == 2:
    print(1)
    exit()

# ✅ 점화식을 사용한 DP 테이블 채우기
dp[1][1] = 1  # 1
dp[2][0] = 1  # 10

for i in range(3, N+1):
    dp[i][0] = dp[i-1][1] + dp[i-1][0]  # 끝자리가 0이면 이전 자리 1 또는 0 가능
    dp[i][1] = dp[i-1][0]  # 끝자리가 1이면 이전 자리 반드시 0

# ✅ 결과 출력 (길이가 N인 이친수 개수)
print(sum(dp[N]))

# -----------------------------------------------------
# ✅ 2단계에서 발생했던 오류 정리 및 수정:
# 1. ✅ `dp[3][0]`을 `N >= 3`일 때만 초기화하여 인덱스 에러 해결:
#    - 기존 코드에서 `N = 1, 2`일 때도 `dp[3]`을 설정하려 해 오류 발생 가능
#    - 해결: `if N >= 3:` 조건 추가하여 `dp[3]` 접근 방지
#
# 2. ✅ `sum(dp[N])`을 사용하여 결과 출력:
#    - 기존 코드에서 `total = dp[N][0] + dp[N][1]`을 별도로 계산했으나,
#    - `sum(dp[N])`을 사용하면 자동으로 합산됨.
#
# ✅ 3단계 최종 정답 코드 제공 완료 🚀


'''
import sys

N = int(sys.stdin.readline())

if N == 1:
    print(1)
    exit()

dp = [0] * (N + 1)
dp[1] = 1
dp[2] = 1

for i in range(3, N + 1):
    dp[i] = dp[i - 1] + dp[i - 2]  # 점화식 적용

print(dp[N])
'''
