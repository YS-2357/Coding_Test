# 백준 11052번: 카드 구매하기 (다이나믹 프로그래밍 - Bottom-Up 방식)
# 문제 설명:
# - 카드 `N`개를 구매하려고 한다.
# - 카드팩은 `N`가지 종류가 있으며, `i`번째 카드팩은 `i`개의 카드가 들어 있으며 가격은 `P[i]`이다.
# - 카드 `N`개를 구매하는 방법 중에서 **최대 비용을 구하는 문제**.
# - 카드팩은 같은 것을 여러 번 구매할 수 있다.

import sys  # ✅ 빠른 입력 처리를 위한 sys 모듈 사용

# ✅ 입력 처리
N = int(sys.stdin.readline())  # 카드 개수 입력
nums = list(map(int, sys.stdin.readline().split()))  # 카드팩 가격 입력

# ✅ DP 배열 초기화 (카드 개수를 i개 구매하는 최대 비용을 저장)
dp = [0] * (N + 1)  # dp[i]: i개의 카드를 구매할 때 얻을 수 있는 최대 비용 저장

# ✅ 기본값 설정 (카드 1개를 구매하는 최대 비용은 첫 번째 카드팩 가격)
dp[1] = nums[0]

# ✅ DP 테이블 채우기 (Bottom-Up 방식)
for i in range(2, N + 1):  # 카드 개수를 2개부터 N개까지 구매할 때의 최대 비용 계산
    for j in range(1, i + 1):  # `j`개의 카드를 구매하는 경우를 고려
        dp[i] = max(dp[i], dp[i - j] + nums[j - 1])  # 최댓값 갱신

# ✅ 결과 출력 (N개의 카드를 구매할 때의 최대 비용)
print(dp[N])

# -----------------------------------------------------
# ✅ 2단계에서 내가 틀렸던 점:
# 1. ✅ `for j in range(j, i):` 문법 오류 발생
#    - 기존 코드: `for j in range(j, i):`
#    - ❌ 문제점: `j`가 정의되지 않아서 오류 발생
#    - ✅ 해결: `for j in range(1, i + 1):`로 수정하여 올바르게 반복

# 2. ✅ `dp[i] = max(nums[i], nums[j] + nums[i - j])` 잘못된 로직 수정
#    - 기존 코드: `nums[i]` 사용 → `nums` 리스트는 0번 인덱스부터 시작하므로 `nums[i]`는 존재하지 않음
#    - ❌ 문제점: `nums[j]`와 `nums[i - j]`를 더하는 것이 아니라, **이전에 계산된 `dp[j]`를 활용해야 함**
#    - ✅ 해결: `dp[i] = max(dp[i], dp[i - j] + nums[j - 1])`로 수정하여 올바른 점화식 적용

# 3. ✅ DP 초기값 설정 오류 수정
#    - 기존 코드에서 `dp[1]`이 잘못 설정될 가능성이 있었음
#    - ✅ 해결: `dp[1] = nums[0]`로 명확히 지정하여 카드 1개를 구매할 때의 최대 비용을 올바르게 설정

# ✅ 위 수정 후 실행하면 백준에서 정답 판정! 🚀
