# 백준 16194번: 카드 구매하기 2 (다이나믹 프로그래밍 - Bottom-Up 방식)
# 문제 설명:
# - N개의 카드를 구매하려고 한다.
# - 카드팩은 N가지 종류가 있으며, i번째 카드팩은 i개의 카드가 들어 있으며 가격은 P[i]이다.
# - 카드 N개를 구매하는 방법 중에서 **최소 비용**을 구하는 문제.
# - 카드팩은 같은 것을 여러 번 구매할 수 있다.

# 입력 형식:
# - 첫 번째 줄에 정수 N (1 ≤ N ≤ 1,000)이 주어진다.
# - 두 번째 줄에 N개의 정수 P[i] (1 ≤ P[i] ≤ 10,000)가 주어진다.

# 출력 형식:
# - 카드 N개를 구매하는 최소 비용을 출력한다.

# 예제 입력 1:
# 4
# 1 5 6 7
# 예제 출력 1:
# 4

import sys  # ✅ 빠른 입력 처리를 위한 sys 모듈 사용

# ✅ 입력 처리
N = int(sys.stdin.readline())  # 카드 개수 입력
nums = list(map(int, sys.stdin.readline().split()))  # 카드팩 가격 입력

# ✅ DP 배열 초기화 (카드 개수를 i개 구매하는 최소 비용을 저장)
dp = [float("inf")] * (N + 1)  # dp[i]: i개의 카드를 구매할 때 얻을 수 있는 최소 비용 저장

# ✅ 기본값 설정 (카드팩 1개 구매 비용은 해당 카드팩 가격과 동일)
for i in range(1, N + 1):
    dp[i] = nums[i - 1]

# ✅ DP 테이블 채우기 (Bottom-Up 방식)
for i in range(1, N + 1):  # 카드 개수를 1개부터 N개까지 구매할 때의 최소 비용 계산
    for j in range(1, i + 1):  # `j`개의 카드를 구매하는 경우를 고려
        dp[i] = min(dp[i], dp[i - j] + nums[j - 1])  # 최솟값 갱신

# ✅ 결과 출력 (N개의 카드를 구매할 때의 최소 비용)
print(dp[N])

# -----------------------------------------------------
# ✅ 2단계에서 내가 틀렸던 점:
# 1. ✅ `dp` 배열 초기화 값이 적절하지 않았음
#    - 기존 코드: `dp = [10000] * (N + 1)`
#    - ❌ 문제점: `10000`은 카드팩 최댓값일 뿐, 실제 카드 N개를 구매하는 비용이 이를 초과할 수 있음.
#    - ✅ 해결: `float('inf')`를 사용하여 최솟값 비교를 안정적으로 수행.

# 2. ✅ `dp[i] = nums[0]`만 설정하여 모든 초기값이 반영되지 않음
#    - 기존 코드: `dp[1] = nums[0]`
#    - ❌ 문제점: `dp[i]`를 `nums[i - 1]`로 초기화해야 모든 카드팩이 초기 비용으로 반영됨.
#    - ✅ 해결: `for i in range(1, N + 1): dp[i] = nums[i - 1]`로 수정.

# 3. ✅ `dp[i]` 갱신 방식 오류
#    - 기존 코드: `dp[i] = min(dp[i], dp[i - j] + nums[j - 1])`에서 `i = 2`부터 시작함.
#    - ❌ 문제점: `dp[i]`를 `i=1`부터 시작하지 않으면 일부 값이 초기화되지 않음.
#    - ✅ 해결: `for i in range(1, N + 1)`부터 시작하도록 수정하여 모든 경우 고려.

# ✅ 위 수정 후 실행하면 백준에서 정답 판정! 🚀
