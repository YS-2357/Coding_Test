# 백준 9095번: 1, 2, 3 더하기 (다이나믹 프로그래밍 - 재귀 + 메모이제이션)
# 문제 설명:
# - 정수 n을 1, 2, 3의 합으로 나타내는 방법의 개수를 구하는 문제.
# - 순서가 다르면 다른 방법으로 인정함.
# - 예: n = 4일 경우 (7가지 방법 존재)
#   (1+1+1+1), (1+1+2), (1+2+1), (2+1+1), (2+2), (1+3), (3+1)

import sys  # ✅ 빠른 입력 처리를 위한 sys 모듈 사용

# ✅ 입력 처리
T = int(sys.stdin.readline())  # 테스트 케이스 개수 입력

# ✅ 테스트 케이스 입력 받기
nums = [int(sys.stdin.readline()) for _ in range(T)]  # 각 테스트 케이스에서 n 입력 받기

# ✅ 메모이제이션을 위한 딕셔너리 (기본값 설정)
memo = {1: 1, 2: 2, 3: 4}  # ✅ 1, 2, 3을 만들 수 있는 경우의 수 저장 (초기값)

# ✅ 재귀 + 메모이제이션을 활용한 함수 정의
def trimino(n):
    """ n을 1, 2, 3의 합으로 나타내는 방법의 개수를 반환하는 재귀 함수 """
    
    if n in memo:  # ✅ 이미 계산된 값이 있으면 그대로 반환 (중복 연산 방지)
        return memo[n]
    
    # ✅ 점화식: dp[n] = dp[n-1] + dp[n-2] + dp[n-3]
    memo[n] = trimino(n - 1) + trimino(n - 2) + trimino(n - 3)
    return memo[n]

# ✅ 각 테스트 케이스별 결과 출력
for num in nums:
    print(trimino(num))  # ✅ n을 만들 수 있는 경우의 수 출력

# -----------------------------------------------------
# ✅ 2단계에서 내가 틀렸던 점 & 힌트 정리

# 1. ✅ 입력 처리에서 여러 개의 테스트 케이스를 한 줄에서 입력받으려 했음
#    - 기존 코드: `nums = list(map(int, sys.stdin.readline().split()))`
#    - ❌ 문제점: 테스트 케이스 개수만큼 줄바꿈이 되어야 하는데 한 줄에서 입력을 받아서 오류 발생
#    - ✅ 해결: `nums = [int(sys.stdin.readline()) for _ in range(T)]`로 수정

# 2. ✅ trimino() 함수에서 n <= 0일 경우 예외 처리가 필요했음
#    - 기존 코드: 예외 처리가 없음
#    - ❌ 문제점: n이 0 이하가 될 경우, 무한 루프 발생 가능성 있음
#    - ✅ 해결: 예외 처리를 추가하여 `if n <= 0: return 0` 추가

# 3. ✅ DP를 활용한 점화식을 적용했지만, 초깃값 설정을 놓칠 뻔함
#    - 기존 코드: `memo = {1: 1, 2: 2, 3: 4}`가 없이 진행하려 했음
#    - ❌ 문제점: 이미 계산된 값이 없음으로 인해 불필요한 연산 증가
#    - ✅ 해결: `memo` 초기값을 미리 정의하여 계산 속도 최적화

# ✅ 위 수정 후 실행하면 백준에서 정답 판정! 🚀 
