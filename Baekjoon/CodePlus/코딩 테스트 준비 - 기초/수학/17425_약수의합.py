# 백준 17425번: 약수의 합
# 문제 설명:
# 자연수 N이 주어졌을 때, 1부터 N까지의 모든 자연수 i에 대해 i의 모든 약수의 합을 구하는 문제.
# 즉, S(N) = ∑ σ(i) (1 ≤ i ≤ N) 을 구해야 한다.

# 입력 형식:
# 첫 번째 줄에 테스트 케이스 개수 T가 주어진다. (1 ≤ T ≤ 100,000)
# 이후 T개의 줄에 N이 주어진다. (1 ≤ N ≤ 1,000,000)

# 출력 형식:
# 각 테스트 케이스마다 S(N)을 출력한다.

# 예제 입력 1:
# 5
# 1
# 2
# 10
# 70
# 10000

# 예제 출력 1:
# 1
# 4
# 87
# 40639
# 82256014


# 🛑 [❌ 사용자가 작성한 코드] (틀린 코드)
"""
n = int(input())

for _ in range(n):
    k = int(input())
    sum = 0
    for i in range(1, k+1):
        sum += i * (k//i)
    print(sum)
"""

# 📌 [❌ 사용자의 코드에서 틀린 점]
# 1. 시간 초과 가능성 (`O(N²)`)
#    - 이중 반복문으로 인해 비효율적인 계산이 발생.
#    - N이 최대 1,000,000일 때 O(N²) 복잡도를 가지면 시간 초과 발생.
# 2. 매번 새롭게 값을 계산함 (불필요한 중복 연산)
#    - 테스트 케이스가 최대 100,000개이므로 같은 연산을 반복하지 않고, 미리 계산해두어야 함.


# ✅ [✔ 모범 답안: 시간 복잡도를 O(N)으로 최적화한 코드]
# - 약수의 개념을 활용하여 미리 S(N)을 계산하고 빠르게 조회 (전처리 활용)
# - 시간 복잡도 O(N)으로 개선하여 여러 개의 테스트 케이스를 빠르게 처리

import sys

# 최대 N의 범위 (1 ≤ N ≤ 1,000,000)
MAX_N = 1000000

# 각 수 i의 약수의 합을 저장하는 배열 (전처리)
divisor_sum = [0] * (MAX_N + 1)

# 약수의 합을 누적해서 S(N)을 저장할 배열
S = [0] * (MAX_N + 1)

# 1부터 MAX_N까지 약수의 합을 미리 계산 (O(N) 알고리즘)
for i in range(1, MAX_N + 1):
    for j in range(i, MAX_N + 1, i):
        divisor_sum[j] += i  # i가 j의 약수이므로 더하기

# S(N) 값을 미리 계산 (누적 합)
for i in range(1, MAX_N + 1):
    S[i] = S[i - 1] + divisor_sum[i]

# 입력 처리
t = int(sys.stdin.readline().strip())  # 테스트 케이스 개수 입력

# 여러 개의 테스트 케이스를 빠르게 처리
for _ in range(t):
    n = int(sys.stdin.readline().strip())
    print(S[n])  # 미리 계산된 S(N) 값 출력
