# 백준 1978번: 소수 찾기
# 문제 설명:
# 주어진 N개의 수 중 소수가 몇 개인지 찾아서 출력하는 문제.
# 소수란 1과 자기 자신만을 약수로 가지는 자연수를 말한다.

# 입력 형식:
# 첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 100)
# 둘째 줄에 N개의 정수가 공백으로 구분되어 주어진다. (1 ≤ 입력값 ≤ 1,000)

# 출력 형식:
# 주어진 N개의 수 중 소수의 개수를 출력한다.

# 예제 입력 1:
# 4
# 1 3 5 7
# 예제 출력 1:
# 3


# 🛑 [❌ 사용자가 작성한 코드] (틀린 코드)
"""
n = int(input())

array = [1] * (n+1)
array[0] = 0
array[1] = 0

for i in range(2, n+1):
    for j in range(1, int(i ** 0.5) + 1):  # ❌ 오류 1: j가 1부터 시작
        if i % j == 0:
            array[i] = 0  # ❌ 오류 2: 약수 중 1도 포함되므로 모든 수가 소수가 아님으로 처리됨

print(sum(array))
"""

# 📌 [❌ 사용자의 코드에서 틀린 점]
# 1. **잘못된 소수 판별 범위 설정**  
#    - 내부 반복문에서 `j`를 1부터 검사 → `1`은 모든 수의 약수이므로 잘못된 판별 가능  
#    - 올바르게 하려면 `j`를 `2부터 √i`까지만 검사해야 함  
# 2. **소수 판별 방식 오류**  
#    - 현재 코드에서는 약수 중 `1`을 포함하여 검사하므로 **모든 수가 소수가 아니라고 판별될 가능성이 있음**  
#    - 예를 들어, `i=5`일 때 `j=1`이면 `i % 1 == 0`이 되어 소수가 아님으로 처리됨  

---

# ✅ [✔ 모범 답안: 소수 판별을 올바르게 수정한 코드]
# - 소수 판별을 효율적으로 수행하기 위해 에라토스테네스의 체를 사용하지 않고 단순한 소수 판별 알고리즘 사용
# - 입력받은 숫자 중 소수의 개수를 빠르게 계산

import math

# 소수 판별 함수
def is_prime(num):
    """
    주어진 수가 소수인지 확인하는 함수.
    소수는 1과 자기 자신만을 약수로 가지는 자연수이다.
    """
    if num < 2:
        return False  # 1은 소수가 아님
    for i in range(2, int(math.sqrt(num)) + 1):  # 2부터 √num까지 확인
        if num % i == 0:  # 약수가 존재하면 소수가 아님
            return False
    return True  # 약수가 없으면 소수

# 입력 처리
n = int(input())  # 자연수 N 입력
numbers = list(map(int, input().split()))  # N개의 숫자 입력

# 소수 개수 계산
prime_count = sum(is_prime(num) for num in numbers)  # 소수인 경우 1씩 더함

# 결과 출력
print(prime_count)
