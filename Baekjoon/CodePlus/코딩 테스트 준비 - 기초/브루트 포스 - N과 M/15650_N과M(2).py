# 백준 15650번: N과 M (2)
# 문제 설명:
# 1부터 N까지 자연수 중에서 길이가 M인 오름차순 조합을 출력하는 문제.
# - 같은 숫자는 한 번만 사용 가능하며, 순서는 반드시 오름차순이어야 한다.

# 입력 형식:
# - 두 정수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)

# 출력 형식:
# - 한 줄에 하나씩 길이가 M인 오름차순 조합을 출력한다.

# 예제 입력 1:
# 4 2
# 예제 출력 1:
# 1 2
# 1 3
# 1 4
# 2 3
# 2 4
# 3 4

import sys

# ✅ 입력 처리
N, M = map(int, sys.stdin.readline().split())

# ✅ 현재 조합을 저장할 리스트
seq = []

# ✅ 백트래킹을 활용한 조합 생성 함수
def backtrack(start):
    if len(seq) == M:  # 길이가 M이면 출력
        print(*seq)
        return
    
    for num in range(start, N + 1):  # 현재 숫자부터 N까지 탐색
        seq.append(num)  # 숫자 추가
        backtrack(num + 1)  # 다음 숫자부터 탐색 (오름차순 유지)
        seq.pop()  # 원상 복구 (백트래킹)

# ✅ 조합 생성 실행
backtrack(1)


# -----------------------------------------------------
# ❌ 내가 처음 쓴 코드부터 맞을 때까지 틀렸던 점

# 1. `visited` 리스트를 사용해서 중복을 방지하려 했음.
#    - ✅ 오름차순 조합에서는 필요 없음. 현재 숫자보다 큰 숫자만 선택하면 중복이 발생하지 않음.

# 2. `backtrack(start + 1)`로 호출해서 잘못된 숫자가 선택됨.
#    - ✅ `backtrack(num + 1)`로 변경하여 현재 선택한 숫자보다 큰 숫자만 선택되도록 수정.

# 3. `backtrack()` 호출 시 `start` 값을 전달하지 않아서 오류 발생.
#    - ✅ `backtrack(1)`로 올바르게 호출하여 1부터 탐색하도록 수정.

# ✅ 위 수정 후 실행하면 백준에서 정답 판정!
