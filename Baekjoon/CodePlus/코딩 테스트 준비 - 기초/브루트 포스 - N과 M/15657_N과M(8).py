# 백준 15657번: N과 M (8)
# 문제 설명:
# N개의 자연수가 주어지고, 이 중에서 길이가 M인 중복을 허용하는 비내림차순 조합을 출력하는 문제.
# - 같은 숫자를 여러 번 선택할 수 있으며, 순서는 반드시 비내림차순(오름차순 포함)이어야 한다.
# - 입력받은 숫자들을 오름차순 정렬한 후 조합을 생성해야 한다.

# 입력 형식:
# - 첫 번째 줄에 두 정수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)
# - 두 번째 줄에 N개의 자연수가 주어진다. (서로 다른 정수, 1 ≤ 숫자 ≤ 10,000)

# 출력 형식:
# - 한 줄에 하나씩 길이가 M인 비내림차순(오름차순 포함) 조합을 출력한다.

# 예제 입력 1:
# 3 2
# 4 2 5
# 예제 출력 1:
# 2 2
# 2 4
# 2 5
# 4 4
# 4 5
# 5 5

import sys

# ✅ 입력 처리
N, M = map(int, sys.stdin.readline().split())
nums = list(map(int, sys.stdin.readline().split()))
nums.sort()  # 숫자들을 오름차순으로 정렬

# ✅ 현재 조합을 저장할 리스트
seq = []

# ✅ 백트래킹을 활용한 중복 조합 생성 함수
def backtrack(start):
    if len(seq) == M:  # 길이가 M이면 출력
        print(*seq)
        return
    
    for i in range(start, N):  # 현재 숫자부터 N까지 탐색 (오름차순 유지)
        seq.append(nums[i])  # 숫자 추가
        backtrack(i)  # 같은 숫자를 선택할 수 있도록 유지
        seq.pop()  # 원상 복구 (백트래킹)

# ✅ 중복 조합 생성 실행
backtrack(0)

# -----------------------------------------------------
# ❌ 내가 처음 쓴 코드부터 맞을 때까지 틀렸던 점

# 1. 잘못된 `backtrack(start)` 호출
#    - 기존 코드: `backtrack(start)`
#    - ❌ 문제점: `start` 값을 그대로 넘기면, 같은 숫자만 반복해서 선택될 가능성이 있음.
#    - ✅ 수정: `backtrack(i)`로 변경하여, 현재 선택한 숫자 이상을 선택할 수 있도록 조정.

# 2. 오름차순(비내림차순) 순서를 유지하지 않음.
#    - 기존 코드에서는 모든 숫자를 중복해서 선택할 수 있었지만, 순서가 보장되지 않았음.
#    - ❌ 문제점: 문제에서 "비내림차순(오름차순 포함)"이라고 명시되어 있음.
#    - ✅ 수정: `for i in range(start, N):`을 사용하여 오름차순을 유지하도록 변경.

# 3. 입력받은 숫자를 정렬하지 않음.
#    - 기존 코드에서는 입력된 순서를 그대로 사용했음.
#    - ❌ 문제점: 문제에서 "입력받은 숫자를 정렬한 후 조합을 생성해야 한다"고 명시되어 있음.
#    - ✅ 수정: `nums.sort()`를 추가하여 입력된 숫자를 오름차순 정렬.

# ✅ 위 수정 후 실행하면 백준에서 정답 판정!
