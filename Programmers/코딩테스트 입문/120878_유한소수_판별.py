# 120878_유한소수_판별.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - 두 정수 a, b가 주어질 때 a/b가 유한소수이면 1, 무한소수이면 2를 반환합니다.
#
# ✅ 입력:
# - a, b: 정수 (0 < a, b ≤ 1,000)
#
# ✅ 출력:
# - 1 (유한소수) 또는 2 (무한소수)
#
# ✅ 예시:
#   a = 7,  b = 20 → 7/20 = 0.35      → 유한소수 → 1
#   a = 1,  b = 3  → 1/3  = 0.333...  → 무한소수 → 2
# -----------------------------------------------------

def solution(a, b):
    # 1) 최대공약수(GCD) 계산 (유클리드 호제법)
    orig_b = b
    while b:
        a, b = b, a % b
    gcd = a

    # 2) 분모를 기약분수로 만들기
    denom = orig_b // gcd

    # 3) 분모에 남은 2와 5 인수 모두 제거
    while denom % 2 == 0:
        denom //= 2
    while denom % 5 == 0:
        denom //= 5

    # 4) 분모가 1이면 유한소수, 아니면 무한소수
    return 1 if denom == 1 else 2

# -----------------------------------------------------
# ✅ 나의 오답 및 실수:
# - 분모가 2나 5로 나누어지는지만 한 번 검사하여,
#   분모에 2·5 외의 소인수가 남아 있어도 유한소수로 잘못 판단함
#
# ✅ GPT가 준 힌트 요약:
# - 분모에서 2와 5 인수를 “모조리” 반복 제거한 뒤,
#   남은 값이 1인지 아닌지로 유한/무한소수를 판별
#
# ✅ 사용된 개념 요약:
# - 유클리드 호제법: 최대공약수 계산
# - 기약분수: 분모를 GCD로 나누기
# - 소인수 제거: `while denom % p == 0` 패턴으로 2와 5 제거
# - 유한소수 조건: 기약분수의 분모에 2,5 이외의 인수가 없어야 함
#
# ✅ 시간 복잡도:
# - GCD 계산: O(log min(a,b))
# - 소인수 제거: O(log denom)
# - 전체: O(log max(a,b)), a,b ≤ 1,000이므로 매우 빠름
# -----------------------------------------------------
