# 120861_캐릭터의_위치.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - 2D 좌표계에서 시작점 [0, 0]에 있는 캐릭터가 방향키 입력을 받아 이동
# - keyinput: “up”, “down”, “left”, “right” 명령 리스트
# - board: [w, h]로 주어진 맵 크기, 
#   이동 가능한 x 범위는 [-w//2, +w//2], y 범위는 [-h//2, +h//2]
# - 모든 명령을 처리한 후 최종 위치 [x, y]를 반환
#
# ✅ 입력:
# - keyinput: 문자열 리스트 (길이 1~1000)
# - board: 정수 리스트 [w, h] (1 ≤ w, h ≤ 100)
#
# ✅ 출력:
# - 최종 위치 [x, y]
#
# ✅ 예시:
#   keyinput = ["up", "up", "left", "down", "left"]
#   board    = [7, 5]
#   → w//2 = 3, h//2 = 2
#   이동 순서: [0,0]→[0,1]→[0,2]→[-1,2]→[-1,1]→[-2,1]
#   최종: [-2, 1]
# -----------------------------------------------------

def solution(keyinput, board):
    # 방향별 이동 벡터 정의
    moves = {
        "up":    (0,  1),
        "down":  (0, -1),
        "left":  (-1, 0),
        "right": (1,  0)
    }
    
    # 시작 위치
    x, y = 0, 0
    
    # 이동 가능한 범위 계산 (클램핑 한계)
    w, h = board
    x_min, x_max = -(w // 2), w // 2
    y_min, y_max = -(h // 2), h // 2
    
    # 모든 명령을 순회하며 위치 업데이트
    for cmd in keyinput:
        dx, dy = moves[cmd]                  # 방향 벡터
        x = max(x_min, min(x_max, x + dx))   # x 클램핑
        y = max(y_min, min(y_max, y + dy))   # y 클램핑
    
    return [x, y]  # 최종 위치 반환

# -----------------------------------------------------
# ✅ 사용된 개념 요약:
# - 딕셔너리로 방향명령→이동벡터 매핑  
# - 벡터 덧셈: (x, y)에 (dx, dy) 더하기  
# - 클램핑(clamp): max(min)으로 범위 제한  
#
# ✅ 나의 오답 및 실수:
# - 없음 — 한 번에 올바르게 구현  
#
# ✅ GPT가 준 힌트 요약:
# - “up/down/left/right”를 키→(dx, dy)로 매핑하면 분기문 없이 간단히 처리 가능  
# - `x = max(x_min, min(x_max, x + dx))` 형태로 경계값을 적용  
#
# ✅ 시간 복잡도:
# - O(n), n = len(keyinput) ≤ 1000 → 매우 빠름  
# -----------------------------------------------------
