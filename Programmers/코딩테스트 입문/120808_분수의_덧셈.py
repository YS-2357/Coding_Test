# 120808_분수의_덧셈.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - 두 개의 분수를 더하고, 그 결과를 기약분수 형태로 반환하는 문제.
# - 결과는 [분자, 분모] 형태의 리스트로 제공해야 한다.

# ✅ 입력 형식:
# - numer1, denom1: 첫 번째 분수의 분자와 분모
# - numer2, denom2: 두 번째 분수의 분자와 분모
#   (모두 1 이상 1,000 이하 자연수)

# ✅ 출력 형식:
# - [result_numer, result_denom]
#   (기약분수로 나타낸 결과)

# ✅ 예시:
#   입력: numer1=1, denom1=2, numer2=3, denom2=4
#   출력: [5, 4]
#   설명:
#   - 1/2 + 3/4 = (1×4 + 3×2) / (2×4) = 10/8 → 기약분수 5/4
# -----------------------------------------------------

def solution(numer1, denom1, numer2, denom2):
    # 1. 새로운 분모 계산 (공통 분모 = 두 분모의 곱)
    new_denom = denom1 * denom2

    # 2. 새로운 분자 계산 (각 분수의 분자를 공통 분모로 맞춰 합산)
    new_numer = numer1 * denom2 + numer2 * denom1

    # 3. 최대공약수(GCD)를 구하는 함수 정의 (유클리드 호제법)
    def gcd(a, b):
        # b가 0이 될 때까지 반복 → a가 최대공약수
        while b:
            a, b = b, a % b
        return a

    # 4. 분자와 분모의 최대공약수 구하기
    common_divisor = gcd(new_numer, new_denom)

    # 5. 최대공약수로 나눠 기약분수 형태로 반환
    return [new_numer // common_divisor, new_denom // common_divisor]

# -----------------------------------------------------
# ✅ 사용된 개념 요약:
# - 공통 분모: denom1 * denom2
# - 새 분자: numer1 * denom2 + numer2 * denom1
# - 최대공약수(GCD):
#   - 유클리드 호제법: gcd(a, b) = gcd(b, a % b)
#   - 반복문으로 구현
# - 기약분수 변환: (분자 ÷ GCD, 분모 ÷ GCD)
# - 시간 복잡도:
#   - GCD 계산: O(log(min(a, b)))
#   - 전체 알고리즘: O(1) (입력 크기 제한)
# -----------------------------------------------------
