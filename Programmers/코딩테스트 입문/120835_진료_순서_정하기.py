# 120835_진료_순서_정하기.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - 응급실에서 환자들의 응급도가 담긴 리스트 emergency가 주어진다.
# - 응급도가 높을수록 진료 우선순위가 높음.
# - 각 환자의 원래 순서에 맞게 치료 순서를 반환한다.
#
# ✅ 입력:
# - emergency: 정수 리스트 (길이 1~100, 값 1~100)
#
# ✅ 출력:
# - 각 원소가 자신의 진료 순서를 나타내는 리스트
#
# ✅ 예시:
# 입력: [3, 76, 24] → 출력: [3, 1, 2]
# -----------------------------------------------------

def solution(emergency):
    # ✅ emergency 리스트의 각 인덱스를 응급도 기준으로 내림차순 정렬
    # sorted(range(len(emergency))) → [0, 1, 2] 인덱스 리스트 생성
    # key=lambda k: emergency[k] → 응급도를 기준으로 정렬
    # reverse=True → 응급도가 큰 순으로
    sorted_indices = sorted(range(len(emergency)), key=lambda k: emergency[k], reverse=True)

    # ✅ 결과 리스트 초기화 (원본 길이와 동일한 크기)
    result = [0] * len(emergency)

    # ✅ 순위 부여:
    # enumerate(sorted_indices) → 정렬된 인덱스와 순위(0부터 시작) 반환
    # rank + 1 → 순위는 1부터 시작
    for rank, index in enumerate(sorted_indices):
        result[index] = rank + 1  # 원래 위치(index)에 순위를 넣음

    return result  # 최종 결과 리스트 반환

# -----------------------------------------------------
# ✅ 나의 오답 및 실수:
# ❌ 처음에는 단순 정렬 후 index()로 순위 매기려는 방식 고려 → 중복 처리 실패 가능
# ❌ 값만 정렬하면 원래 순서를 잃어버림 → 인덱스 기반 정렬 필요
#
# ✅ GPT가 준 힌트 요약:
# - 인덱스를 기반으로 정렬하면 원본 순서 유지 가능
# - enumerate와 초기화 리스트를 활용해 효율적으로 순위 부여
#
# ✅ 사용된 개념 요약:
# - 정렬에서 key 매개변수 사용: key=lambda k: emergency[k]
# - enumerate로 순위 계산
# - 리스트 인덱싱을 이용한 매핑
#
# ✅ 더 효율적인 알고리즘:
# - 현재 알고리즘의 시간 복잡도는 O(n log n) (정렬 때문)
# - n ≤ 100이므로 충분히 최적
# - dict 매핑 방식도 가능하지만 복잡도는 동일
# -----------------------------------------------------
