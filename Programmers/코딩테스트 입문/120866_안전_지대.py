# 120866_안전_지대.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - n×n 크기의 이차원 배열 board가 주어집니다.
#   - board[i][j] = 1인 칸은 지뢰가 설치된 칸
#   - 0인 칸은 지뢰가 없는 칸
# - 지뢰가 설치된 칸과 그 8방향(상, 하, 좌, 우, 대각선) 인접 칸은 모두 위험 지역으로 간주
# - 위험 지역이 아닌, 즉 안전 지역(0)인 칸의 개수를 반환하세요.
#
# ✅ 입력:
# - board: 0 또는 1로 이루어진 이차원 리스트 (n은 1 이상 100 이하)
#
# ✅ 출력:
# - 안전 지역(지뢰 및 인접이 아닌 칸)의 개수 (정수)
#
# ✅ 예시:
#   board = [
#     [0, 0, 0, 0, 0],
#     [0, 0, 1, 0, 0],
#     [0, 0, 0, 0, 0],
#     [0, 0, 0, 0, 0],
#     [0, 0, 0, 0, 0]
#   ]
#   → 지뢰(1)와 8방향 인접 칸을 모두 1로 처리하면
#     [
#       [0,1,1,1,0],
#       [1,1,1,1,1],
#       [1,1,1,1,1],
#       [0,1,1,1,0],
#       [0,0,0,0,0]
#     ]
#   → 안전 지역(0)의 개수: 9
# -----------------------------------------------------

def solution(board):
    n = len(board)
    # 위험 지역 체크용 배열 (0: 안전, 1: 위험)
    danger = [[0] * n for _ in range(n)]

    # 8방향 이동 벡터 정의
    dx = [1, 1, 1, 0, -1, -1, -1, 0]
    dy = [1, 0, -1, -1, -1, 0, 1, 1]

    # 각 지뢰 위치에서 위험 지역 표시
    for i in range(n):
        for j in range(n):
            if board[i][j] == 1:
                danger[i][j] = 1
                # 8방향 인접 칸도 위험 처리
                for k in range(8):
                    ni, nj = i + dx[k], j + dy[k]
                    if 0 <= ni < n and 0 <= nj < n:
                        danger[ni][nj] = 1

    # 안전 지역 개수 계산
    safe_count = 0
    for i in range(n):
        for j in range(n):
            if danger[i][j] == 0:
                safe_count += 1

    return safe_count

# -----------------------------------------------------
# ✅ 사용된 개념 요약:
# - 8방향 인접 칸 탐색: dx, dy 벡터 사용
# - 이차원 배열 복사 없이 별도 danger 배열로 위험 표시
# - 경계 검사(0 ≤ ni, nj < n)로 배열 범위 벗어남 방지
# - 마지막에 danger 배열을 순회하며 안전 칸(0) 개수 집계

# ✅ 시간 복잡도:
# - O(n²): 최대 (n×n) 순회 두 번 + 8방향 탐색 → n ≤ 100 이므로 충분히 빠름
# -----------------------------------------------------
