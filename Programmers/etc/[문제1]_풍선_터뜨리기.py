# [문제1]_풍선_터뜨리기.py
# -----------------------------------------------------
# ✅ 제목: 풍선 터뜨리기 — 한 번만 작은 풍선 제거 가능할 때 최후 생존 풍선 수
# ✅ 문제 설명(요약):
# - 서로 다른 정수가 적힌 풍선 배열 a.
# - 인접한 두 풍선 중 하나를 터뜨리며, “더 작은 값을 터뜨리는 행위”는 **평생 딱 1번**만 가능.
# - 규칙을 지키며 끝까지 남길 수 있는 풍선의 개수를 구한다.
#
# ✅ 입력 형식(요지):
# - a: List[int], 1 ≤ len(a) ≤ 1_000_000, 모든 값 서로 다름
#
# ✅ 규칙 요약(핵심 관찰):
# - 어떤 풍선 i가 끝까지 남을 수 있으려면, i 기준 왼쪽 또는 오른쪽 중 **어느 한쪽**에서는
#   i보다 더 작은 값이 **영원히 등장하지 않아야** 함.
#   ↔ i값이 “좌측 최소” 또는 “우측 최소” 중 하나이면 생존 가능.
#
# ✅ 입출력 예시(간단):
# - a = [9,-1,-5] → 3
# - a = [-16,27,65,-2,58,-92,-71,-68,-61,-33] → 6

def solution(a):
    n = len(a)
    # 좌측에서의 최소값 누적
    left_min = [0]*n
    cur = float('inf')
    for i in range(n):
        cur = min(cur, a[i])
        left_min[i] = cur
    # 우측에서의 최소값 누적
    right_min = [0]*n
    cur = float('inf')
    for i in range(n-1, -1, -1):
        cur = min(cur, a[i])
        right_min[i] = cur
    # 생존 판정: a[i]가 왼쪽 최소이거나 오른쪽 최소이면 가능
    ans = 0
    for i in range(n):
        if a[i] <= left_min[i] or a[i] <= right_min[i]:
            ans += 1
    return ans

# -----------------------------------------------------
# 📚 꼭 필요한 개념 & 사용 개념(최소):
# - 단방향 누적 최소(prefix/suffix minimum)
# - O(n) 스캔으로 생존 가능 조건 판정 (왼쪽 최소이거나 오른쪽 최소)
