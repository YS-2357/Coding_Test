# [문제1]_유사_칸토어_비트열.py
# -----------------------------------------------------
# ✅ 문제 설명:
# 0번째 유사 칸토어 비트열: "1"
# n번째: 이전 비트열에서 1 → "11011", 0 → "00000" 치환
# n번째 비트열의 구간 [l, r]에서 1의 개수를 구하라.

# ✅ 입력 형식:
# - n: 1 ≤ n ≤ 20
# - l, r: 1 ≤ l ≤ r ≤ 5^n, r < l + 10,000,000 (1-based, 폐구간)

# ✅ 출력 형식:
# - 구간 [l, r] 내 1의 개수 (정수)

# ✅ 입출력 예시:
# n=2, l=4, r=17 → 8

# ✅ 정답 코드:
def solution(n, l, r):
    # 주어진 위치가 '0'인지 '1'인지 판별하는 재귀 함수
    def is_one(idx, depth):
        if depth == 0:                  # 깊이 0이면 "1"
            return 1
        length = pow(5, depth-1)         # 현재 구간을 5등분한 하나의 길이
        pos = idx // length              # 몇 번째 블록에 속하는지
        if pos == 2:                     # 가운데 블록(2번째)은 모두 0
            return 0
        return is_one(idx % length, depth-1)

    count = 0
    # l~r (1-based)이므로 0-based로 변환
    for i in range(l-1, r):
        count += is_one(i, n)
    return count

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 한 번에 정답 도출 (힌트 사용 안 함)

# 📚 사용된 개념 요약:
# - 칸토어 집합 생성 규칙의 재귀적 구조
# - 구간 전체를 생성하지 않고, 각 위치를 재귀 판별 → 메모리 절약
# - 시간복잡도: O((r-l+1) * n), n ≤ 20, r-l ≤ 10^7
