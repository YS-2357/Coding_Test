# [문제1]_택배상자.py
# -----------------------------------------------------
# ✅ 문제 설명:
# 메인 컨베이어(1→n 순서로 한 번만 앞으로 흐름)와 보조 벨트(스택)를 사용해
# 주어진 order 순서대로 상자를 최대 몇 개 실을 수 있는지 계산한다.

# ✅ 입력 형식:
# - order: 길이 n(1 ≤ n ≤ 1,000,000), 1..n의 순열

# ✅ 출력 형식:
# - 실을 수 있는 상자의 최대 개수 (정수)

# ✅ 입출력 예시(요약):
# - order = [4,3,1,2,5] -> 2
# - order = [5,4,3,2,1] -> 5

# ✅ 정답 코드(한 줄 주석):
def solution(order):
    n = len(order)                           # 전체 상자 개수
    stack = []                               # 보조 벨트(스택)
    cur = 1                                  # 메인 컨베이어에서 다음에 꺼낼 상자 번호
    idx = 0                                  # order에서 다음으로 실어야 할 인덱스
    loaded = 0                               # 적재한 상자 수 카운트

    while cur <= n:                          # 메인 컨베이어가 남아 있는 동안
        if order[idx] == cur:                # 1) 메인에서 바로 실을 수 있으면
            loaded += 1                      #    적재 카운트 증가
            idx += 1                         #    다음 목표로 이동
            cur += 1                         #    다음 컨베이어 상자로 이동
        elif stack and stack[-1] == order[idx]:
            stack.pop()                      # 2) 스택 top이 목표면 pop해서 적재
            loaded += 1                      #    적재 카운트 증가
            idx += 1                         #    다음 목표로 이동
        else:
            stack.append(cur)                # 3) 둘 다 아니면 현재 상자를 스택에 보관
            cur += 1                         #    다음 컨베이어 상자로 이동

    while stack and idx < n and stack[-1] == order[idx]:
        stack.pop()                          # 메인 소진 후에도 스택 top이 목표라면 계속 적재
        loaded += 1                          # 적재 카운트 증가
        idx += 1                             # 다음 목표로 이동

    return loaded                            # 적재 가능한 총 개수 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 한 번에 정답 도출 (힌트 사용 안 함)

# 📚 사용된 개념 요약:
# - 시뮬레이션 패턴: 메인(증가 포인터) + 보조(스택) 조합
# - 각 상자는 최대 1회 push/1회 pop → 시간복잡도 O(n), 공간 O(n)
# - 슬라이싱/리스트 앞 pop 금지(시간 폭발 유발)
