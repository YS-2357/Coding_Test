# 87390_n^2_배열_자르기.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - n x n 크기의 2차원 배열 a에서 a[i][j] = max(i, j) + 1로 정의됨
# - 이 배열을 1차원으로 펴서 left ~ right 구간만 잘라서 반환
#
# ✅ 입력:
# - n: 정수 (1 ≤ n ≤ 10^7)
# - left, right: 정수 (0 ≤ left ≤ right < n²)
#
# ✅ 출력:
# - 1차원 배열에서 left~right 인덱스에 해당하는 값들의 리스트
#
# ✅ 예시:
#   입력: n = 3, left = 2, right = 5
#   출력: [3, 2, 2, 3]
#
#   배열 형태:
#   [
#     [1, 2, 3],
#     [2, 2, 3],
#     [3, 3, 3]
#   ]
#   → 1차원으로 펴면: [1,2,3,2,2,3,3,3,3]
#   → 인덱스 2~5: [3,2,2,3]
# -----------------------------------------------------

def solution(n, left, right):
    answer = []

    # ✅ left부터 right까지 순회
    for i in range(left, right + 1):
        row = i // n       # 행 인덱스
        col = i % n        # 열 인덱스

        # ✅ 배열 규칙: a[row][col] = max(row, col) + 1
        value = max(row, col) + 1
        answer.append(value)

    return answer  # 결과 리스트 반환

# -----------------------------------------------------
# ✅ 나의 오답 및 실수:
# ❌ 처음엔 전체 2차원 배열을 생성하고 값을 넣으려 했으나, n이 10^7까지 가능해 메모리 초과 발생
# ❌ 시간복잡도 O(n^2) 접근을 시도함 → 제한 시간 초과
#
# ✅ GPT가 준 힌트 요약:
# - 전체 배열을 생성하지 말고, 수학적으로 필요한 위치의 값만 계산
# - 1차원 인덱스를 2차원 좌표로 변환: row = i // n, col = i % n
# - a[i][j] = max(i, j) + 1 규칙을 그대로 적용
#
# ✅ 사용된 개념 요약:
# - 1차원 인덱스를 2차원으로 변환: (i // n, i % n)
# - 수학적 수식으로 특정 위치의 값만 계산 → 메모리 사용 최소화
#
# ✅ 시간 복잡도:
# - O(right - left + 1): 최대 10^7 → 효율적
# - 메모리도 리스트 한 줄만 사용 → 문제 조건 만족
# -----------------------------------------------------
