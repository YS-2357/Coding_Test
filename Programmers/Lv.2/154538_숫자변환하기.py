# 154538_숫자변환하기.py
# -----------------------------------------------------
# ✅ 제목: 숫자 변환하기
# ✅ 문제 설명(요약):
# - 정수 x를 시작값으로 두고, y로 변환하고자 한다.
# - 사용할 수 있는 연산은 (1) +n, (2) *2, (3) *3.
# - 최소 연산 횟수를 구하며, 불가능할 경우 -1을 반환한다.
#
# ✅ 입력 형식(요지):
# - x, y, n (1 ≤ x ≤ y ≤ 1,000,000)
#
# ✅ 규칙 요약:
# 1) 연산은 세 가지(+n, *2, *3)만 가능.
# 2) y보다 큰 수로는 확장하지 않는다.
# 3) BFS 탐색으로 최소 연산 횟수 보장.
# 4) 불가능 시 -1 반환.
#
# ✅ 정답 코드(나의 풀이; 한 줄마다 주석):
from collections import deque

def solution(x, y, n):
    queue = deque([(x, 0)])              # (현재 값, 연산 횟수)
    visited = {x}                        # 방문 집합 (중복 방지)
    ops = [lambda v: v + n,              # 세 가지 연산을 람다로 정의
           lambda v: v * 2,
           lambda v: v * 3]
    
    while queue:                         # BFS 탐색
        cur, cnt = queue.popleft()
        
        if cur == y:                     # 목표에 도달하면 반환
            return cnt
        
        for op in ops:                   # 세 연산을 순차 적용
            nxt = op(cur)
            if nxt <= y and nxt not in visited:  # 범위 및 방문 확인
                visited.add(nxt)
                queue.append((nxt, cnt + 1))
        
    return -1                            # 도달 불가 시 -1 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - BFS 구조와 방문 관리로 문제 요구 조건 충족.
# - 테스트케이스에 대해 올바른 최소 횟수 반환 확인.

# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - 초기에는 +n, *2, *3을 개별 if문으로 작성 → 중복 코드 발생.
# - 람다 리스트 ops로 정리하여 반복문에서 처리하도록 개선.
# - 방문 배열 대신 set을 사용해 중복 방지.

# 📚 사용된/필수 개념(최소):
# - BFS (모든 간선 비용 동일일 때 최단거리 탐색)
# - 방문 관리(set)
# - 연산 함수를 리스트로 관리 (람다 활용)
# - 시간복잡도: O(y−x), 공간복잡도: O(y−x)

# 🧠 (선택) 다른 효율적인 풀이 또는 알고리즘 제안:
# - DP 접근: dp[i] = min(dp[i-n], dp[i/2], dp[i/3]) + 1 로 점화식 구현 가능.
#   이 경우 O(y−x) 시간으로 가능하며 배열 하나로 관리할 수 있음.

# -----------------------------------------------------
# 다른 풀이
# def solution(x, y, n):
#     INF = 10**9
#     dp = [INF] * (y + 1)
#     dp[x] = 0
    
#     for i in range(x, y + 1):
#         if dp[i] == INF:
#             continue
#         if i + n <= y:
#             dp[i + n] = min(dp[i + n], dp[i] + 1)
#         if i * 2 <= y:
#             dp[i * 2] = min(dp[i * 2], dp[i] + 1)
#         if i * 3 <= y:
#             dp[i * 3] = min(dp[i * 3], dp[i] + 1)
    
#     return dp[y] if dp[y] != INF else -1
