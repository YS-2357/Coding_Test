# 118667_두_큐_합_같게_만들기.py
# -----------------------------------------------------
# ✅ 제목: 두 큐 합 같게 만들기
# ✅ 문제 설명(요약):
# - 두 큐의 합을 같게 만들기 위해, 한쪽 큐의 맨 앞 원소를 꺼내 다른 큐 뒤에 넣는 연산을 수행.
# - 최소 연산 횟수를 구하고, 불가능하면 -1을 반환.

# ✅ 입력 형식(요지):
# - queue1, queue2: 길이 같은 정수 배열 (1 ≤ 원소 ≤ 10^9, 길이 ≤ 300,000)

# ✅ 규칙 요약:
# 1) 전체 합이 홀수면 불가능 → -1
# 2) 목표 합 target = total//2
# 3) s1 > target → queue1에서 pop → queue2에 push
#    s1 < target → queue2에서 pop → queue1에 push
# 4) 포인터(i, j)로 시뮬레이션하며 합을 갱신
# 5) 제한 횟수 넘어가면 불가능 처리

# ✅ 정답 코드(나의 풀이; 한 줄마다 주석)
def solution(queue1, queue2):
    s1, s2 = sum(queue1), sum(queue2)        # 초기 합
    if s1 == s2:                             # 이미 같으면 0
        return 0
    
    total = s1 + s2
    if total % 2 == 1:                       # 전체 합 홀수면 불가능
        return -1
    
    answer = 0
    target = total // 2                      # 목표 합
    i, j, n = 0, len(queue1), len(queue1) + len(queue2)
    arr = queue1 + queue2                    # 두 큐 이어붙여 배열로 관리
    
    while i < n and j < n:                   # 두 포인터 모두 범위 내에서 반복
        if s1 == target:                     # 합이 맞으면 종료
            return answer
        elif s1 > target:                    # 큐1이 크면 i 포인터 이동
            s1 -= arr[i]
            i += 1
            answer += 1
        else:                                # 큐1이 작으면 j 포인터 이동
            s1 += arr[j]
            j += 1
            answer += 1
    
    return -1                                # 끝까지 안 맞으면 불가능

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 합이 동일하면 즉시 0 반환.
# - 포인터로 원소 이동을 시뮬레이션하며 합을 조정.
# - 정상적으로 최소 연산 횟수 출력.

# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - 초기에는 deque pop/append 방식만 고려했으나 O(N^2) 위험 → 포인터 방식으로 수정.
# - total 합 변수 오타(`tatal2`)가 있었음 → `s2`로 수정.

# 📚 사용된/필수 개념:
# - 투 포인터(슬라이딩 윈도우) 방식
# - 합 조정으로 목표값 도달 여부 판단
# - 시간복잡도 O(N), 공간 O(N)

# 🧠 (선택) 다른 효율적인 풀이 또는 알고리즘 제안:
# - deque로 직접 `popleft/append` 연산 구현도 가능(O(N)), 다만 파이썬에서는 포인터 방식이 더 빠름.
# - 슬라이딩 윈도우 관점으로도 해석 가능: arr 내에서 합이 target인 구간 찾기 문제.
