# 131701_연속_부분_수열_합의_개수.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - 원형으로 연결된 수열에서 가능한 모든 연속 부분 수열의 합을 구한다.
# - 합의 중복을 제거하고 서로 다른 합의 개수를 반환한다.
#
# ✅ 입력:
# - elements: 길이 1 이상 1,000 이하의 정수 리스트
#
# ✅ 출력:
# - 가능한 서로 다른 부분합의 개수 (정수)
#
# ✅ 예시:
# 입력: [7, 9, 1, 1, 4]
# 출력: 18
# -----------------------------------------------------

def solution(elements):
    count = 0  # 부분 수열의 길이를 조절하기 위한 변수
    n = len(elements)  # 원래 배열의 길이
    answer = []  # 가능한 모든 부분합을 저장할 리스트
    elements = elements * 2  # 원형 배열을 선형으로 처리하기 위해 2배 확장

    # ✅ 누적합(prefix sum) 배열 생성
    # prefix[i]는 elements[0:i]까지의 합 (i는 1-based index)
    prefix = [0]
    for element in elements:
        prefix.append(prefix[-1] + element)  # 이전 값 + 현재 원소 → 누적합 저장

    # ✅ 부분합 계산
    # 길이 1부터 n까지의 연속 부분합을 모두 계산
    while count <= n:
        for i in range(1, n + 1):  # 시작 인덱스 i (prefix는 1-based)
            # 부분합 = prefix[end] - prefix[start]
            # end = i + count, start = i
            answer.append(prefix[i + count] - prefix[i])
        count += 1  # 부분합 길이 증가

    # ✅ set을 사용하여 중복 제거 후 개수 반환
    # 부분합 리스트 answer에서 0도 포함되므로 마지막에 -1
    return len(set(answer)) - 1

# -----------------------------------------------------
# ✅ 나의 부족했던 개념 & 2단계에서 놓친 부분:
# ❌ 단순히 sum()으로 부분합을 구하면 시간복잡도가 O(n^3)에 달할 수 있어 효율성 실패
# ❌ 원형 배열 처리 시 단순 인덱스 연산만 생각하고, prefix로 O(1) 구간 합 계산 개념을 놓침
#
# ✅ GPT가 준 힌트 요약:
# - **Prefix Sum(누적합)**을 사용하면 부분합을 O(1)에 구할 수 있음
# - 원형 배열은 2배 확장으로 선형처럼 처리 가능
#
# ✅ 사용된 개념 요약:
# - **Prefix Sum**: prefix[i] = 첫 i개 원소의 합 → 부분합 계산 최적화
# - **원형 배열 처리**: 배열 확장으로 원형 조건 해소
# - **set**: 중복된 합 제거 후 개수 반환
#
# ✅ 시간 복잡도:
# - prefix 배열 생성: O(n)
# - 부분합 계산: O(n^2)
# 전체 O(n^2) → n 최대 1000에서 충분히 가능
# -----------------------------------------------------
