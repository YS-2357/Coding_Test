# 49994_방문_길이.py
# -----------------------------------------------------
# ✅ 제목: 방문 길이
# ✅ 문제 설명(요약):
# - (0,0)에서 시작해 dirs 문자열에 따라 U/D/L/R로 이동한다.
# - 좌표 범위는 -5 ≤ x,y ≤ 5, 범위를 벗어나면 이동 무시.
# - 처음 지나가는 길(간선)만 카운트하며, 같은 길을 여러 번 지나도 1번만 센다.
#
# ✅ 입력 형식(요지):
# - dirs: str, 'U','D','L','R' 문자들의 시퀀스
#
# ✅ 규칙 요약:
# 1) 간선(길)은 방향 없는 무향 간선으로 취급해야 한다.
#    예: (0,0)→(0,1) 과 (0,1)→(0,0)은 같은 간선.
# 2) 경계를 벗어나는 이동은 무시(좌표 변화 없음, 간선 추가 없음).
# 3) 최종적으로 서로 다른 간선의 개수를 반환.
#
# ✅ 정답 코드(너의 풀이; 한 줄마다 주석):
def solution(dirs):
    answer = 0
    x, y = 0, 0                                      # 시작 좌표
    dir_map = {
        "L": (-1, 0),
        "R": (1, 0),
        "U": (0, 1),
        "D": (0, -1)
    }
    edges = set()                                    # 무향 간선들을 저장할 집합
    for direction in dirs:
        dx, dy = dir_map[direction]
        nx, ny = x + dx, y + dy                      # 이동 후 좌표 후보
        if -5 <= nx <= 5 and -5 <= ny <= 5:          # 범위 안에 있을 때만 이동
            # 무향 간선 정규화: 두 점을 작은 것, 큰 것으로 정렬해 저장
            edge = (min((x, y), (nx, ny)), max((x, y), (nx, ny)))
            edges.add(edge)                          # 간선을 집합에 추가(중복 자동 제거)
            x, y = nx, ny                            # 위치 갱신
    answer = len(edges)                              # 서로 다른 간선 수
    return answer

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 방향성 문제를 고쳐서 모든 테스트케이스 통과.
#
# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - 초기에는 (x,y,nx,ny)를 그대로 저장해 (0,0→0,1)과 (0,1→0,0)을 서로 다르게 취급.
# - 수정: 두 점을 정렬(min, max)해 무향 간선으로 동일하게 인식.
#
# 📚 사용된/필수 개념(최소):
# - 무향 간선 처리: (a,b)와 (b,a)를 하나로 묶기 → 정규화
# - 집합(set)을 이용한 중복 제거
# - 시간복잡도: O(len(dirs)), 공간복잡도: O(len(dirs))
#
# 🧠 왜 edge를 (min, max)로 하면 무향 정규화가 될까?
# - 간선은 두 점 A,B로 정의되는데, 방향이 없으면 (A,B)와 (B,A)를 같은 것으로 봐야 한다.
# - 파이썬에서 튜플 비교는 **사전식(lexicographic) 순서**로 된다.
#   * `min((0,0),(0,1))` → (0,0)
#   * `max((0,0),(0,1))` → (0,1)
# - 즉, 두 좌표의 순서를 항상 “작은 것 먼저, 큰 것 나중”으로 강제하는 것.
# - 그래서 (0,0→0,1)과 (0,1→0,0) 모두 `( (0,0), (0,1) )`로 같은 튜플이 된다.
# - 이 과정을 **정규화(normalization)**라고 부른다.
