# 17684_압축.py
# -----------------------------------------------------
# ✅ 제목: 압축 (LZW)
# ✅ 문제 설명(요약):
# - 초기 사전: 'A'~'Z' → 1~26.
# - msg를 왼쪽부터 보며 사전에 있는 가장 긴 문자열 w를 출력(색인).
# - w 뒤 한 글자 c가 있다면 w+c를 사전에 새로 등록.
# - 전 과정을 끝까지 반복해 출력 색인들의 리스트를 반환.
#
# ✅ 입력 형식(요지):
# - msg: 대문자 알파벳 문자열 (길이 ≤ 1000 수준)
#
# ✅ 규칙 요약:
# 1) 사전 초기화: A..Z → 1..26
# 2) 가장 긴 w 찾기 → 그 색인 출력
# 3) w 뒤 글자 c가 존재하면 w+c를 사전에 추가
# 4) msg를 w 길이만큼 앞으로 진행
#
# ✅ 정답 코드(너의 풀이; 한 줄마다 주석):
def solution(msg):
    answer = []                                        # 출력 색인들을 담을 리스트
    dict_map = {chr(i+64): i for i in range(1, 27)}   # 'A'~'Z'를 1~26으로 초기화 (A=65 → chr(65)= 'A')
    
    temp = ''                                          # 현재까지 누적한 후보 문자열 w
    while msg:                                         # 입력이 남아 있는 동안 반복
        w, msg = msg[0], msg[1:]                       # 왼쪽에서 한 글자 꺼내고 나머지로 갱신
        temp += w                                      # 후보 w에 글자 추가 (가장 긴 사전 항목을 점차 탐색)
        if temp not in dict_map:                       # 현재 temp가 사전에 없다면(넘쳤다면)
            answer.append(dict_map[temp[:-1]])         # 직전까지(=temp[:-1])가 사전에 있던 가장 긴 문자열 → 색인 출력
            dict_map[temp] = len(dict_map) + 1         # 새로 발견된 문자열 temp를 사전에 등록 (새 번호 부여)
            temp = ''                                  # 후보 초기화
            msg = w + msg                              # 방금 넣었던 글자 w는 아직 소비되지 않은 다음 탐색의 첫 글자로 되돌림
    answer.append(dict_map[temp])                      # 루프 종료 후 남은 최종 후보 temp의 색인 출력
        
    return answer                                      # 출력 리스트 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 예시 "KAKAO" → [11, 1, 27, 15]로 기대값과 일치.
# - 사전 등록/출력 타이밍(넘쳤을 때 직전 문자열 출력) 정확.
#
# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - (잠재) temp가 사전에 없을 때 직전 문자열 출력 순서 누락 위험 → `temp[:-1]` 사용으로 해결.
# - (잠재) pop-프런트 슬라이싱은 O(n) 비용 → 입력 길이가 커지면 비효율 가능(이 문제 크기에서는 통과).
#
# 📚 사용된/필수 개념(최소):
# - LZW 핵심: 가장 긴 일치 w 출력 후, w+c 등록
# - 해시맵 사전(문자열 → 색인)
# - 시간복잡도: 평균 O(N)~O(N²) (파이썬 슬라이싱/멤버십에 따라), 공간 O(N) (사전 크기)
#
# 🧠 (선택) 다른 효율적인 풀이 또는 알고리즘 제안:
# - 인덱스 포인터(i)를 사용해 `msg`를 슬라이싱하지 않고 진행하면 문자열 복사 비용 감소.
# - `while i < len(msg):`로 두 포인터 확장해 “가장 긴 w”를 찾고, i를 w 길이만큼 전진.
