# 12980_점프와_순간이동.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - 거리 N까지 이동할 때, 순간이동(비용 0)과 점프(비용 1)를 이용한다.
# - 목표: 배터리 소모(점프 횟수)를 최소화.
# - 점프는 1칸 이동, 순간이동은 현재 거리 * 2 이동.

# ✅ 입력:
# - n: 목표 거리 (1 ≤ n ≤ 10,000,000)

# ✅ 출력:
# - 최소 건전지 사용량 (정수)

# ✅ 예시:
#   입력: 5 → 출력: 2
#   (이유: 0→1(점프,1)→2(순간이동)→4(순간이동)→5(점프,1) → 총 2번 점프)
# -----------------------------------------------------

def solution(n):
    ans = 0  # 건전지 사용량(점프 횟수)

    # N에서 1까지 거꾸로 줄여나가며 최소 비용 계산
    while n != 1:
        if n % 2 == 0:
            # 짝수이면 순간이동 가능 → 배터리 소모 X
            n = n // 2
        else:
            # 홀수이면 점프 필요 → 배터리 1 소모 후 1칸 감소
            n -= 1
            ans += 1
            # 그 다음은 순간이동 (n // 2)
            n = n // 2

    # 마지막 남은 1은 점프해야 하므로 1 추가
    ans += 1

    return ans

# -----------------------------------------------------
# ✅ 사용된 개념 요약:
# - **거꾸로 접근**:
#   - 목표 N에서 0까지 역으로 줄이며 최소 점프 횟수 계산.
# - **조건 분기**:
#   - N 짝수 → 순간이동 (비용 0, n//=2)
#   - N 홀수 → 점프 (비용 1, n-=1 → n//=2)
# - **최종 패턴**:
#   - N의 이진수에서 1의 개수가 배터리 사용량과 동일.
#   - 예: N=5 (이진수 101) → 1의 개수=2 → 정답=2
# ✅ 시간 복잡도:
# - O(log N): N을 계속 2로 나누기 때문에 매우 빠름.
# -----------------------------------------------------

# N의 이진 표현에서 '1'의 개수 세기
# def solution(n):
#     return bin(n).count('1')
