# 17679_프렌즈4블록.py
# -----------------------------------------------------
# ✅ 제목: 프렌즈4블록
# ✅ 문제 설명(요약):
# - m×n 보드에서 같은 문자 2×2 블록을 찾고 제거한다.
# - 제거 후 위의 블록들이 아래로 떨어지며 빈칸을 채운다.
# - 더 이상 제거할 블록이 없을 때까지 반복하고, 제거된 총 블록 수를 반환한다.
#
# ✅ 입력 형식(요지):
# - m, n: 보드 크기
# - board: 길이 m의 문자열 리스트(각 문자열 길이 n)
#
# ✅ 규칙 요약:
# 1) 같은 문자로 이루어진 2×2를 한 라운드에서 모두 표시 후 일괄 제거.
# 2) 제거된 칸 수를 누적.
# 3) 각 열마다 블록을 아래로 낙하시켜 빈칸('.')을 위로 올림.
# 4) 라운드를 반복하다가 더 이상 제거할 블록이 없으면 종료.
#
# ✅ 정답 코드(나의 풀이; 한 줄마다 주석):
def solution(m, n, board):
    answer = 0
    board = [list(row) for row in board]   # 문자열 → 리스트로 변환(가변)
    
    while True:
        to_remove = set()                   # 라운드마다 초기화
        for i in range(m):
            for j in range(n):
                if 0 <= i < m-1 and 0 <= j < n-1:  # 경계 내 2×2만 검사
                    block = {board[i][j], board[i][j+1], board[i+1][j], board[i+1][j+1]}
                    if len(block) == 1 and '.' not in block:  # 동일 문자이면서 빈칸 아님
                        to_remove.add((i,j))
                        to_remove.add((i+1,j))
                        to_remove.add((i,j+1))
                        to_remove.add((i+1,j+1))
        if not to_remove:                   # 더 지울 게 없으면 종료
            break

        for i, j in to_remove:              # 표시된 칸 제거
            board[i][j] = "."
            answer += 1

        for j in range(n):                  # 열 단위 낙하
            col = [board[i][j] for i in range(m) if board[i][j] != "."]  # 블록만 추출
            for i in range(m-1, -1, -1):    # 아래부터 재배치
                if col:
                    board[i][j] = col.pop()
                else:
                    board[i][j] = "."
    
    return answer

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 라운드 반복 → 표시 후 일괄 제거 → 열 단위 낙하의 핵심 흐름을 구현.
# - set으로 중복 좌표 제거, 리스트 변환으로 제자리 치환 가능.

# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - (초기) 문자열 불변으로 치환 실패 → board를 list(list)로 변환하여 해결.
# - (초기) 라운드 간 표시 누적 문제 → while 루프 시작 시 to_remove 매 라운드 초기화.
# - (개선 여지) 경계 체크를 매번 if로 검사 → for 범위를 (m-1),(n-1)로 줄여 가독성/미세성능 개선 가능.

# 📚 사용된/필수 개념(최소):
# - 2×2 패턴 탐지: set 크기 1 조건으로 동일문자 판정
# - 일괄 제거 후 낙하: 열별 압축(rebuild)로 구현
# - 반복 시뮬레이션: 변화 없을 때 종료
# - 시간복잡도: 라운드당 O(mn), 라운드 수는 최대 O(mn)보다 훨씬 작음(실전 통과 범위)
# - 공간복잡도: O(mn) (보드, 보조 리스트)

# 🧠 (선택) 다른 효율적인 풀이 또는 알고리즘 제안:
# - 낙하를 while-swap(아래가 '.'이면 swap)로 구현할 수도 있으나,
#   현재처럼 열 압축 방식이 단순하고 빠르다.
# - 탐지 단계에서 for i in range(m-1), for j in range(n-1)로 경계 if 제거 권장.
