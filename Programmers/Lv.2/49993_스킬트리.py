# 49993_스킬트리.py
# -----------------------------------------------------
# ✅ 제목: 스킬트리
# ✅ 문제 설명(요약):
# - 특정 선행 스킬 순서(skill)가 주어짐.
# - 여러 개의 스킬트리 중에서, 이 순서를 위배하지 않고 배울 수 있는
#   스킬트리의 개수를 세는 문제.
#
# ✅ 입력 형식(요지):
# - skill: 문자열 (선행 스킬 순서, 길이 ≤ 26)
# - skill_trees: 문자열 배열 (각 원소는 스킬트리)
#
# ✅ 규칙 요약:
# 1) skill에 포함되지 않은 스킬은 순서에 상관없이 언제든 배울 수 있음.
# 2) skill에 포함된 스킬은 반드시 주어진 순서대로만 배워야 함.
# 3) 일부 스킬은 생략 가능. (앞에서부터 접두사 형태만 허용)
#
# ✅ 정답 코드(너의 풀이; 한 줄마다 주석):
def solution(skill, skill_trees):
    answer = 0
    for tree in skill_trees:
        need = 0                   # skill에서 다음으로 와야 할 인덱스
        ok = True                  # 현재 스킬트리 유효 여부
        for c in tree:             # 스킬트리의 각 문자 순회
            if c not in skill:     # 선행 스킬에 없는 것은 무시
                continue
            if c == skill[need]:   # 기대하는 스킬이면 통과
                need += 1
            else:                  # 순서 위배
                ok = False
                break
        if ok:                     # 끝까지 위배 없으면 유효
            answer += 1
    return answer                  # 가능한 스킬트리 개수 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - skill 순서를 포인터(need)로 추적하여 유효성 판별 성공.
# - 문제의 조건을 모두 충족하는 정답 코드 구현 완료.

# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - 초기에 stack 구조를 떠올렸으나 불필요하게 복잡해짐 → 포인터 방식으로 단순화.
# - skill에 포함되지 않은 스킬을 무조건 처리하려다 오류 가능성 → 무시하도록 수정.
# - skill 인덱스(need)가 끝까지 도달한 이후에도 검사할 수 있으므로, 
#   이 경우 안전하게 loop를 종료하는 처리를 고려할 수 있음.

# 📚 사용된/필수 개념(최소):
# - 포인터(two-pointer 느낌): skill 내 다음 위치를 추적
# - 문자열 순회 + 조건 분기
# - 접두사 관계 검사 아이디어
# - 시간복잡도: O(Σ 길이) (각 tree 한 번씩만 순회), 공간복잡도: O(1)

# 🧠 (선택) 다른 효율적인 풀이 또는 알고리즘 제안:
# - "필터 + 접두사 검사" 방식:
#   각 스킬트리에서 skill에 포함된 문자만 추출 후,
#   그 결과가 skill의 접두사(prefix)인지 확인 → 구현 단순, 가독성 높음.
