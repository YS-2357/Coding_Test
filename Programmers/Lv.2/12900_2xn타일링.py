# 12900_2xn타일링.py
# -----------------------------------------------------
# ✅ 제목: 2×n 타일링
# ✅ 문제 설명(요약):
# - 2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 경우의 수를 구하는 문제.
# - 결과는 1,000,000,007로 나눈 나머지를 반환한다.
#
# ✅ 입력 형식(요지):
# - n (1 ≤ n ≤ 60,000)
#
# ✅ 규칙 요약:
# 1) f(n) = f(n-1) + f(n-2) (피보나치 수열 형태)
# 2) 초기값: f(0) = 1, f(1) = 1
# 3) 모든 계산은 MOD = 1,000,000,007로 나눈다.
#
# ✅ 정답 코드(나의 풀이; 한 줄마다 주석):
def solution(n):
    MOD = 1000000007
    dp = [0] * (n + 1)      # DP 테이블 초기화
    dp[0] = 1               # 2×0 보드 채우는 경우: 1 (아무 것도 안 놓기)
    dp[1] = 1               # 2×1 보드 채우는 경우: 세로 타일 1개
    for i in range(2, n+1): # 점화식 적용
        dp[i] = (dp[i-1] + dp[i-2]) % MOD
    return dp[n]            # 최종 결과 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - DP 점화식을 그대로 구현하여 정상 작동.
# - 작은 n, 큰 n 모두 조건에 맞게 동작.

# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - 초기에는 f(1)=1, f(2)=2라는 정의를 혼동할 수 있음 → dp[0]=1, dp[1]=1 설정으로 해결.
# - 모듈러 연산을 루프마다 적용하지 않으면 오버플로 발생 가능 → 매 연산마다 % MOD 추가.

# 📚 사용된/필수 개념(최소):
# - DP(피보나치 점화식 기반)
# - 점화식: f(n)=f(n-1)+f(n-2)
# - 모듈러 연산
# - 시간복잡도: O(n)
# - 공간복잡도: O(n) (리스트 사용)

# 🧠 (선택) 다른 효율적인 풀이 또는 알고리즘 제안:
# - 공간 최적화: 배열 대신 두 변수(prev1, prev2)만 유지 → O(1) 공간 가능.
# - O(log n) 방법: 행렬 거듭제곱으로 피보나치 수열 계산.
