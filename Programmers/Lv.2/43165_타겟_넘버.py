# 43165_타겟_넘버.py
# -----------------------------------------------------
# ✅ 제목: 타겟 넘버
# ✅ 문제 설명(요약):
# - 숫자 배열 numbers가 주어진다.
# - 각 원소 앞에 + 또는 -를 붙여 합을 계산한다.
# - 그 합이 target이 되는 경우의 수를 반환한다.
#
# ✅ 입력 형식(요지):
# - numbers: List[int], 길이 N (2 ≤ N ≤ 20)
# - target: int
#
# ✅ 규칙 요약:
# 1) 각 숫자마다 + 또는 - 두 가지 선택지가 있다.
# 2) 모든 선택지를 적용했을 때 합이 target과 같아지는 경우의 수를 센다.
# 3) 가능한 경우의 수를 정수로 반환.
#
# ✅ 정답 코드(너의 풀이; 한 줄마다 주석):
def solution(numbers, target):
    answer = 0
    
    def dfs(total, count):
        if count == len(numbers):                       # 모든 숫자를 다 사용했을 때
            return 1 if total == target else 0          # 합이 target이면 경우의 수 1, 아니면 0 반환
        left = dfs(total+numbers[count], count+1)       # 현재 숫자에 + 붙이고 다음 단계로
        right = dfs(total-numbers[count], count+1)      # 현재 숫자에 - 붙이고 다음 단계로
        return left + right                             # 두 가지 경우의 수를 합산
    
    answer = dfs(0, 0)                                  # 초기 상태: 합=0, 인덱스=0
    return answer                                       # 전체 경우의 수 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 한 번에 정답. DFS 구조와 종료 조건을 정확히 처리.
#
# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - 초안에서는 dfs가 total 합만 반환해서 경우의 수를 누적하지 못함.
# - 수정: 리프 노드에서 1/0을 반환하도록 하고, 재귀 호출 결과를 더해 경우의 수를 누적.
#
# 📚 사용된/필수 개념(최소):
# - 깊이 우선 탐색(DFS) / 백트래킹
# - 재귀적 경우의 수 합산
# - 시간복잡도: O(2^N) (각 숫자에 대해 +/− 분기)
# - 공간복잡도: O(N) (재귀 호출 스택)
#
# 🧠 (선택) 다른 효율적인 풀이 또는 알고리즘 제안:
# - BFS 방식으로 큐에 현재 합을 넣고, 한 단계씩 확장하며 경우의 수 세기.
# - 동적 계획법(DP): 가능한 합들을 딕셔너리(합→경우의 수)로 관리하며 숫자마다 업데이트.
#   → 중복 상태를 합쳐서 효율성을 조금 높일 수 있음.
