# 77885_2개_이하로_다른_비트.py
# -----------------------------------------------------
# ✅ 제목: 2개 이하로 다른 비트
# ✅ 문제 설명(요약):
# - 주어진 정수 배열 numbers에 대해,
#   각 원소 x보다 큰 수 중 이진수 표현에서 다른 비트가 2개 이하인
#   가장 작은 수를 찾아 반환한다.
#
# ✅ 입력 형식(요지):
# - numbers: 정수 배열 (1 ≤ x < 10^15, 길이 ≤ 100,000)
#
# ✅ 규칙 요약:
# 1) 짝수 x → 결과는 x+1 (LSB가 0→1로만 변함).
# 2) 홀수 x → 이진수 끝부분이 …0111 꼴.
#    - 오른쪽에서 처음 만나는 0을 1로, 그 바로 오른쪽의 1을 0으로 바꾼다.
#    - 결과적으로 두 비트만 바뀌며 x보다 큰 최소값이 됨.
#
# ✅ 정답 코드(나의 풀이; 한 줄마다 주석):
def solution(numbers):
    answer = []
    for x in numbers:
        if x % 2 == 0:                 # 짝수: LSB만 0→1로
            answer.append(x + 1)
            continue

        bits = list("0" + bin(x)[2:])  # 홀수: 앞에 0 붙여 안전 처리
        bits.reverse()                 # 뒤에서부터 탐색하기 위해 reverse
        if bits[0] == "0":             # 맨 끝이 0이면 바로 1로 (사실 홀수면 여기 안 걸림)
            bits[0] = "1"
        else:                          # 끝이 1 → 오른쪽에서 첫 0 찾기
            for i in range(1, len(bits)):
                if bits[i] == "0":
                    bits[i], bits[i-1] = "1", "0"  # 0→1, 직전 1→0
                    break
        bits.reverse()
        answer.append(int("".join(bits), 2))  # 다시 10진수로 변환

    return answer

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 짝수/홀수 케이스 분리, bin 문자열 변환을 통한 비트 조작으로 구현 성공.
# - 홀수의 연속 1 꼬리 처리도 잘 동작.

# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - (초기 아이디어) bin(x) 결과를 문자열 그대로 쓰면 수정 불가 → list로 변환.
# - (초기) 모든 케이스를 loop로만 처리하려다 홀수/짝수 구분이 더 간단 → 분리 처리.
# - reverse/다시 reverse 단계가 조금 장황하나, 로직 이해에는 직관적.

# 📚 사용된/필수 개념(최소):
# - 이진수 변환: bin(x)
# - 문자열 → 리스트 변환 후 직접 비트 수정
# - 홀수: “연속된 1 꼬리 블록을 왼쪽 한 칸 밀기” 규칙
# - 시간복잡도: O(L) (L=비트 길이, 최대 60) → 전체 O(N)

# 🧠 (선택) 다른 효율적인 풀이 또는 알고리즘 제안:
# - 수학적 비트연산 공식을 쓰면 더 간단:
#   f(x) = x+1,  f(x) = x+1 + ((x^(x+1)) >> 2) (홀수의 경우).
#   → 문자열 변환 없이도 O(1)에 처리 가능.
