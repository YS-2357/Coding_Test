# 154539_뒤에_있는_큰_수_찾기.py
# -----------------------------------------------------
# ✅ 제목: 뒤에 있는 큰 수 찾기
# ✅ 문제 설명(요약):
# - numbers 배열에서 각 위치 i의 값보다 오른쪽에 있는 "처음으로 큰 값"을 찾는다.
# - 없다면 -1로 기록한다.
# - 결과 배열을 반환한다.
#
# ✅ 입력 형식(요지):
# - numbers: List[int], 길이 n (1 ≤ n ≤ 1,000,000)
#
# ✅ 규칙 요약:
# 1) i < j이고 numbers[j] > numbers[i]인 가장 작은 j를 찾아 numbers[i]의 답으로 삼는다.
# 2) 없다면 -1.
#
# ✅ 정답 코드(너의 풀이; 한 줄마다 주석):
def solution(numbers):
    n = len(numbers)
    answer = [-1] * n                             # 결과 배열을 -1로 초기화
    stack = []                                    # "아직 다음 큰 수를 못 찾은 인덱스"를 담는 스택
    
    for i in range(n):                            # 왼쪽에서 오른쪽으로 순회
        while stack and numbers[stack[-1]] < numbers[i]:
            answer[stack.pop()] = numbers[i]      # 스택 top보다 큰 값이 나오면 해당 인덱스의 답 확정
        stack.append(i)                           # 현재 인덱스를 스택에 추가
    
    return answer                                 # 결과 배열 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 모든 테스트케이스에서 정답. O(n^2) 아닌 O(n)으로 해결됨.
#
# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - 초기에는 heapq를 이용했으나 "가장 작은 값"만 뽑아 순서 조건(오른쪽에서 처음 등장)을 지키지 못함.
# - 수정: 모노토닉 스택(인덱스 저장)을 사용하여 오른쪽 첫 큰 값을 정확히 찾음.
#
# 📚 사용된/필수 개념(최소):
# - 모노토닉 스택(단조 감소 스택)
# - 각 인덱스의 다음 큰 수를 스택으로 추적
# - 시간복잡도: O(n) (각 인덱스 최대 1회 push + pop)
# - 공간복잡도: O(n) (스택과 결과 배열)
#
# 🧠 (선택) 다른 효율적인 풀이 또는 알고리즘 제안:
# - 오른쪽에서 왼쪽으로 스캔하면서 "현재보다 큰 값만 남기는 스택"으로 처리해도 된다.
# - 이 경우 스택에는 후보 값 자체를 저장하고, 답은 스택 top으로 채운다.
