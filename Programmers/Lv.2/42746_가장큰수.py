# 42746_가장큰수.py
# -----------------------------------------------------
# ✅ 제목: 가장 큰 수
# ✅ 문제 설명(요약):
# - 정수 배열 numbers를 이어붙였을 때 만들 수 있는 가장 큰 수를 문자열로 반환.
#
# ✅ 입력 형식(요지):
# - numbers: 정수 배열 (0 ≤ 원소 ≤ 1000, 길이 ≤ 100,000)
#
# ✅ 규칙 요약:
# 1) 단순 내림차순 정렬은 실패.
# 2) 두 수 a, b를 문자열로 두었을 때 a+b vs b+a 중 큰 쪽이 앞에 와야 전체가 최대.
# 3) 모든 원소가 0이면 "0"을 반환.
#
# ✅ 정답 코드(나의 풀이; 한 줄마다 주석):
def solution(numbers):
    numbers = [str(num) for num in numbers]                # 숫자를 문자열로 변환
    numbers.sort(key=lambda x: x*3, reverse=True)          # 문자열을 3번 반복하여 정렬 기준 생성
                                                           # (숫자 범위가 1000 이하라 최대 3자리 → 3배 반복으로 자리 맞춤 효과)
    return str(int("".join(numbers)))                      # 이어붙인 뒤 int→str 변환 (앞자리 0 제거)

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - `x*3`을 키로 둔 정렬로 문제 조건 충족.
# - join 후 int 변환 → 선행 0을 제거할 수 있어 "0000" → "0" 처리 성공.

# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - 초기에는 단순히 내림차순 정렬만 고려 → `[3, 30, 34]`에서 잘못된 결과.
# - 문자열 반복으로 자리수를 보정하지 않으면 비교가 어긋남.
# - int 변환을 거치지 않으면 `"0000"` 같은 케이스 처리 불가.

# 📚 사용된/필수 개념(최소):
# - 문자열 정렬 비교: `a+b` vs `b+a` 원리
# - 반복 문자열을 활용한 정렬 키
# - join, int 변환으로 예외 처리
# - 시간복잡도: O(N log N · L) (L ≤ 3)

# 🧠 (선택) 다른 효율적인 풀이 또는 알고리즘 제안:
# - Python `functools.cmp_to_key`로 직접 비교 함수 구현 가능:
#   if a+b > b+a → a 먼저.  
# - 이 방식은 반복곱 키 대신 직접 문자열 합성 비교로 의도를 명확히 드러냄.
