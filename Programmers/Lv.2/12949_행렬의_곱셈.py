# 12949_행렬의_곱셈.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - 두 2차원 행렬 arr1과 arr2가 주어짐
# - arr1 × arr2의 **행렬 곱셈 결과**를 반환하는 문제
#   (단, arr1은 n×m, arr2는 m×p 크기)
#
# ✅ 입력:
# - arr1: n x m 행렬
# - arr2: m x p 행렬
#   (1 ≤ n, m, p ≤ 100, 요소는 정수)
#
# ✅ 출력:
# - arr1과 arr2의 곱셈 결과: n x p 행렬
#
# ✅ 예시:
#   입력:
#   arr1 = [[1, 4], [3, 2], [4, 1]]
#   arr2 = [[3, 3], [3, 3]]
#
#   출력:
#   [[15, 15], [15, 15], [15, 15]]
# -----------------------------------------------------

def solution(arr1, arr2):
    answer = []  # 최종 결과를 담을 리스트

    n1 = len(arr1)       # arr1의 행 수
    n2 = len(arr1[0])    # arr1의 열 수 == arr2의 행 수
    n4 = len(arr2[0])    # arr2의 열 수

    # ✅ 결과 행렬은 n1 x n4 크기
    for i in range(n1):
        row = []  # 결과 행렬의 한 행
        for j in range(n4):
            value = 0  # 결과 행렬의 (i, j) 위치 값
            for k in range(n2):
                # 각 항의 곱을 누적: arr1[i][k] * arr2[k][j]
                value += arr1[i][k] * arr2[k][j]
            row.append(value)  # j열 계산 완료 → 행에 추가
        answer.append(row)  # i행 계산 완료 → 결과에 추가

    return answer  # 전체 결과 행렬 반환

# -----------------------------------------------------
# ✅ 사용된 개념 요약:
# - 행렬 곱셈 정의:
#   C[i][j] = sum(arr1[i][k] * arr2[k][j]) for k in range(공통 차원)
# - 3중 for문을 사용하여 각 원소 위치마다 값 계산
# - 결과 행렬의 크기는 arr1의 행 × arr2의 열

# ✅ 나의 오답 및 실수:
# ❌ 초기에 잘못된 중첩 반복 구조로 모든 원소 곱을 실행하여 잘못된 결과 도출
# ✅ GPT가 준 힌트 요약:
# - 결과값의 위치와 계산 방식은 행과 열이 맞닿는 방향의 곱셈 누적으로 구성되어야 함
#
# ✅ 시간 복잡도:
# - O(n × m × p): 최대 100 × 100 × 100 = 1,000,000 → 통과 가능
# -----------------------------------------------------
