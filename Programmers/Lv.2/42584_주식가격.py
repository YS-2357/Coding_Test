# 42584_주식가격.py
# -----------------------------------------------------
# ✅ 제목: 주식가격
# ✅ 문제 설명(요약):
# - 초 단위로 기록된 주식가격 배열 prices가 주어진다.
# - 각 시점 i에서, 그 가격이 **떨어지지 않는 기간(초 단위)**을 계산한다.
# - 끝까지 가격이 떨어지지 않으면 마지막까지의 길이를 반환한다.
#
# ✅ 입력 형식(요지):
# - prices: List[int] (길이 2 이상 100,000 이하)
#
# ✅ 규칙 요약:
# 1) i초 시점 가격은 j(>i) 시점 가격이 더 작아지는 순간까지 유지된다.
# 2) 떨어진다면 (j-i)초 동안 유지.
# 3) 끝까지 떨어지지 않으면 (n-1-i)초 동안 유지.
#
# ✅ 정답 코드(너의 풀이; 한 줄마다 주석):
def solution(prices):
    n = len(prices)                   # 전체 길이
    answer = [0] * n                  # 결과를 담을 배열
    stack = []                        # 아직 떨어지지 않은 인덱스를 담는 스택
    
    for i, price in enumerate(prices):
        while stack and price < prices[stack[-1]]:   # 현재 가격이 더 작으면
            j = stack.pop()                          # 이전 인덱스 j는 떨어진 순간을 만남
            answer[j] = i - j                        # j에서 i까지 유지됨
        stack.append(i)                              # 현재 인덱스를 스택에 넣음 (아직 유지 중)
        # print(answer, stack)                      # 디버깅용
    
    while stack:                                     # 끝까지 떨어지지 않은 경우
        j = stack.pop()                              # 남은 인덱스 j에 대해
        answer[j] = n - 1 - j                        # 끝까지 유지되므로 (마지막까지의 거리)
    return answer                                    # 최종 결과 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 예시 prices=[1,2,3,2,3] → [4,3,1,1,0], 문제 기대값과 일치.
# - 다양한 케이스에서 정상 동작.
#
# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - (가능) 처음엔 단순 이중 for문 O(n²)로 풀 수 있지만 시간 초과.
#   → 수정: 스택으로 각 인덱스를 한 번만 push/pop 하도록 개선해 O(n).
# - (실수 여지) `while stack and price < prices[stack[-1]]:` 조건에서 `<` 사용해야 함.  
#   `<=`로 쓰면 같은 가격에도 떨어졌다고 처리해 오답.
#
# 📚 사용된/필수 개념(최소):
# - 단조 스택(Monotonic Stack): 아직 가격이 떨어지지 않은 시점 인덱스 관리
# - 시간복잡도: O(n) (각 원소 최대 한 번 push+pop)
# - 공간복잡도: O(n) (스택과 결과 배열)
#
# 🧠 (선택) 다른 효율적인 풀이 또는 알고리즘 제안:
# - 큐/덱으로는 비효율적. 스택이 가장 적절.
# - 병렬 처리나 세그먼트 트리로도 풀 수 있지만 문제 크기(N=100,000)에는 O(n) 스택 풀이가 최적.
