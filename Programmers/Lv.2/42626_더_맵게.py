# 42626_더_맵게.py
# -----------------------------------------------------
# ✅ 제목: 더 맵게
# ✅ 문제 설명(요약):
# - 음식들의 스코빌 지수 배열과 기준 K가 주어진다.
# - 모든 음식의 스코빌 지수가 K 이상이 되도록 섞는다.
#   * 섞는 규칙: 가장 안 매운 두 음식 → 새 음식 = (첫 번째) + (두 번째 * 2)
# - 최소 횟수를 반환. 불가능하면 -1.
#
# ✅ 입력 형식(요지):
# - scoville: List[int], 음식 스코빌 지수
# - K: int, 기준값
#
# ✅ 규칙 요약:
# 1) 항상 최소 두 개의 최소값을 꺼내 섞는다.
# 2) 모든 음식의 최솟값이 K 이상일 때 멈춘다.
# 3) 섞는 도중 음식이 1개 남았는데도 K 미만이면 -1 반환.
#
# ✅ 정답 코드(너의 풀이; 한 줄마다 주석):
import heapq

def solution(scoville, K):
    answer = 0
    heapq.heapify(scoville)                # 리스트를 최소 힙으로 변환
    
    while scoville[0] < K:                 # 가장 작은 값이 아직 K 미만이면 반복
        if len(scoville) < 2:              # 더 이상 두 개를 꺼낼 수 없으면 불가능
            return -1
        min1 = heapq.heappop(scoville)     # 가장 작은 값 꺼내기
        min2 = heapq.heappop(scoville)     # 두 번째 작은 값 꺼내기
        heapq.heappush(scoville, min1 + 2 * min2)  # 섞어서 다시 힙에 추가
        answer += 1                        # 섞은 횟수 +1
    return answer                          # 모든 음식이 K 이상이면 횟수 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 예시 [1,2,3,9,10,12], K=7 → 결과 2 (문제 예시와 일치).
# - 다양한 케이스에서 정상 작동.
#
# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - 종료 조건 확인을 반복문 맨 앞에서 실행하도록 유지.
#
# 📚 사용된/필수 개념(최소):
# - 최소 힙(heapq)으로 O(log n) 연산
# - 그리디하게 가장 작은 두 값만 섞으면 최적해 보장
# - 시간복잡도: O(n log n) (각 원소 push/pop 한 번씩)
# - 공간복잡도: O(n)
#
# 🧠 (선택) 다른 효율적인 풀이 또는 알고리즘 제안:
# - 파이썬 heapq는 최소 힙만 지원하므로 현재 방법이 최적.
# - 불필요한 정렬은 쓰지 말고 항상 heapify + heappop/heappush로 처리.
