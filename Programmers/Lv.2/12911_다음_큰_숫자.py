# 12911_다음_큰_숫자.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - 자연수 n보다 큰 자연수 중, 이진수에서 1의 개수가 n과 같은 가장 작은 수를 구한다.

# ✅ 입력:
# - n (1 ≤ n ≤ 1,000,000)

# ✅ 출력:
# - 조건을 만족하는 자연수

# ✅ 예시:
#   입력: 78
#   출력: 83 (78의 이진수는 1001110 → 1의 개수 4, 다음으로 1의 개수 4인 수는 83)
# -----------------------------------------------------

def solution(n):
    # n의 이진수에서 1의 개수를 미리 계산
    ones = bin(n)[2:].count('1')  # bin(n) → '0b1001110' → [2:]로 '0b' 제거 → count('1')
    
    # n보다 큰 수부터 탐색 시작
    answer = n + 1  # 최소 n보다 커야 하므로 n+1로 초기화

    # 조건 만족할 때까지 무한 루프
    while True:
        # 현재 숫자의 이진 표현에서 1의 개수를 계산
        if bin(answer)[2:].count('1') == ones:
            # 1의 개수가 같으면 조건 만족 → 반환
            return answer
        # 조건 불만족 → 다음 숫자로 이동
        answer += 1

# -----------------------------------------------------
# ✅ 사용된 개념 요약:
# - bin(x): 정수를 이진 문자열로 변환 (예: bin(5) → '0b101')
# - 문자열 슬라이싱 [2:]: '0b' 제거
# - count('1'): 이진수 문자열에서 1의 개수 세기
# - while 루프: 조건 만족할 때까지 반복
# ✅ 시간 복잡도:
# - 최악의 경우 n에서 다음 조건 만족 숫자까지 k번 반복
# - 각 반복에서 bin 변환과 count('1')는 O(log n)
# - 전체는 O(k log n) (k는 다음 숫자까지 거리, 보통 크지 않음)
# -----------------------------------------------------
