# 12953_N개의_최소공배수.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - 배열 arr의 모든 원소에 대해 최소공배수(LCM)를 구하여 반환.
# - LCM은 a*b // GCD(a, b)로 계산 가능.

# ✅ 입력:
# - arr: 정수 배열 (길이 1 이상, 원소는 100 이하 자연수)

# ✅ 출력:
# - 모든 원소의 최소공배수 (정수)

# ✅ 예시:
#   입력: [2, 6, 8, 14]
#   출력: 168
# -----------------------------------------------------

def solution(arr):
    
    # ✅ 최대공약수(GCD) 구하는 함수 (유클리드 호제법)
    def gcd(a, b):
        while b:              # b가 0이 될 때까지 반복
            a, b = b, a % b   # a에 b 대입, b에 a%b 대입
        return a              # b가 0이면 a가 GCD

    # ✅ 최소공배수(LCM) 구하는 함수
    def lcm(a, b):
        return a * b // gcd(a, b)  # LCM = a*b // GCD(a, b) → 정수 나눗셈(//) 사용

    # ✅ 배열에서 마지막 값 꺼내 초기값으로 설정
    a = arr.pop()

    # ✅ 남은 값들과 차례대로 LCM 계산
    while arr:
        b = arr.pop()         # 배열에서 하나 꺼냄
        a = lcm(a, b)         # 현재까지의 LCM과 새 값의 LCM 계산

    return a  # 모든 값을 처리한 후 a가 전체 최소공배수

# -----------------------------------------------------
# ✅ 사용된 개념 요약:
# - **유클리드 호제법**:
#   - GCD(a, b) = GCD(b, a % b)
# - **LCM**:
#   - a와 b의 최소공배수는 (a * b) // GCD(a, b)
# - **반복 구조**:
#   - 리스트에서 pop()으로 값 꺼내면서 누적 LCM 계산
# ✅ 시간 복잡도:
# - 각 GCD 계산: O(log(min(a, b)))
# - 배열 길이 n이면 O(n log M) (M은 숫자 크기)
# ✅ 주의:
# - LCM 계산에서 **정수 나눗셈(//)** 사용해야 float 문제 없음
# -----------------------------------------------------
