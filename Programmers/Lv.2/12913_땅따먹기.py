# 12913_땅따먹기.py
# -----------------------------------------------------
# ✅ 제목: 땅따먹기
# ✅ 문제 설명(요약):
# - n×4 배열 land에서 한 행당 한 칸씩 선택해 합을 최대화한다.
# - 단, **연속된 두 행에서 같은 열을 선택할 수 없다.**
#
# ✅ 입력 형식(요지):
# - land: List[List[int]] (세로 n, 가로 4)
#
# ✅ 규칙 요약:
# 1) dp[i][c] = land[i][c] + max(dp[i-1][k]) for k != c
# 2) 초기 dp[0] = land[0]
# 3) 정답 = max(dp[n-1])
#
# ✅ 정답 코드(너의 풀이; 한 줄마다 주석):
def solution(land):
    answer = 0
    n = len(land)                                 # 총 행 수
    dp = [[0] * 4 for _ in range(n)]              # dp[i][j]: i행 j열까지의 최대 합
    dp[0] = land[0]                               # 초기값: 첫 행은 그대로
    
    for i in range(1, n):                         # 1행부터 n-1행까지 순회
        for j in range(4):                        # 각 열 j에 대해
            dp[i][j] = land[i][j] + max(          # 현재 칸 점수 +
                dp[i-1][k] for k in range(4) if k != j  # 바로 위 행에서 같은 열을 제외한 최댓값
            )
            
    return max(dp[n-1])                           # 마지막 행에서의 최대 합이 정답

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 예시/기본 테스트 통과. O(n)으로 효율적.
#
# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - (이전) `return max(dp[n])`로 인덱스 범위를 벗어남 → `dp[n-1]`로 수정.
# - (가능) land가 매우 클 때 2D dp 메모리가 부담 → 1D 롤링 배열로 개선 가능.
#
# 📚 사용된/필수 개념(최소):
# - 동적 계획법(DP) 점화식 설계
# - “같은 열 금지” 제약을 max에서 제외 조건으로 처리
# - 시간복잡도: O(n·4·3) ≈ O(n), 공간복잡도: O(n·4)
#
# 🧠 (선택) 다른 효율적인 풀이 또는 알고리즘 제안:
# - 1D 롤링:
#   prev = land[0][:]
#   for i in range(1,n):
#       cur = [land[i][c] + max(prev[k] for k in range(4) if k!=c) for c in range(4)]
#       prev = cur
#   return max(prev)
