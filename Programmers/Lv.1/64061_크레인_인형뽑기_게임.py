# 📌 1. 파일 제목, 문제 설명, 입력/출력 형식, 규칙 요약
# ------------------------------------------------------------
# 파일명: 64061_크레인_인형뽑기_게임.py
# 플랫폼: 프로그래머스 (Level 1)
# 문제: 64061 크레인 인형뽑기 게임
# 링크: https://school.programmers.co.kr/learn/courses/30/lessons/64061
#
# [문제 설명 요약]
# - N×N 보드(board)에서 moves 배열에 적힌 열 번호(1-based) 순서대로
#   그 열의 "맨 위 인형"을 집어 바구니에 담는 시뮬레이션 문제.
# - 바구니(스택)의 맨 위 두 인형이 같은 번호가 되면 두 인형이 즉시 사라지고,
#   사라진 인형 수(= 점수)는 2씩 증가한다.
# - 최종적으로 사라진 인형의 총 개수를 반환한다.
#
# [입력 형식]
# - board: List[List[int]] (N×N), 0은 빈칸, 양의 정수는 인형 번호.
# - moves: List[int], 각 원소는 뽑을 열 번호(1-based).
#
# [출력 형식]
# - int: 소멸된(사라진) 인형 총 개수.
#
# [규칙 요약]
# - 각 move에 대해 해당 열의 가장 위(행 인덱스가 작은)에서 0이 아닌 값 하나를 집는다.
# - 집은 인형을 바구니(스택)에 넣을 때, 스택 top과 번호가 같으면 둘 다 제거되어 점수 +2.
# - 같은 move 내에서 한 번의 삽입으로 최대 한 번만 터질 수 있다(연쇄 필요 없음).
# - 빈 열(더 이상 0이 아닌 값이 없음)은 건너뛴다.
#
# [권장 알고리즘/자료구조]
# - 바구니: 스택(LIFO) 사용 → top 비교 후 동일하면 pop + 점수 2.
# - 열 탐색: 단순 위→아래 선형 탐색(O(N)) 또는 열별 포인터/스택 전처리로 O(1)화 가능.
#
# [복잡도(현 구현 기준)]
# - 전처리: 없음, 각 move마다 최대 O(N) 탐색
# - 전체: O(N * len(moves))  (N은 보드 한 변)
# - 공간: O(len(moves)) (바구니) + 입력 보드
# ------------------------------------------------------------


# 📌 2. 정답 코드 (나의 원본 풀이, 절대 수정 금지)
def solution(board, moves):
    answer = 0  # 소멸된 인형의 총 개수를 기록
    n, m = len(board), len(board[0])  # 보드 크기 (행, 열) → m은 실제 사용되지 않음
    basket = []  # 바구니 역할을 할 스택

    for move in moves:  # 각 이동(move)을 순서대로 처리
        for i in range(n):  # 해당 열에서 위쪽 행부터 탐색
            doll = board[i][move-1]  # move는 1-based → 내부는 0-based로 변환
            if doll != 0:  # 빈칸이 아니면 인형이 있다는 뜻
                if basket and basket[-1] == doll:  # 바구니가 비어있지 않고 top이 동일한 인형이면
                    basket.pop()  # top 제거
                    answer += 2  # 인형 두 개 소멸 → 점수 +2
                    board[i][move-1] = 0  # 집은 칸은 비워줌
                    break  # 이번 move는 처리 끝
                else:  # 바구니 top이 다르거나 비어있다면
                    basket.append(doll)  # 인형을 바구니에 넣음
                    board[i][move-1] = 0  # 집은 칸 비움
                    break  # 이번 move 처리 끝

    return answer  # 최종 소멸된 인형 총 개수 반환


# 📌 3. 첫 시도 결과, 오답 이유 및 실수, 사용한 알고리즘 개념
# ------------------------------------------------------------
# [첫 시도 결과]
# - 예시 입력 기반 정상 동작. 바구니 스택으로 동일 상단 2개 시 소멸(+2) 처리.
# - 시간복잡도: 각 move마다 위→아래 선형 탐색으로 O(N). 일반적으로 N이 크지 않아 통과 가능.
#
# [오답/실수 가능 지점 점검]
# - (정확성) move는 1-based → 내부 인덱스에서 move-1 처리: 반영되어 있음.
# - (정확성) 집은 칸을 0으로 초기화해야 재사용 방지: 반영되어 있음.
# - (정확성) 0(빈칸)은 바구니에 넣지 않음: 조건문으로 반영.
# - (코드 품질) m 변수를 선언했으나 사용하지 않음(경미한 불필요 변수).
# - (성능) 매 move마다 해당 열을 위→아래로 탐색(O(N)): 입력이 큰 경우 비효율적일 수 있음.
#
# [사용한 필수 개념/알고리즘]
# - 시뮬레이션 + 스택(LIFO): 바구니를 리스트 스택으로 관리, top 비교 후 동일 시 pop.
# - 단순 선형 탐색: 각 열에서 맨 위 인형을 찾을 때 위→아래로 스캔.
# - 인덱스 변환: 1-based 열 번호를 0-based로 변환.
# ------------------------------------------------------------


# 📌 4. (선택) 다른 효율적인 풀이 또는 알고리즘 제안  [코드 제공 금지, 개념/흐름만]
# ------------------------------------------------------------
# [열 포인터 방식]
# - 각 열마다 "다음 뽑힐 행 인덱스(top_idx[col]])"를 미리 계산해두고, move 때 O(1)에 접근.
# - 흐름:
#   1) 초기화 시, 각 열에 대해 위에서부터 첫 번째 0이 아닌 행 인덱스를 기록.
#   2) move 수행 시 해당 열의 top_idx[col]가 가리키는 인형을 즉시 집어 처리.
#   3) 인형을 집었다면 top_idx[col] += 1 로 다음 후보로 이동(0을 건너뛰도록 초기 단계에서 스킵).
#
# [열 스택(또는 데크) 전처리]
# - 각 열을 "위에서 아래 순"으로 담은 스택/데크로 구성해두고, move마다 pop으로 O(1) 획득.
# - 흐름:
#   1) 전처리 단계에서 각 열을 순회하며 0이 아닌 인형만 추출하여 컬렉션에 쌓는다.
#   2) move 수행 시 해당 열 컬렉션에서 pop → 바구니 스택과 비교/소멸 처리.
#
# [장점]
# - 매 move 처리 비용을 O(1)에 가깝게 낮춰 전체를 O(N^2 + len(moves)) 또는 O(len(moves))로 개선.
# - 로직이 바구니 스택과 잘 분리되어 가독성↑, 디버깅 용이.
#
# [엣지/주의]
# - 전처리 시 0은 제외하고 유효 인형만 담아야 함.
# - move가 가리키는 열이 비어있을 수 있으므로 예외 케이스(건너뛰기) 처리 필요.
# ------------------------------------------------------------
