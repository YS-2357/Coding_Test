# 258712_가장_많이_받은_선물.py
# -----------------------------------------------------
# ✅ 제목: 가장 많이 받은 선물
# ✅ 문제 설명(요약):
# - friends: 친구 이름 리스트, gifts: "A B"(A가 B에게 선물 1회) 형식의 기록이 주어진다.
# - 다음 달 각 쌍(A,B)에서 규칙에 따라 누가 선물을 받을지 정하고,
#   각 사람이 다음 달 "받게 될" 선물 개수 중 최댓값을 구한다.
#
# ✅ 입력 형식(요지):
# - friends: List[str] (2 ≤ len(friends) ≤ 50)
# - gifts: List[str] (1 ≤ len(gifts) ≤ 10,000), 각 원소는 "giver receiver"
#
# ✅ 규칙 요약:
# 1) 지난달 A→B 횟수 > B→A 횟수라면, 다음 달 **A가 B에게 선물**(= B가 1개 받음)
# 2) 같다면 "선물 지수"(= 준 수 - 받은 수) 큰 사람이 **상대에게 선물**(= 상대가 1개 받음)
# 3) 그것도 같으면 그 쌍에서는 주고받지 않음
#
# ✅ 입출력 예시(사이트 예시):
# - friends = ["muzi","ryan","frodo","neo"], gifts = [...] → 결과 2.  (다음 달 최댓값)  ← 출처 블로그 요약
#   (자세한 표와 설명은 문제 페이지/해설 블로그에 수록)
#
# ✅ 정답 코드(너의 풀이; 한 줄마다 주석):
def solution(friends, gifts):
    answer = 0                               # 반환값 후보(이 풀이에서는 최댓값 계산에 미사용)
    n = len(friends)                         # 친구 수
    gnt = [[0] * n for _ in range(n)]        # gnt[i][j]: i가 j에게 준 횟수(정방행렬)
    name_to_id = {friend: i for i, friend in enumerate(friends)}  # 이름→인덱스 매핑

    for giventake in gifts:                  # 선물 기록 순회
        give, take = giventake.split(" ")    # "A B"를 공백 하나 기준으로 분리
        g_id, t_id = name_to_id[give], name_to_id[take]  # A,B를 인덱스로 변환
        gnt[g_id][t_id] += 1                 # A가 B에게 준 횟수 1 증가
    # print(gnt)                             # (디버깅용) 전체 카운트 행렬

    g_index = [0] * n                        # 선물 지수(= 준 수 - 받은 수)
    for i in range(n):                       # 각 사람 i에 대해
        for j in range(n):                   # 모든 상대 j를 훑으며
            if gnt[i][j] != 0:               # i가 j에게 준 기록이 있으면
                g_index[i] += gnt[i][j]      #  → '준 수' 누적
            if gnt[j][i] != 0:               # j가 i에게 준 기록이 있으면
                g_index[i] -= gnt[j][i]      #  → '받은 수' 차감
    # print(g_index)                         # (디버깅용) 선물 지수 배열

    next_time = [0] * n                      # 다음 달 "받게 될" 선물 개수 카운트
    for i in range(n):                       # 서로 다른 쌍만 보려면
        for j in range(i+1, n):              # i < j 범위로 순회
            if gnt[i][j] > gnt[j][i]:        # i→j가 더 많으면 (규칙1)
                next_time[i] += 1            #  → (현재 풀이) i에 +1
            elif gnt[i][j] < gnt[j][i]:      # j→i가 더 많으면 (규칙1 반대)
                next_time[j] += 1            #  → j에 +1
            else:                            # 동일(0-0 포함)일 때
                if g_index[i] > g_index[j]:  # i의 선물 지수가 더 크면 (규칙2)
                    next_time[i] += 1        #  → (현재 풀이) i에 +1
                elif g_index[i] < g_index[j]:# j의 선물 지수가 더 크면 (규칙2)
                    next_time[j] += 1        #  → j에 +1
    # print(next_time)                       # (디버깅용) 다음 달 수령 카운트

    return max(next_time)                    # 다음 달 '받게 될' 최댓값 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 한 번에 정답 "미도달" (여러 테스트에서 실패)
#
# 🔧 오답 및 실수(정확성 실패 원인):
# 1) **수령자/증가 방향 반대**:
#    - 규칙1에 따르면 i→j가 더 많으면 "다음 달 i가 B에게 줌"이므로 **수령자는 j**여야 함.
#      현재 코드는 `gnt[i][j] > gnt[j][i]`에서 `next_time[i] += 1`로 **i를 증가**시켜 반대로 셈.
# 2) **동률(0-0 포함) 처리에서 수령자 반대**:
#    - 규칙2는 "선물 지수가 큰 사람이 **상대에게** 준다" → **수령자는 지수가 작은 쪽**.
#      현재 코드는 `g_index[i] > g_index[j]`에 `next_time[i] += 1`로 **지수 큰 i**를 증가시킴.
#    → 두 경우 모두 '누가 받는가'가 거꾸로 되어 결과가 어긋남.
# 3) (비효율) 선물 지수 계산을 이중루프로 `!=0` 체크하며 누적:
#    - 정확성에는 큰 문제 없지만, 행합/열합으로 간결히 계산 가능(성능·가독성 개선 여지).
# 4) (견고성) `" ".split(" ")`:
#    - 공백이 여러 개인 입력에서는 실패 가능. 일반적으로 `split()`이 안전.
#
# 🛠️ 어떻게 고쳤는지(수정 지침 요약; 전체코드 기재 없이 방향만):
# - 규칙1: `gnt[i][j] > gnt[j][i]`이면 **수령자 j**에 `+1`, 반대면 **수령자 i**에 `+1`.
#   (즉, "더 많이 준 사람"이 **주는 쪽**이고, 카운트는 **받는 쪽**에 더한다.)
# - 규칙2(동률): `g_index[i] > g_index[j]`이면 **수령자 j**에 `+1`, 반대면 **수령자 i**에 `+1`.
#   (즉, "지수 큰 사람"이 **주는 쪽**, 카운트는 **상대(작은 지수)**에게 더한다.)
# - 선물 지수: `give[i] = sum(gnt[i])`, `recv[i] = sum(gnt[k][i] for k in range(n))`,
#   `g_index[i] = give[i] - recv[i]`로 계산(불필요한 `!=0` 분기 제거).
# - 파싱: `giver, receiver = rec.split()`로 공백 수에 관계없이 처리.
#
# 📚 사용한/필요한 개념(최소):
# - 2차원 카운팅(정방행렬), 이름→인덱스 매핑
# - "수여 규칙"을 **수령자 관점**으로 카운팅(받는 쪽 배열을 증가)
# - 행합/열합으로 '선물 지수' 계산
