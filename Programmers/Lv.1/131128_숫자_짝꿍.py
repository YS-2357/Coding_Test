# 131128_숫자_짝꿍.py
# -----------------------------------------------------
# ✅ 제목: 숫자 짝꿍
# ✅ 문제 설명(요약):
# - 두 숫자 문자열 X, Y에서 공통으로 등장하는 숫자들(중복 허용)의 멀티셋을 구한다.
# - 그 숫자들로 만들 수 있는 가장 큰 수를 문자열로 반환한다.
# - 공통 숫자가 없으면 "-1", 공통 숫자가 모두 0이면 "0"을 반환한다.
#
# ✅ 입력 형식(요지):
# - X: str (숫자 문자로만 구성)
# - Y: str (숫자 문자로만 구성)
#
# ✅ 규칙 요약:
# 1) 각 자릿수(0~9)에 대해 X와 Y의 빈도를 센다.
# 2) 자릿수 d의 공통 개수는 min(cntX[d], cntY[d]).
# 3) d를 9→0 내림차순으로, 공통 개수만큼 이어 붙인다.
# 4) 결과가 비어있으면 "-1", 결과가 모두 0이면 "0".
#
# ✅ 정답 코드(너의 풀이; 한 줄마다 주석):
def solution(X, Y):
    answer = ''                      # 결과 문자열을 누적할 버퍼(가장 큰 수를 만들기 위해 뒤에 이어 붙임)
    x_dict, y_dict = {}, {}          # 각 문자열의 자릿수 빈도를 저장할 딕셔너리(키: '0'~'9', 값: 개수)
    
    for x in X:                      # X의 각 문자 순회
        x_dict[x] = x_dict.get(x, 0) + 1  # 해당 숫자 빈도를 +1 (없으면 0에서 시작)
    for y in Y:                      # Y의 각 문자 순회
        y_dict[y] = y_dict.get(y, 0) + 1  # 해당 숫자 빈도를 +1 (없으면 0에서 시작)
    
    for i in range(9, -1, -1):       # 9부터 0까지 역순 순회(가장 큰 수를 만들기 위해 내림차순)
        i = str(i)                   # 딕셔너리 키와 비교/접근을 위해 문자열로 변환
        # 양쪽 딕셔너리에 키가 존재하는지 검사(get의 기본값 -1 사용해 "없음" 판별)
        if x_dict.get(i, -1) > -1 and y_dict.get(i, -1) > -1:
            # 만약 현재까지 붙인 숫자가 하나도 없고, 지금 보는 숫자가 '0'뿐이라면
            # 결과가 '000...'이 되지 않도록 즉시 "0" 반환(모두 0이라는 의미)
            if not answer and i == "0":
                return "0"
            # 공통 개수만큼 해당 숫자 i를 이어 붙임(최대값 유지를 위해 내림차순에서 누적)
            answer += i * min(x_dict[i], y_dict[i])

    if not answer:                   # 공통 숫자가 전혀 없었던 경우
        return "-1"                  # 규칙에 따라 "-1" 반환
    
    return answer                    # 그 외에는 누적된 최대 수를 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 한 번에 맞춤. 공통 없음("-1") / 모두 0("0") / 일반 케이스 모두 규칙에 부합.
#
# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - 잠재 포인트 1: "모두 0" 처리에서 '0'을 여러 번 붙이지 않도록 조기 반환 필요
#   → 본 풀이에서 `not answer and i=="0": return "0"`로 정확히 처리.
# - 잠재 포인트 2: 존재하지 않는 키 접근 시 KeyError 위험
#   → `dict.get(key, -1)`로 존재 여부를 먼저 확인하여 방지.
# - 잠재 포인트 3: 정렬/조합을 숫자 비교가 아닌 문자열 정렬로 처리하면 오답 가능
#   → 자릿수별 카운팅 + 내림차순 누적으로 안전하게 구현.
#
# 📚 사용된/필수 개념(최소):
# - 해시맵(딕셔너리) 기반 빈도 카운팅
# - 멀티셋 교집합(min 빈도) 계산
# - 내림차순(9→0) 누적으로 최대 수 구성
# - 조기 판정: 모두 0인 경우 "0" 반환
# - 시간복잡도: O(|X| + |Y| + 10) ≈ O(|X|+|Y|), 공간복잡도: O(1) (자릿수 10개 고정 + 결과 길이)
