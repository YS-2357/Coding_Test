# 118666_성격_유형_검사하기.py
# -----------------------------------------------------
# ✅ 제목: 성격 유형 검사하기
# ✅ 문제 설명(요약):
# - 성향 지표 쌍: RT, CF, JM, AN (각각 앞/뒤 글자 중 하나를 최종 선택).
# - 설문 항목 survey[i]는 두 글자(예: "RT")로, 앞글자=비동의 쪽, 뒷글자=동의 쪽.
# - 선택값 choices[i]는 1~7:
#     1~3 → 앞글자에 점수 3,2,1
#     4   → 중립(점수 0)
#     5~7 → 뒷글자에 점수 1,2,3
# - 모든 문항 반영 후 각 지표쌍에서 더 큰 점수의 글자를 선택(동점이면 앞글자).
# - 선택된 4글자를 이어 최종 문자열을 반환.
#
# ✅ 입력 형식(요지):
# - survey: List[str] (각 원소는 길이 2의 문자열, 예: "RT", "CF")
# - choices: List[int] (각 원소는 1~7의 정수)
#
# ✅ 규칙 요약:
# 1) 점수는 |choice-4| 로 계산(0~3).
# 2) choice<4 → 앞글자에 점수 가산, choice>4 → 뒷글자에 점수 가산.
# 3) 최종 문자열은 "RT", "CF", "JM", "AN" 순서로 각 쌍에서 승자를 이어붙임(동점 시 앞글자).
#
# ✅ 정답 코드(너의 풀이; 한 줄마다 주석):
def solution(survey, choices):
    answer = ''  # 최종 성격 유형 4글자를 이어 붙일 결과 문자열

    hash_map = {        # 각 성향 글자의 누적 점수를 저장할 해시맵(딕셔너리) 초기화
        "R": 0, "T": 0, # RT 지표
        "C": 0, "F": 0, # CF 지표
        "J": 0, "M": 0, # JM 지표
        "A": 0, "N": 0  # AN 지표
    }
    
    # survey와 choices를 동시에 순회하며 점수 누적
    for (type1, type2), choice in zip(survey, choices):  # type1=앞글자(비동의), type2=뒷글자(동의)
        point = choice - 4          # choice와 4의 차이를 통해 방향/세기를 동시에 표현(음수/양수, 절댓값이 점수)
        if point > 0:               # 5~7인 경우: 동의 방향 → 뒷글자(type2)에 점수 부여
            hash_map[type2] += point  # 점수는 |choice-4| = point (여기선 양수)
        elif point < 0:             # 1~3인 경우: 비동의 방향 → 앞글자(type1)에 점수 부여
            hash_map[type1] += -point # point는 음수이므로 부호를 반전하여 가산
        else:                       # choice==4(중립): 점수 0 → 어떤 글자에도 가산 없음
            continue                # 명시적으로 넘어가 로직 가독성 유지
    
    # 각 지표쌍에서 점수가 더 큰 글자를 선택(동점이면 앞글자 선택)
    answer += "R" if hash_map["R"] >= hash_map["T"] else "T"  # RT 비교: 동점 시 "R"
    answer += "C" if hash_map["C"] >= hash_map["F"] else "F"  # CF 비교: 동점 시 "C"
    answer += "J" if hash_map["J"] >= hash_map["M"] else "M"  # JM 비교: 동점 시 "J"
    answer += "A" if hash_map["A"] >= hash_map["N"] else "N"  # AN 비교: 동점 시 "A"
    
    return answer  # 완성된 4글자 성격 유형 문자열 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 한 번에 맞춤(동점 처리 및 가산 규칙 모두 준수).
#
# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - 잠재 실수 포인트: 동점 규칙(앞글자 우선) 누락 가능성 → 본 풀이에서 >= 비교로 정확히 처리.
# - 잠재 실수 포인트: 점수 테이블(1→3, 2→2, 3→1)을 하드코딩하면 실수 위험 → (choice-4) 부호/절댓값으로 간결 처리.
#
# 📚 사용된/필수 개념(최소):
# - 해시맵을 통한 누적 집계(O(1) 접근)
# - 부호 인코딩(point=choice-4)으로 방향/세기 동시 처리
# - 동점 시 앞글자 선택 규칙 반영(>= 비교)
# - 시간복잡도: O(n), 공간복잡도: O(1)
