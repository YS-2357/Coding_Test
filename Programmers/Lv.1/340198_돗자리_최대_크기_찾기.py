# 340198_돗자리_최대_크기_찾기.py
# -----------------------------------------------------
# ✅ 제목: 공원에 가장 큰 정사각형 돗자리 깔기
# ✅ 문제 설명(요약):
# - park: 공원 좌표가 문자열 배열로 주어지고, 빈 칸은 '-1' (사람/장애물은 그 외 값)이다.
# - mats: 가능한 돗자리 한 변 길이 목록이 주어진다.
# - 사람/장애물이 하나도 없는 s×s 정사각형을 찾을 수 있으면 그 s를 사용할 수 있다.
# - 깔 수 있는 s들 중 가장 큰 값을 반환, 없으면 -1.
#
# ✅ 입력 형식(요지):
# - mats: List[int] (돗자리 한 변 길이들)
# - park: List[List[str]] 혹은 List[str] (각 칸 문자열, 빈 칸은 '-1')
#
# ✅ 규칙 요약:
# - s×s 영역 안의 모든 칸이 빈 칸('-1')이어야 한다.
# - 가능한 s 중 가장 큰 s를 반환(없으면 -1). 큰 것부터 탐색하면 최초 발견 시 즉시 반환.
#
# ✅ 입출력 예시(요약):
# - 예) mats = [5, 3, 2], park는 일부만 빈 칸 → 가능한 최대 s = 3 → 3 반환.

def solution(mats, park):
    answer = -1                                   # 기본값: 깔 수 없으면 -1 반환
    N, M = len(park[0]), len(park)                # N: 열(가로 길이), M: 행(세로 길이)
    grid = [[1 if r == '-1' else 0 for r in row]  # 빈 칸('-1')을 1, 그 외(장애물/사람)는 0으로 매핑
            for row in park]
    # print(grid)                                 # (디버그) 0/1 격자 확인
    
    psum = [[0] * (N+1) for _ in range(M+1)]      # 2D prefix sum (누적합) 배열 (패딩 1칸)
    for i in range(M):                             # 행 순회
        for j in range(N):                         # 열 순회
            psum[i+1][j+1] = (grid[i][j]          # 현재 칸
                               + psum[i][j+1]     # 위쪽 누적
                               + psum[i+1][j]     # 왼쪽 누적
                               - psum[i][j])      # 좌상단 중복 제거
    # print(psum)                                 # (디버그) 누적합 확인
            
    mats.sort(reverse=True)                        # 큰 s부터 검사(최대값을 빨리 찾기 위해)
    for mat in mats:                               # 각 돗자리 길이에 대해
        for i in range(M-mat+1):                   # 시작 행: 0..M-mat
            for j in range(N-mat+1):               # 시작 열: 0..N-mat
                # (i,j)~(i+mat-1,j+mat-1) 영역의 빈 칸 개수 s를 O(1)에 계산
                s = (psum[i+mat][j+mat]
                     - psum[i][j+mat]
                     - psum[i+mat][j]
                     + psum[i][j])
                if s == mat * mat:                 # 영역 전체가 빈 칸(= 빈 칸 수가 면적과 같음)
                    return mat                     # 가장 큰 s부터 검사하므로 즉시 반환
    return answer                                  # 끝까지 못 찾으면 -1

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 한 번에 정답 **미도달** (마지막 비교 조건 오류로 실패)
#
# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# 1) 누적합 의미 불일치:
#    - grid에서 빈 칸을 1로 두었으므로, 부분합 s는 "해당 영역의 빈 칸 개수".
#    - 처음엔 s==0을 "장애물 없음"으로 체크했지만 이는 반대 의미였음.
#    → **s == mat*mat**(면적과 동일)일 때가 전부 빈 칸이므로 이 조건으로 수정.
# 2) 최대값 탐색 전략:
#    - **mats를 내림차순 정렬**하여 큰 s부터 검사 → 발견 즉시 반환(조기 종료).
#
# 📚 사용한 개념(필수만):
# - 2차원 누적합(2D prefix sum)으로 사각형 영역 합을 O(1)에 조회
# - 큰 s부터 탐색(그리디한 조기 종료)
