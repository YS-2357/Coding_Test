# 181851_전국_대회_선발_고사.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - 학생들의 등수 정보(rank)와 참석 가능 여부(attendance)가 주어짐
# - 참석 가능한 학생 중에서 등수가 가장 높은 3명을 선발
# - 이들의 번호(index)를 a, b, c라 할 때 다음 식으로 결과 계산:
#   → 10000 × a + 100 × b + c
#
# ✅ 입력:
# - rank: 학생 등수 리스트 (0 ≤ 값 ≤ 100)
# - attendance: 참석 가능 여부 리스트 (True/False)
#   → 두 리스트는 같은 길이이며, 길이 ≥ 3
#
# ✅ 출력:
# - 공식에 따라 계산된 정수 값
#
# ✅ 예시:
#   입력: rank = [3, 7, 2, 5, 4, 6, 1], attendance = [False, True, True, True, True, False, True]
#   출력: 20403
# -----------------------------------------------------

def solution(rank, attendance):
    students = []

    # ✅ 출석 가능한 학생만 (등수, 번호) 튜플로 저장
    for i, (r, att) in enumerate(zip(rank, attendance)):
        if att:
            students.append((r, i))  # 등수 기준 정렬을 위해 (등수, 번호)

    students.sort()  # ✅ 등수(r)가 낮을수록 앞에 오게 정렬됨

    # ✅ 상위 3명 학생 번호 추출
    a, b, c = students[0][1], students[1][1], students[2][1]

    # ✅ 공식 계산
    return 10000 * a + 100 * b + c

# -----------------------------------------------------
# ✅ 사용된 개념 요약:
# - enumerate: 학생 번호(index) 추적
# - zip: 등수와 참석 여부를 함께 순회
# - 정렬 기준: 등수가 낮은 학생이 먼저 오도록 (r 오름차순)
# - 문제에서 요구하는 공식: 10000a + 100b + c

# ✅ 나의 오답 및 실수:
# ❌ 초기에 rank.index() 사용 → 등수가 중복될 경우 첫 인덱스만 반환되어 오류 발생
# ✅ GPT가 준 힌트 요약:
# - enumerate를 활용해 인덱스를 추적하고, (등수, 인덱스)로 정렬해야 정확함

# ✅ 시간 복잡도:
# - 필터링 O(n), 정렬 O(n log n), 추출 O(1) → 총 O(n log n)
# - n ≤ 100이므로 성능 문제 없음
# -----------------------------------------------------
