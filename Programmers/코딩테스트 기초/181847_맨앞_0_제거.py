# 181847_맨앞_0_제거.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - 문자열 n_str이 주어질 때, 맨 앞에 연속해서 등장하는 '0' 문자를 모두 제거한 뒤 남은 문자열을 반환
# - n_str은 "0"만으로 이루어지지 않으므로, 결과가 빈 문자열이 될 일은 없음
#
# ✅ 입력:
# - n_str: 길이 2~10의 숫자 문자열 (예: "001023")
#
# ✅ 출력:
# - 선행 '0'들이 제거된 문자열 (예: "1023")
#
# ✅ 예시:
#   입력: "0010"   → 출력: "10"
#   입력: "854020" → 출력: "854020"
# -----------------------------------------------------

def solution(n_str):
    # ✅ n_str이 '0'으로 시작하는 동안
    while n_str.startswith('0'):
        # 올바른 코드는 replace의 반환값을 다시 n_str에 할당해야 함
        n_str = n_str.replace('0', '', 1)
    return n_str

    # 또는 간단히 lstrip() 사용:
    # return n_str.lstrip('0')

# -----------------------------------------------------
# ✅ 나의 오답 및 실수:
# - 단순히 n_str.replace('0', '', 1)를 호출만 하고 반환값을 할당하지 않아,
#   n_str이 전혀 갱신되지 않고 무한 루프에 빠짐
#
# ✅ GPT가 준 힌트 요약:
# - 문자열 메서드는 불변(immutable)이므로, replace()의 결과를 반드시 변수에 다시 대입할 것
# - 더 간단한 대안으로 n_str.lstrip('0') 또는 str(int(n_str)) 사용 가능
#
# ✅ 사용된 개념 요약:
# - startswith(): 문자열이 특정 접두사로 시작하는지 검사
# - replace(old, new, count): 한 번만(old→new) 치환 후 새로운 문자열 반환
# - 문자열 불변성(immutable) 이해 및 반환값 재할당
#
# ✅ 시간 복잡도:
# - 최악의 경우 n_str 길이만큼 replace 반복 → O(m²) (m ≤ 10)
# - 매우 작은 입력 크기이므로 성능 문제 없음
# -----------------------------------------------------
