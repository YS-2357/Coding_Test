# 181902_문자_개수_세기.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - 문자열 my_string이 주어진다.
# - 알파벳 대문자(A-Z)와 소문자(a-z)의 등장 횟수를 세어 길이 52의 리스트로 반환.
#   - 인덱스 0~25: 대문자 A~Z의 개수
#   - 인덱스 26~51: 소문자 a~z의 개수
#
# ✅ 입력:
# - my_string: 문자열 (길이 1 이상 100 이하)
#
# ✅ 출력:
# - 길이 52의 리스트 (각 알파벳 등장 횟수)
#
# ✅ 예시:
#   입력: "Programmers"
#   출력: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
#          1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0]
# -----------------------------------------------------

def solution(my_string):
    # ✅ 길이 52 리스트 초기화
    # - 0~25: 대문자 A-Z
    # - 26~51: 소문자 a-z
    answer = [0] * 52

    # ✅ 문자열 순회
    for char in my_string:
        # 대문자인 경우
        if 'A' <= char <= 'Z':
            # ord('A')는 65 → 인덱스 계산: ord(char) - 65
            index = ord(char) - ord('A')
            answer[index] += 1
        # 소문자인 경우
        elif 'a' <= char <= 'z':
            # ord('a')는 97 → 인덱스 계산: ord(char) - 97 + 26
            index = ord(char) - ord('a') + 26
            answer[index] += 1

    # ✅ 결과 반환
    return answer

# -----------------------------------------------------
# ✅ 사용된 개념 요약:
# - 아스키 코드 활용:
#   - ord('A') = 65, ord('Z') = 90
#   - ord('a') = 97, ord('z') = 122
# - 리스트 인덱스 매핑:
#   - 대문자: 0~25 → ord(char) - ord('A')
#   - 소문자: 26~51 → ord(char) - ord('a') + 26
#
# ✅ 시간 복잡도:
# - O(n) (n = my_string 길이)
#
# ✅ 더 효율적인 방법:
# - collections.Counter로도 구현 가능하지만, 문제에서 명시한 출력 포맷을 맞추기 위해 리스트 사용
# -----------------------------------------------------
