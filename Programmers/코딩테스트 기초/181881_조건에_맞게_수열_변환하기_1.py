# 181881_조건에_맞게_수열_변환하기_1.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - 정수 배열 arr이 주어진다.
# - 다음 조건에 따라 arr를 반복적으로 변환한다:
#   1. x ≥ 50 and 짝수 → x // 2
#   2. x < 50 and 홀수 → x * 2 + 1
#   3. 그 외 → 그대로 유지
# - 배열이 더 이상 변하지 않을 때까지 이 과정을 반복하며,
#   총 몇 번의 반복이 일어났는지 반환.
#
# ✅ 입력:
# - arr: 정수 리스트 (1 ≤ len(arr) ≤ 1,000)
#
# ✅ 출력:
# - arr가 고정 상태가 되기까지의 반복 횟수
#
# ✅ 예시:
#   입력: [1, 2, 3, 100, 99, 98]
#   출력: 5
# -----------------------------------------------------

def solution(arr):
    answer = 0  # 반복 횟수 초기화
    
    # ✅ 조건에 따라 배열을 변환하는 함수
    def process(arr):
        result = []  # 새로운 배열에 결과 저장
        for x in arr:
            if x % 2 == 0 and x >= 50:       # 조건 1
                result.append(x // 2)
            elif x % 2 == 1 and x < 50:      # 조건 2
                result.append(x * 2 + 1)
            else:                            # 조건 3
                result.append(x)
        return result

    # ✅ 값이 고정될 때까지 반복
    while True:
        after = process(arr)      # 새로 변환한 배열
        if arr == after:          # 변화가 없다면 종료
            return answer
        arr = after               # 다음 반복을 위해 갱신
        answer += 1               # 반복 횟수 증가

# -----------------------------------------------------
# ✅ 나의 오답 및 실수:
# ❌ process(arr) 함수가 원본 arr를 직접 수정해서,
#    arr == after 비교 시 항상 같아져버림 → 무한루프 혹은 즉시 종료
#
# ✅ GPT가 준 힌트 요약:
# - 리스트는 참조 타입이므로, process 내부에서 원본을 직접 수정하면 안 됨
# - 새로운 리스트(result)를 만들어 리턴하면 비교 시 의도한 동작 가능
#
# ✅ 사용된 개념 요약:
# - 조건 분기 (if-elif-else)
# - 리스트 비교 (arr == after)
# - 불변 처리: 리스트를 복사하거나 새로 만들어 비교
#
# ✅ 시간 복잡도:
# - O(n * t) (n = 배열 길이, t = 반복 횟수 ≤ 수렴 시 빠름)
# -----------------------------------------------------
