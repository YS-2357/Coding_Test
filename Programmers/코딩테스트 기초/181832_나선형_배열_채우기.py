# 181832_나선형_배열_채우기.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - 양의 정수 n이 주어질 때, n×n 배열을 시계 방향 나선형으로
#   1부터 n²까지 순서대로 채워 반환합니다.
#
# ✅ 입력:
# - n: 배열 크기 (1 ≤ n)
#
# ✅ 출력:
# - 시계방향 나선형으로 채워진 n×n 2차원 리스트
#
# ✅ 예시 (n=4):
#   [
#     [ 1,  2,  3,  4],
#     [12, 13, 14,  5],
#     [11, 16, 15,  6],
#     [10,  9,  8,  7]
#   ]
# -----------------------------------------------------

def solution(n):
    # 1) 빈 배열 초기화
    answer = [[0] * n for _ in range(n)]
    # 2) 우→하→좌→상 방향 벡터
    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]
    # 3) 시작 위치 및 방향
    x, y, d = 0, 0, 0

    # 4) 1부터 n*n까지 숫자 채우기
    for num in range(1, n * n + 1):
        answer[x][y] = num

        # 5) 다음 위치 계산
        nx = x + dx[d]
        ny = y + dy[d]
        # 6) 이동 불가(범위 벗어나거나 이미 채워짐) 시 방향 전환
        if not (0 <= nx < n and 0 <= ny < n and answer[nx][ny] == 0):
            d = (d + 1) % 4
            nx = x + dx[d]
            ny = y + dy[d]

        # 7) 위치 갱신
        x, y = nx, ny

    return answer

# -----------------------------------------------------
# ✅ 사용된 개념 요약:
# - 2차원 배열 초기화: [[0]*n for _ in range(n)]
# - 방향 벡터(dx, dy)로 우→하→좌→상 순환
# - 다음 칸(nx, ny) 유효성 검사:
#   • 배열 경계(0 ≤ nx,ny < n)
#   • 아직 채워지지 않은 칸(answer[nx][ny]==0)
# - 유효하지 않으면 방향 전환(d = (d+1)%4) 후 재계산
# - 항상 최종(nx,ny)로 x,y를 업데이트하여 이동
#
# ✅ 나의 오답 및 실수:
# - “유효할 때 방향 전환”으로 잘못 구현 → 제대로 나선형이 되지 않음
# - 이동을 항상 수행하지 않고 조건 안에서만 갱신함
#
# ✅ GPT가 준 힌트 요약:
# - 다음 위치가 범위 벗어나거나 이미 채워졌을 때만 방향을 전환
# - 그 후 항상 x, y를 새로운 위치(nx, ny)로 갱신해야 함
#
# ✅ 시간 복잡도:
# - O(n²): n*n 칸만큼 한 번씩 채우므로 n ≤ 50~100 정도면 충분히 빠름
# -----------------------------------------------------
