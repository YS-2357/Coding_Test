# 42883_큰수만들기.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - 숫자로 이루어진 문자열 number에서 k개의 숫자를 제거해
#   남은 숫자의 순서를 유지하면서 가장 큰 수를 만들어야 한다.
# - 숫자의 길이는 최대 1,000,000이므로 O(N²) 방식은 불가능 → O(N) 필요.

# ✅ 입력 형식:
# - number: 문자열 (길이 2 이상 1,000,000 이하)
# - k: 제거할 숫자의 개수 (1 ≤ k < len(number))

# ✅ 출력 형식:
# - 제거 후 만들 수 있는 가장 큰 수를 문자열로 반환

# ✅ 입출력 예제:
#   입력: number = "1924", k = 2
#   출력: "94"

# -----------------------------------------------------

def solution(number, k):
    answer = ''  # 최종 결과 문자열
    stack = []   # 스택: 현재까지 선택된 숫자들을 저장 (가장 큰 수를 유지하기 위한 구조)
    
    for num in number:  # number 문자열을 왼쪽부터 하나씩 탐색
        # 스택이 비어있지 않고, 아직 제거할 숫자가 남아있으며, 
        # 현재 숫자가 스택의 마지막 숫자보다 크면 → pop (작은 숫자 제거)
        while stack and k > 0 and stack[-1] < num:
            stack.pop()  # 작은 값 제거
            k -= 1       # 제거 가능 횟수 감소
        stack.append(num)  # 현재 숫자 push (남은 숫자들로 최대값 구성)

    # 모든 숫자 순회 후, k가 남아있으면 뒤에서 k개 제거
    # (남아있는 제거 횟수는 뒷부분 작은 숫자 제거로 처리)
    if k > 0:
        stack = stack[:-k]

    return ''.join(stack)  # 스택에 남은 숫자들을 합쳐 결과 반환

# -----------------------------------------------------
# ✅ 나의 오답 및 실수:
# ❌ 처음에는 단순히 조합으로 풀려 했으나, 시간 복잡도 문제 발생
# ❌ k를 고려하지 않고 모든 숫자 스캔 후 잘라내면 최적해가 보장되지 않음

# ✅ GPT가 준 힌트 요약:
# - 그리디 + 스택 조합으로 O(N)에 해결 가능
# - 현재 숫자가 스택 top보다 크면 pop (이전 작은 값은 의미 없음)
# - k가 남으면 마지막에서 제거

# ✅ 사용된 개념 요약:
# - **스택**: 마지막 값 비교 및 제거 O(1)
# - **그리디 알고리즘**: 매 순간 가장 큰 수를 유지
# - **시간 복잡도**: O(N) (각 숫자는 최대 한 번 push, 한 번 pop)
# - 조건 분기: while로 스택 top과 현재 숫자 비교, k 감소 조건 포함

# -----------------------------------------------------
