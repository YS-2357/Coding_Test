# 42885_구명보트.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - 사람들의 몸무게 리스트와 보트의 무게 제한(limit)이 주어진다.
# - 한 보트에는 최대 2명만 탈 수 있으며, 두 사람의 합이 limit 이하일 때만 함께 탈 수 있다.
# - 모든 사람을 구출하기 위해 필요한 최소 보트 개수를 구하라.

# ✅ 입력 형식:
# - people: 사람들의 몸무게 리스트 (최대 50,000명)
# - limit: 보트의 무게 제한 (40 ≤ limit ≤ 240)

# ✅ 출력 형식:
# - 필요한 최소 보트 개수 (정수)

# ✅ 입출력 예제:
#   입력: people = [70, 50, 80, 50], limit = 100
#   출력: 3

# -----------------------------------------------------

from collections import deque  # deque는 양쪽에서 pop 가능 (O(1))

def solution(people, limit):
    answer = 0  # 보트 개수를 세기 위한 변수

    # 사람들의 몸무게를 오름차순으로 정렬 후 deque로 변환
    people = deque(sorted(people))

    # deque가 빌 때까지 반복
    while people:
        # 가장 무거운 사람을 pop (오른쪽 끝에서 제거)
        heaviest = people.pop()

        # 남아 있는 사람이 있고, 가장 가벼운 사람과 함께 limit 이하라면
        if people and heaviest + people[0] <= limit:
            people.popleft()  # 가장 가벼운 사람도 함께 태움 (왼쪽 끝 제거)

        # 조건에 따라 한 명 혹은 두 명이 보트를 탐 → 보트 1대 추가
        answer += 1

    return answer  # 최소 보트 개수 반환

# -----------------------------------------------------
# ✅ 나의 오답 및 실수:
# ❌ 처음에는 pop()과 popleft()를 무조건 호출해서 IndexError 발생
# ❌ count 누적 방식으로 잘못 접근 → 보트 2인 제한 조건 미처리

# ✅ GPT가 준 힌트 요약:
# - 보트에는 최대 2명만 태울 수 있으므로 투포인터(양끝 비교) 전략 필요
# - 가장 무거운 사람부터 태우고, 가능하면 가장 가벼운 사람과 짝지음
# - deque를 사용하면 pop과 popleft 모두 O(1) → 효율적

# ✅ 사용된 개념 요약:
# - **정렬**: 가벼운 사람과 무거운 사람을 짝지어 탐색하기 위함 (O(N log N))
# - **그리디 알고리즘**: 매번 가장 무거운 사람부터 처리 (최적의 선택)
# - **deque 자료구조**: 양쪽 끝 pop이 빠름 → 효율성 확보
# - **시간 복잡도**: O(N log N) (정렬) + O(N) (deque 탐색)

# -----------------------------------------------------
