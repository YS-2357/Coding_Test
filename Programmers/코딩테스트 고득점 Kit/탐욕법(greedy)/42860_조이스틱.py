# 42860_조이스틱.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - 조이스틱을 사용해 알파벳 이름을 완성하려 한다.
# - 커서 좌우 이동과 상하(알파벳 변경) 조작이 가능하다.
# - 최소 조작 횟수를 구하라.

# ✅ 입력 형식:
# - name: 조이스틱으로 완성해야 할 이름 (대문자 문자열)

# ✅ 출력 형식:
# - 완성까지 필요한 최소 조작 횟수 (정수)

# ✅ 입출력 예제:
#   입력: "JEROEN"
#   출력: 56

# -----------------------------------------------------

def solution(name):
    answer = 0
    n = len(name)  # 이름의 길이 저장

    start = 'A' * n  # 모두 'A'로 초기화된 문자열과 비교하여 변경 필요 여부 판단

    for a, alphabet in zip(start, name):  # 초기 문자열 'A'*n과 목표 문자열을 병렬 순회
        if a == alphabet:  # 현재 위치 문자가 'A'와 같다면 변경 필요 없음
            answer += 0
        else:
            # 알파벳 변경 최소 조작 횟수 계산
            # 위로 이동: alphabet - 'A'
            # 아래로 이동: 'Z' - alphabet + 1
            answer += min(ord(alphabet) - ord('A'), ord('Z') - ord(alphabet) + 1)

    min_move = n - 1  # 기본 이동 횟수: 오른쪽으로 끝까지 직진

    for i in range(n):
        next_idx = i + 1  # 다음 인덱스부터 연속된 'A' 구간 탐색 시작
        while next_idx < n and name[next_idx] == 'A':
            next_idx += 1  # 연속된 'A' 건너뛰기

        # i까지 이동 후, 왼쪽으로 돌아가서 끝까지 가는 경우
        distance = 2 * i + n - next_idx
        min_move = min(distance, min_move)

        # 반대 방향: 뒤쪽 먼저 가고 돌아오는 경우
        distance = i + 2 * (n - next_idx)
        min_move = min(distance, min_move)

    answer += min_move  # 알파벳 변경 횟수 + 최소 커서 이동 횟수
    return answer  # 최종 최소 조작 횟수 반환

# -----------------------------------------------------
# ✅ 나의 오답 및 실수:
# ❌ 알파벳 변경만 고려하고 커서 이동 최적화를 하지 않으면 큰 오차 발생
# ❌ 커서 이동을 단순 직진으로 처리하면 'A'가 연속되는 구간에서 비효율 발생

# ✅ GPT가 준 힌트 요약:
# - 커서 이동 방향을 조합하여 최소 이동을 계산해야 한다.
# - 'A'가 연속된 구간을 우회하거나 돌아가는 전략이 더 효율적일 수 있다.

# ✅ 사용된 개념 요약:
# - ASCII 코드 활용: `ord()`로 알파벳 조작 비용 계산
# - 커서 이동 거리 최소화: `2*i + n - next_idx` 등 다양한 경로 시뮬레이션
# - 순회하며 조건별 최소값을 갱신하는 그리디 방식

# -----------------------------------------------------
