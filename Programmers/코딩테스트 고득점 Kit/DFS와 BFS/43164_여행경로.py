# 43164_여행경로.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - "ICN" 공항에서 출발하여 모든 티켓을 사용해 여행 경로를 짜려 한다.
# - 경로는 알파벳 순서가 앞서는 경로를 선택해야 한다.
# - 가능한 경로 중 사전순으로 가장 앞서는 경로를 반환하라.

# ✅ 입력 형식:
# - tickets: 항공권 목록 [["ICN", "SFO"], ["ICN", "ATL"], ["SFO", "ATL"], ...]
# - 모든 티켓은 한 번씩만 사용할 수 있음

# ✅ 출력 형식:
# - "ICN"부터 시작하는 여행 경로 리스트 (예: ["ICN", "JFK", "HND", "IAD"])

# ✅ 입출력 예제:
# 예제 1:
#   입력: [["ICN", "JFK"], ["HND", "IAD"], ["JFK", "HND"]]
#   출력: ["ICN", "JFK", "HND", "IAD"]

# -----------------------------------------------------

def solution(tickets):
    tickets.sort()  # 알파벳 순으로 정렬 (사전순 경로를 우선 탐색하기 위함)
    n = len(tickets)
    used = [False] * n  # 각 항공권 사용 여부
    answer = []  # 정답 경로를 담을 리스트

    def dfs(route):
        if len(route) == n + 1:  # 모든 티켓을 다 사용한 경우
            answer.extend(route)  # 경로를 정답 리스트에 복사
            return True  # 경로를 찾았으니 더 이상 탐색 X
        
        for i in range(n):
            # 사용하지 않았고, 현재 경로의 마지막 공항에서 출발하는 티켓이면
            if not used[i] and tickets[i][0] == route[-1]:
                used[i] = True  # 사용 처리
                if dfs(route + [tickets[i][1]]):  # 다음 목적지로 이동
                    return True  # 정답을 찾았으면 바로 return
                used[i] = False  # 백트래킹: 사용 취소
        return False  # 끝까지 못 찾으면 False 반환

    dfs(['ICN'])  # 시작은 항상 "ICN"
    return answer

# -----------------------------------------------------
# ✅ 나의 오답 및 실수:
# ❌ 처음에는 모든 경로를 저장하고 `min(answer)`로 처리해서 비효율 발생
# ❌ 조건 만족하는 경로를 찾고도 탐색을 계속함 → 불필요한 시간 낭비

# ✅ GPT가 준 힌트 요약:
# - `tickets.sort()` 후 DFS로 탐색하되, 경로를 하나 찾으면 바로 종료
# - 사전순 경로를 첫 번째로 찾기 위해 미리 정렬

# ✅ 사용된 개념 요약:
# - DFS(깊이 우선 탐색): 경로 탐색
# - 백트래킹: 경로가 틀리면 이전 상태로 되돌리기
# - 사전순 정렬 + 즉시 반환: 불필요한 경로 탐색 제거 → 성능 개선

# -----------------------------------------------------
