# 1844_게임맵최단거리.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - (0, 0)에서 시작하여 상대 팀 진영 (n-1, m-1)까지 도달하는 **최단 거리**를 구하는 문제입니다.
# - 갈 수 있는 길은 `maps[i][j] == 1`인 경우뿐이며, 상하좌우로만 이동 가능합니다.

# ✅ 입력 형식:
# - maps: 2차원 리스트, maps[i][j]는 0 또는 1 (1 ≤ n, m ≤ 100)
#   - 1은 이동 가능, 0은 벽
# - 출발점: (0, 0), 도착점: (n-1, m-1)

# ✅ 출력 형식:
# - 도착점까지의 최소 이동 칸 수 (경로가 없다면 -1)

# ✅ 입출력 예제:
# 예제 1:
#   입력: [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,1],[0,0,0,0,1]]
#   출력: 11
# 예제 2:
#   입력: [[1,0,1],[1,0,1],[1,1,1]]
#   출력: 5
# -----------------------------------------------------

from collections import deque

def solution(maps):
    n = len(maps)            # 행의 개수
    m = len(maps[0])         # 열의 개수
    visited = [[False]*m for _ in range(n)]  # 방문 여부 체크
    dx = [0, 0, 1, -1]        # 방향 벡터 (상하좌우)
    dy = [1, -1, 0, 0]
    
    queue = deque()
    queue.append((0, 0))      # 시작 위치 삽입
    visited[0][0] = True      # 시작 위치 방문 처리

    while queue:
        x, y = queue.popleft()
        for i in range(4):    # 네 방향에 대해 검사
            nx = x + dx[i]
            ny = y + dy[i]
            # 범위 내이며, 이동 가능하고, 아직 방문하지 않은 경우
            if 0 <= nx < n and 0 <= ny < m and maps[nx][ny] == 1 and not visited[nx][ny]:
                visited[nx][ny] = True
                maps[nx][ny] = maps[x][y] + 1  # 이전 거리 + 1 로 누적
                queue.append((nx, ny))

    return maps[n-1][m-1] if maps[n-1][m-1] > 1 else -1  # 도착 가능 여부 판단

# -----------------------------------------------------
# ✅ 나의 오답 및 실수:
# ❌ DFS 방식으로 구현하여 최단거리를 보장하지 못함
# ❌ x, y 위치를 dx, dy로 갱신하면서 원래 좌표(n, m)를 덮어씀
# ❌ count 변수를 함수 내부에서 누적하려다 전역 범위 혼란 발생

# ✅ GPT가 준 힌트 요약:
# - 최단 거리 문제는 DFS가 아닌 BFS로 해결해야 함
# - maps[x][y] = 이전 거리 + 1 방식으로 누적
# - 방문 배열과 큐를 함께 관리

# ✅ 사용된 개념 요약:
# - BFS (너비 우선 탐색): 최단 거리 탐색에 최적
# - 방향 벡터 (dx/dy): 상하좌우 이동
# - visited 배열: 중복 방문 방지
# - maps 자체를 거리 저장 배열로 재사용

# -----------------------------------------------------
