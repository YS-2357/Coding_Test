# 프로그래머스 1843번: 사칙연산 (구간 DP 문제)
# -----------------------------------------------------
# ✅ 문제 설명:
# - 숫자와 연산자('+', '-')가 번갈아 있는 리스트가 주어진다.
# - 괄호를 적절히 쳐서 결과를 최대화해야 한다.
#
# ✅ 입력 형식:
# - arr: 문자열로 이루어진 리스트, 길이는 홀수.
# - 숫자와 연산자가 번갈아가며 등장한다.
#
# ✅ 출력 형식:
# - 만들 수 있는 수식 중 최댓값을 반환한다.
#
# ✅ 입출력 예제:
# 🔹 예제 입력:
#   ["1", "-", "3", "+", "5", "-", "8"]
# 🔹 예제 출력:
#   1
#
# ✅ 알고리즘 개요:
# - 구간 DP를 사용하여 i~j까지의 최댓값과 최솟값을 모두 기록.
# - '+' 연산은 둘 다 더하면 되고, '-' 연산은 최댓값-최솟값 조합을 고려해야 함.
# - 모든 가능한 구간을 탐색하면서 최댓값을 업데이트한다.
# -----------------------------------------------------

def solution(arr):
    # 숫자와 연산자를 각각 분리
    nums = [int(x) for x in arr[::2]]  # 짝수 인덱스: 숫자
    ops = [x for x in arr[1::2]]        # 홀수 인덱스: 연산자

    N = len(nums)  # 숫자 개수

    # ✅ DP 배열 선언
    # dp_max[i][j]: i~j 구간에서 가능한 최대값
    # dp_min[i][j]: i~j 구간에서 가능한 최소값
    dp_max = [[float('-inf')] * N for _ in range(N)]
    dp_min = [[float('inf')] * N for _ in range(N)]

    # ✅ 1칸짜리 구간(자기 자신) 초기화
    for i in range(N):
        dp_max[i][i] = nums[i]
        dp_min[i][i] = nums[i]

    # ✅ 구간의 길이를 늘려가며 탐색
    for length in range(1, N):  # 구간 길이 1, 2, ..., N-1
        for i in range(N - length):
            j = i + length  # 끝점은 시작점 + 구간 길이

            # i~j 구간을 k로 나눠서 양쪽을 나누어 계산
            for k in range(i, j):
                if ops[k] == '+':
                    # '+' 연산일 경우: 최대+최대, 최소+최소
                    dp_max[i][j] = max(dp_max[i][j], dp_max[i][k] + dp_max[k+1][j])
                    dp_min[i][j] = min(dp_min[i][j], dp_min[i][k] + dp_min[k+1][j])
                elif ops[k] == '-':
                    # '-' 연산일 경우:
                    # 최대-최소가 최대가 되고, 최소-최대가 최소가 된다
                    dp_max[i][j] = max(dp_max[i][j], dp_max[i][k] - dp_min[k+1][j])
                    dp_min[i][j] = min(dp_min[i][j], dp_min[i][k] - dp_max[k+1][j])

    # ✅ 최종 답은 0~N-1 전체 구간의 최대값
    return dp_max[0][N-1]

# -----------------------------------------------------
# ✅ 2단계(내가 틀렸던 점) 요약:
# 1️⃣ i==j 구간(한 칸짜리 구간) 초기화가 빠졌었다.
#     - 해결: for문을 이용해 dp_max[i][i], dp_min[i][i]를 nums[i]로 초기화.
#
# 2️⃣ DP 순회 순서를 잘못 잡았었다.
#     - 해결: 구간 길이(length) 기준으로 작은 구간부터 점점 넓히면서 DP를 채움.
#
# 3️⃣ dp_max, dp_min 초기값 설정을 -1, 1001로 했었음.
#     - 해결: float('-inf') / float('inf') 로 안전하고 정확하게 초기화.
#
# ✅ 수정 후 제출하면 정답입니다! 🚀
# -----------------------------------------------------
