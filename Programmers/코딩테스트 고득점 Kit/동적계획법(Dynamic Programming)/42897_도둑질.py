# 42897_도둑질.py
# -----------------------------------------------------
# 해석:
# - 집이 원형으로 바가된 구조의 매 개 행에 돈이 있다.
# - 이중 이어진 두 개의 집을 터르면 결과가 안 된다.
# - 첫 번째 집과 마지막 집도 이어진 구조로 고려해야 한다.
#
# 필요 작업:
# - 첫 집을 터르고 마지막은 터르지 않고 계산 (case 1)
# - 첫 집을 터르지 않고 마지막 개지도 터르기 (case 2)
# - 두 경우의 결과에서 최대값을 고르기
#
# 값 방식:
# - 여러 개의 DP에서, 다양한 구간을 고르어 버티고 최근값 배열을 작성.
# -----------------------------------------------------

def solution(money):
    N = len(money)  # 집 개수

    # case1: 첫 집을 터르고, 마지막은 터르지 않기
    dp1 = [0] * N
    dp1[0] = money[0]  # 첫 집을 터보기
    dp1[1] = max(money[0], money[1])  # 첫이나 그 다음 집 중 최대
    for i in range(2, N-1):  # N-1개까지, 마지막 집 제외
        dp1[i] = max(dp1[i-1], dp1[i-2] + money[i])

    # case2: 첫 집을 터르지 않고, 마지막은 터르도 가능
    dp2 = [0] * N
    dp2[0] = 0  # 첫 집을 터르지 않으므로 0
    dp2[1] = money[1]  # 첫이 아닌 다음 집에서 결정
    for i in range(2, N):  # 마지막지까지
        dp2[i] = max(dp2[i-1], dp2[i-2] + money[i])

    # 두 경우의 최대값을 비교해 최종 결과 계산
    return max(dp1[N-2], dp2[N-1])

# -----------------------------------------------------
# 특징:
# - 해당 무엇이 오류였는가?
#   1. 원형 구조를 고려하지 않고 일반 DP만 사용
#   2. dp[i][0]/[1] 구조의 분명함 부족
#
# - 해결:
#   - 첫집 터르는 경우, 터르지 않는 경우로 구분 합니다.
#   - 두 경우의 DP와 마지막 결과를 비교해 결과 하고 반환합니다.
# -----------------------------------------------------
