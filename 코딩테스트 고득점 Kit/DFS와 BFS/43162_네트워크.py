# 43162_네트워크.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - n개의 컴퓨터와 연결 정보가 주어졌을 때,
#   총 네트워크(서로 연결된 그룹)의 개수를 구하는 문제입니다.

# ✅ 입력 형식:
# - n: 컴퓨터 수 (1 ≤ n ≤ 200)
# - computers: n x n 2차원 배열, computers[i][j] = 1이면 i와 j가 연결됨

# ✅ 출력 형식:
# - 총 네트워크 개수 (정수)

# ✅ 입출력 예제:
# 예제 1:
#   입력: n = 3, computers = [[1,1,0],[1,1,0],[0,0,1]]
#   출력: 2
# 예제 2:
#   입력: n = 3, computers = [[1,1,0],[1,1,1],[0,1,1]]
#   출력: 1
# -----------------------------------------------------

def solution(n, computers):
    answer = 0
    visited = [False] * n  # 각 컴퓨터 방문 여부

    def dfs(start):  # DFS 함수 정의
        visited[start] = True
        for idx, neighbor in enumerate(computers[start]):
            if not visited[idx] and neighbor == 1:  # 연결되어 있고 아직 방문하지 않았다면
                dfs(idx)  # 재귀적으로 방문

    for i in range(n):  # 모든 컴퓨터를 순회
        if not visited[i]:  # 아직 방문하지 않은 컴퓨터라면
            dfs(i)  # DFS로 연결된 모든 컴퓨터 방문
            answer += 1  # 하나의 네트워크 발견

    return answer

# -----------------------------------------------------
# ✅ 나의 오답 및 실수:
# ❌ dfs 함수 내부에서 visited 오타 (vistied) 발생
# ❌ 네트워크 개수 증가 시점을 빠뜨림
# ❌ 외부 반복문 없이 dfs만 호출해 전체 순회를 놓침

# ✅ GPT가 준 힌트 요약:
# - 방문하지 않은 노드를 시작점으로 DFS 시작
# - 각 DFS 호출마다 하나의 네트워크 완성
# - 연결 조건: computers[i][j] == 1 and not visited[j]

# ✅ 사용된 개념 요약:
# - DFS: 그래프 탐색을 통한 연결 요소 탐색
# - visited 배열: 무한 루프 방지 및 중복 처리
# - 연결 요소 개수 세기: DFS를 시작할 때마다 count += 1

# -----------------------------------------------------
