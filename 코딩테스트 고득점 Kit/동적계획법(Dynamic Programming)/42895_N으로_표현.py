# 42895_N으로_표현.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - 숫자 N이 주어질 때, 숫자 N을 최대 8번까지 사용하여 목표 숫자 number를 만들 수 있는지 확인한다.
# - 사칙연산(+, -, *, /)과 숫자 이어붙이기(예: 5 → 55, 555 등)가 가능하다.
# - N을 사용한 횟수 중 가장 적은 경우를 반환하고, 불가능하면 -1을 반환한다.
#
# ✅ 입력 형식:
# - N: 1 이상 9 이하의 자연수
# - number: 1 이상 32,000 이하의 자연수
#
# ✅ 출력 형식:
# - 최소 횟수를 반환 (최대 8번 사용 가능). 만들 수 없다면 -1 반환
# -----------------------------------------------------

from itertools import product  # 두 집합의 모든 조합을 계산하기 위해 사용

def solution(N, number):
    # ✅ N과 number가 같으면 최소 사용 횟수는 1
    if N == number:
        return 1

    # ✅ S[i]: N을 i번 사용해서 만들 수 있는 수들의 집합
    S = [set() for _ in range(9)]
    S[1].add(N)  # N을 1번 사용해서 만들 수 있는 값은 N 하나

    for i in range(2, 9):  # N을 최대 8번까지 사용할 수 있음
        # ✅ 숫자를 이어붙인 값도 포함 (예: 5, 55, 555)
        S[i].add(int(str(N) * i))

        # ✅ i를 j + (i-j)로 분할하여 사칙연산 조합 수행
        for j in range(1, i):
            for x, y in product(S[j], S[i - j]):
                S[i].update({x + y, x - y, x * y})
                if y != 0:
                    S[i].add(x // y)  # 정수 나눗셈

        # ✅ 목표 수를 만들 수 있다면 사용 횟수 반환
        if number in S[i]:
            return i

    return -1  # 8번 이내로 만들 수 없다면 -1 반환

# -----------------------------------------------------
# ✅ 주요 구현 전략:
# - 동적 계획법(DP) + 집합(set) 사용 → 중복 제거 및 빠른 탐색
# - 반복문 내에서 이전 단계의 모든 조합을 활용하여 가능한 수 계산
# - 사칙연산 결과와 이어붙인 숫자를 모두 고려
#
# ✅ 2단계에서의 실수 및 수정:
# 1️⃣ set 대신 list 사용 → 중복 처리 어려움 → ✅ 수정: set으로 변경
# 2️⃣ 나눗셈 연산 시 y==0 예외처리 없음 → ✅ 수정: y != 0 조건 추가
# 3️⃣ 숫자 이어붙이기 누락 → ✅ 수정: int(str(N) * i) 추가
# -----------------------------------------------------
# ✅ 프로그래머스 제출용. 모든 조건 충족. 정답 처리 가능.
# -----------------------------------------------------
