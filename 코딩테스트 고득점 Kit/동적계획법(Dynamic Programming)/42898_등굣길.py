# 42898_등굣길.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - m x n 크기의 격자에서 (1,1) → (m,n)까지 이동할 때, 이동 가능한 서로 다른 경로의 개수를 구하는 문제.
# - 오른쪽 또는 아래쪽으로만 이동할 수 있으며, 물에 잠긴 지역(puddles)은 지날 수 없다.

# ✅ 입력 형식:
# - m: 가로 칸 수 (열) (1 ≤ m ≤ 100)
# - n: 세로 칸 수 (행) (1 ≤ n ≤ 100)
# - puddles: 물에 잠긴 지역 좌표 리스트

# ✅ 출력 형식:
# - 이동 가능한 경로 수를 1,000,000,007로 나눈 나머지를 반환한다.
# -----------------------------------------------------

def solution(m, n, puddles):
    MOD = 1_000_000_007  # ✅ 결과를 나눌 상수

    # ✅ DP 테이블 생성 (n행 m열, 모두 0으로 초기화)
    DP = [[0] * m for _ in range(n)]
    
    # ✅ 웅덩이 좌표를 (가로-1, 세로-1) 기준으로 저장
    puddles_set = set((x-1, y-1) for x, y in puddles)
    
    # ✅ 첫 번째 행(0행) 초기화
    for col in range(m):
        if (col, 0) in puddles_set:
            break
        DP[0][col] = 1
        
    # ✅ 첫 번째 열(0열) 초기화
    for row in range(n):
        if (0, row) in puddles_set:
            break
        DP[row][0] = 1
        
    # ✅ DP 테이블 채우기
    for row in range(1, n):
        for col in range(1, m):
            if (col, row) in puddles_set:
                DP[row][col] = 0  # ✅ 웅덩이는 경로 없음
            else:
                DP[row][col] = (DP[row-1][col] + DP[row][col-1]) % MOD  # ✅ 위+왼쪽 경로 합산

    # ✅ 최종 결과 반환
    return DP[n-1][m-1]

# -----------------------------------------------------
# ✅ 주요 수정 사항:
# - puddles 좌표를 (가로, 세로) 기준으로 저장한 후 비교 시 (col, row) 순서로 비교함
# - DP 테이블은 [row][col] 순서로 접근
# - 매 이동 경로 계산 시 1,000,000,007로 모듈러 연산 적용
# - 입력 변수 m (열) / n (행) 정확히 구분하여 사용

# ✅ 주의했던 포인트:
# - 초기화 순서: 열 먼저, 행 나중
# - puddles 좌표 변환: (x-1, y-1) 적용
# - 웅덩이 지나갈 수 없음 (경로 수 0으로 처리)
# - DP 접근 시 항상 인덱스 범위(n, m) 주의

# ✅ 프로그래머스 모든 테스트케이스 통과 가능
# ✅ 백준 제출 또는 GitHub 업로드용 최종 정답 코드
# -----------------------------------------------------
