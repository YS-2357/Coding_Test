# 20055_컨베이어벨트_위의_로봇.py
# -----------------------------------------------------
# ✅ 문제 설명:
# - 컨베이어 벨트는 길이 2N으로 구성되어 있으며, 각 칸마다 내구도가 있다.
# - 매 단계마다 다음 순서를 따른다:
#   1) 벨트가 한 칸 회전 (로봇도 함께 회전)
#   2) 로봇을 한 칸 이동 (앞칸 내구도가 1 이상 & 앞칸에 로봇이 없으면 이동하며 내구도 -1)
#   3) 1번 칸에 내구도가 1 이상이면 로봇을 올림 (올린 후 내구도 -1)
#   4) 내구도가 0인 칸의 수가 K 이상이면 종료
# - 종료 시점의 단계(회전 횟수)를 출력한다.
#
# ✅ 입력 형식:
# - 첫 줄: N, K (벨트 절반 길이, 내구도 0 개수 기준)
# - 두 번째 줄: 2N개의 숫자 (벨트 각 칸의 내구도)
#
# ✅ 출력 형식:
# - 종료 시점의 단계 수를 출력
#
# ✅ 예제 입력:
#   3 2
#   1 2 1 2 1 2
# ✅ 예제 출력:
#   2
# -----------------------------------------------------

from collections import deque

# ✅ 입력 처리
N, K = map(int, input().split())  # N: 벨트 절반, K: 내구도 0의 개수 기준
belt = deque(map(int, input().split()))  # 벨트 내구도 정보 (2N칸)
robots = deque([False] * N)  # 로봇 상태를 표시하는 N칸 (올리는 위치부터 내리는 위치까지만 관리)

step = 0  # 단계 수

while True:
    step += 1  # ✅ 단계 수 증가

    # 1단계: 벨트 + 로봇 한 칸 회전
    belt.rotate(1)
    robots.rotate(1)
    robots[-1] = False  # 내리는 위치에 로봇이 있으면 무조건 내림

    # 2단계: 로봇 이동 (뒤에서부터 체크해야 앞 로봇에 영향 안 줌)
    for i in range(N - 2, -1, -1):
        if robots[i] and not robots[i + 1] and belt[i + 1] > 0:
            robots[i] = False
            robots[i + 1] = True
            belt[i + 1] -= 1
    robots[-1] = False  # 내리는 위치는 항상 비워야 함

    # 3단계: 로봇 올리기
    if belt[0] > 0:
        robots[0] = True
        belt[0] -= 1

    # 4단계: 내구도 0인 칸 수 체크
    if belt.count(0) >= K:
        print(step)
        break

# -----------------------------------------------------
# ✅ 설명 요약:
# - deque 자료구조를 사용해 회전을 효율적으로 구현
# - 로봇 위치는 벨트의 앞 절반만 관리 (N칸)
# - 매 단계마다 벨트 회전 → 로봇 이동 → 로봇 올리기 → 내구도 확인 순으로 시뮬레이션
#
# ✅ 주의한 점 (2단계 참고):
# 1. 벨트와 로봇을 따로 관리 (deque 2개)
# 2. 로봇 이동은 뒤에서부터 처리하여 순서 유지
# 3. 내리는 위치의 로봇은 항상 즉시 내림
# 4. 내구도 0인 칸 수가 K 이상이면 바로 종료
#
# ✅ 백준 제출 가능 코드. 정답 판정 기준 만족.
# -----------------------------------------------------
