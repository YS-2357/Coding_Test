# 3634_Minimum Removals to Balance Array.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3634. Minimum Removals to Balance Array
# 🏷️ 유형: 정렬 / 투 포인터(슬라이딩 윈도우)
#
# ✅ 문제 설명(요약):
#   - 정수 배열 nums와 정수 k가 주어진다.
#   - 어떤 부분배열이 “균형(balanced)”이 되려면,
#     부분배열의 최댓값 ≤ 최솟값 * k 를 만족해야 한다.
#   - 배열에서 일부 원소를 제거하여 이 조건을 만족하는 부분배열을 만들 때,
#     제거해야 하는 최소 원소 개수를 구한다.
#
# ✅ 입력 형식(요지):
#   - nums: List[int]
#   - k: int
#
# ✅ 규칙 요약:
#   - 제거 후 남는 원소들은 연속일 필요는 없지만,
#     정렬된 상태에서 하나의 구간(left..right-1)으로 생각할 수 있다.
#   - 남기는 원소 개수를 최대화하면 제거 개수는 최소가 된다.
#
# 🧠 핵심 불변식(Invariant):
#   - nums를 정렬하면, 조건은 nums[right] ≤ nums[left] * k 형태로 단순화된다.
#   - left를 고정했을 때 조건을 만족하는 최대 right를 늘려가며,
#     (right - left)는 “유효한 구간의 길이”를 의미한다.
#   - 제거 개수 = 전체 길이 n - (유효 구간 길이).
#   - 모든 left에 대해 이를 계산해 최소 제거 개수를 갱신한다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                                     # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def minRemoval(self, nums: List[int], k: int) -> int:           # 최소 제거 개수를 반환하는 함수
        n = len(nums)                                               # 배열 길이를 저장
        nums.sort()                                                 # 조건 판단을 쉽게 하기 위해 배열을 오름차순 정렬

        ans = n                                                     # 최악의 경우(전부 제거)를 초기값으로 설정
        right = 0                                                   # 투 포인터의 오른쪽 포인터 초기화

        for left in range(n):                                       # 왼쪽 포인터를 0부터 n-1까지 이동
            while right < n and nums[right] <= nums[left] * k:     # 균형 조건을 만족하는 동안 right를 확장
                right += 1                                          # 조건을 만족하므로 오른쪽 포인터 증가
            ans = min(ans, n - (right - left))                     # 현재 구간 길이로 제거 개수 최소값 갱신
        
        return ans                                                  # 최소 제거 개수를 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: 정렬 후 투 포인터로 최대 유효 구간 길이 탐색.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(n log n)  (정렬 비용) + O(n) (투 포인터)
#   - 공간: O(1)        (정렬 외 추가 공간 없음)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 이 문제는 정렬 기반 투 포인터가 사실상 최적이며,
#     이분 탐색으로 right를 찾는 방식도 가능하지만 전체 복잡도는 유사하다(개념만).
