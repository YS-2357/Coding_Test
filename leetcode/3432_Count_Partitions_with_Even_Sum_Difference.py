# 3432_Count_Partitions_with_Even_Sum_Difference.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3432. Count Partitions with Even Sum Difference
# -----------------------------------------------------
# ✅ 문제 설명(요약):
#   - 정수 배열 nums가 주어졌을 때, 인덱스 i를 기준으로 배열을 왼쪽/오른쪽 두 부분으로 나눈다.
#       · 왼쪽 부분: nums[0..i]
#       · 오른쪽 부분: nums[i+1..n-1]
#   - 이때, 두 부분의 합의 차이 |sum(left) - sum(right)| 가 짝수(even)가 되는 i의 개수를 구하는 문제이다.
#   - i는 0부터 n-2까지 가능한 모든 partition 위치를 고려한다.
#
# ✅ 입력 형식(요지):
#   - nums: List[int]
#       · 길이 n (n >= 1)
#       · 각 원소는 정수
#
# ✅ 규칙/관찰 요약:
#   - sum(left) - sum(right) 의 짝/홀 여부는 전체 합 S와 왼쪽 합 L의 짝/홀로 표현 가능하다.
#   - 전체 합 S = sum(nums), 왼쪽 합 L, 오른쪽 합 R 에 대해:
#       · R = S - L
#       · 차이 D = L - R = 2L - S
#   - D가 짝수가 되려면:
#       · 2L - S ≡ 0 (mod 2)  →  S ≡ 0 (mod 2)
#       · 즉, 전체 합 S 가 짝수이면, 어떤 L이든 상관없이 D는 항상 짝수.
#       · 전체 합 S 가 홀수이면, 어떤 L에 대해서도 D는 항상 홀수.
#   - 따라서:
#       · 전체 합이 짝수이면, 모든 partition 위치 i(0..n-2)가 유효 → 개수 = n - 1
#       · 전체 합이 홀수이면, 가능한 partition은 하나도 없음 → 개수 = 0
#   - 전체 합 S의 짝/홀은 배열 내 홀수 개수의 짝/홀과 같다:
#       · odd 개의 홀수가 있으면, S ≡ odd (mod 2)
#
# -----------------------------------------------------
# ✅ 정답 코드 (나의 최종 풀이; 절대 수정 금지, 주석만 추가)
# -----------------------------------------------------

from typing import List

class Solution:
    def countPartitions(self, nums: List[int]) -> int:
        odd = 0                      # 배열 내 홀수 원소의 개수를 셀 변수

        for num in nums:             # nums의 모든 원소를 순회
            if num % 2 == 1:         # num이 홀수이면
               odd += 1              # 홀수 개수 증가

        # 전체 합 S의 짝/홀은 홀수 개수 odd의 짝/홀과 동일하다.
        #   · odd 가 짝수 → S는 짝수
        #   · odd 가 홀수 → S는 홀수
        if odd % 2 == 0:
            # 전체 합이 짝수이면, 어떤 partition i(0..n-2)를 선택하더라도
            #   D = sum(left) - sum(right) = 2L - S 에서
            #   2L는 항상 짝수, S는 짝수 → D도 항상 짝수.
            # 따라서 모든 i가 유효 partition → 개수는 (n - 1).
            return len(nums) - 1
        else:
            # 전체 합이 홀수이면, 어떤 partition i에 대해서도
            #   2L는 짝수, S는 홀수 → D = 2L - S 는 항상 홀수.
            # 즉, 짝수 차이를 만드는 partition은 존재하지 않는다.
            return 0

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 합의 차이가 짝수가 되기 위한 조건을 직접 시뮬레이션 하는 대신,
#     "전체 합의 짝/홀" 관점으로 단순화하여 O(n) 한 번 순회로 정답 도출.
#   - 배열 내 홀수 개수의 짝/홀만으로 전체 합의 짝/홀을 판단하고,
#     그에 따라 (n - 1) 또는 0을 바로 반환하는 방식으로 정답을 맞춤.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - (가정) 처음에는 각 partition마다 sum(left), sum(right)를 실제로 계산하거나,
#     prefix sum을 사용해 각 i마다 조건을 검사하려 시도할 수 있음 → O(n^2) 또는 O(n) 복잡도.
#   - 이 풀이에서는:
#       · 합의 짝/홀만 필요하다는 점에 착안해,
#         "전체 합이 짝수이면 모든 partition 가능, 홀수이면 하나도 불가능"이라는 수식을 도출.
#       · 전체 합의 짝/홀은 "홀수 개수의 짝/홀"로 충분히 표현 가능하므로,
#         홀수 개수 odd만 세면 되는 문제로 축약했다.
#   - 사용한 개념:
#       1) 합의 짝/홀(Parity)와 홀수 개수 관계:
#          - S ≡ odd (mod 2)
#       2) 차이식 변형:
#          - D = L - R = 2L - S
#          - 2L는 항상 짝수 → D의 짝/홀은 S에만 의존.
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도: O(n)
#       · nums를 한 번 순회하여 홀수 개수만 세면 됨.
#   - 공간 복잡도: O(1)
#       · odd와 몇 개의 상수형 변수만 사용.
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - prefix sum을 사용해 각 partition별 sum(left), sum(right)를 실제로 계산하고
#     매번 (sum(left) - sum(right))의 짝/홀을 확인하는 방법도 가능하지만,
#     결국 동일한 결론(전체 합의 짝/홀에만 의존)에 도달한다.
#   - 현재 풀이가 이 문제에서 가능한 가장 단순하고 최적화된 형태라고 볼 수 있다.
# -----------------------------------------------------
