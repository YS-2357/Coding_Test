# 0014_longest_common_prefix.py
# -----------------------------------------------------
# ✅ 제목: Longest Common Prefix
# ✅ 문제 설명(요약):
# - 문자열 배열 strs가 주어질 때, 모든 문자열에 공통으로 존재하는 가장 긴 접두사를 반환.
# - 공통 접두사가 없으면 "" 반환.
#
# ✅ 입력 형식(요지):
# - strs: List[str], 길이 ≥ 1
#
# ✅ 규칙 요약:
# 1) 가장 짧은 문자열 길이만큼만 접두사 후보가 될 수 있다.
# 2) 접두사를 길이 줄여가며 모든 문자열에 대해 startswith 확인.
# 3) 가장 긴 접두사를 찾으면 바로 반환.
#
# ✅ 입출력 예시(1개):
# - strs = ["flower","flow","flight"] → "fl"
#
# ✅ 정답 코드(너의 풀이; 한 줄마다 주석):
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        n = min([len(s) for s in strs])           # 가장 짧은 문자열 길이를 기준으로 잡음
        
        for i in range(n, 0, -1):                 # 길이를 n부터 1까지 줄여가며
            prefix = strs[0][:i]                  # 기준 문자열의 접두사 추출
            if all(s.startswith(prefix) for s in strs):  # 모든 문자열이 해당 접두사로 시작하는지 확인
                return prefix                     # 조건 만족 시 즉시 반환
        
        return ''                                 # 공통 접두사가 없으면 빈 문자열 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 정상 작동. 다만 i를 줄여가며 체크하므로 최악의 경우 O(n·m²)까지 갈 수 있음.
#
# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - 이번엔 오답 없음. 다만 "큰 길이부터 줄이기" 방식이라 모든 검사를 끝까지 할 수 있음.
#   더 효율적 접근으로는 "세로 스캔" 또는 "정렬 후 첫/마지막 문자열 비교"가 있다.
#
# 📚 사용된/필수 개념(최소):
# - 문자열 슬라이싱 및 startswith
# - 모든 원소 확인을 위한 all()
# - 브루트포스지만 입력이 작을 때 충분히 통과
# - 시간복잡도: O(n·m²) (n=문자열 개수, m=최단 길이)
