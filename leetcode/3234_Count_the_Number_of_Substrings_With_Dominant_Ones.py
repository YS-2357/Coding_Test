# 3234_Count_the_Number_of_Substrings_With_Dominant_Ones.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3234. Count the Number of Substrings With Dominant Ones
# ✅ 주의: 아래 풀이는 "공식/다른 사람의 풀이"를 기반으로 한 정리이며, 나의 원작성 코드는 아님.
#
# ✅ 문제 설명(요약):
#   - 이진 문자열 s가 주어진다.
#   - 부분문자열에 대해, 1의 개수를 cnt1, 0의 개수를 cnt0라 할 때
#       cnt1 >= (cnt0)^2
#     를 만족하면 해당 부분문자열을 "dominant"라고 부른다.
#   - s의 모든 부분문자열 중 dominant 인 것의 개수를 구하는 문제.
#
# ✅ 입력 형식(요지):
#   - s: str, 길이 n (문자는 '0' 또는 '1')
#
# ✅ 규칙 요약:
#   - 부분문자열을 전부 O(n^2)로 보면서 (0,1) 개수를 직접 세면 TLE.
#   - 0의 개수(cnt0)를 기준으로 케이스를 나누고,
#     이전 0의 위치 정보를 이용해 "시작 위치 후보"들을 건너뛰며 세는 최적화된 방식.
#
# ✅ 정답 코드(나의 풀이 아님; 절대 수정 금지, 각 줄 주석만 추가)
class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        n = len(s)                            # 문자열 길이 n
        pre = [-1] * (n + 1)                  # pre[i]: 위치 i-1 기준으로, 직전(왼쪽) 0의 인덱스를 저장하는 배열

        for i in range(n):                    # 0 ~ n-1까지 순회하며 pre 배열 채우기
            if i == 0 or s[i - 1] == "0":     # i==0 이거나, 바로 앞 문자가 '0'이면
                pre[i + 1] = i                # 직전 0의 위치는 현재 인덱스 i
            else:                             # 앞 문자가 '1'이면, 직전 0 위치는 그대로 이어받음
                pre[i + 1] = pre[i]

        res = 0                               # 조건을 만족하는 부분문자열 개수
        for i in range(1, n + 1):             # 부분문자열의 끝 인덱스를 i-1로 고정 (1-based처럼 사용)
            cnt0 = 1 if s[i - 1] == "0" else 0  # 끝 문자가 '0'인지에 따라 0의 개수 초기화
            j = i                             # j: 시작 후보들을 역방향으로 따라갈 포인터 (pre를 통해 점프)
            while j > 0 and cnt0 * cnt0 <= n: # j가 범위 내이고, cnt0^2가 n을 넘지 않을 때만 진행 (상한 가지치기)
                cnt1 = (i - pre[j]) - cnt0    # 구간 [pre[j], i) 안의 길이에서 0 개수를 빼서 1 개수 계산
                                              #   길이 = i - pre[j]
                                              #   그 중 0은 cnt0개 → 1은 나머지
                if cnt0 * cnt0 <= cnt1:       # 조건 cnt1 >= cnt0^2 가 만족되면
                    res += min(               # 이 구간에서 유효한 시작점 개수를 한 번에 더함
                        j - pre[j],           #   (j ~ pre[j]+1 사이의 시작점 후보 개수)
                        cnt1 - cnt0 * cnt0 + 1#   (1 개수가 조건을 만족하는 최대 시작점 개수)
                    )
                j = pre[j]                    # j를 "직전 0의 위치+1" 부근으로 점프(다음 시작 후보 그룹으로 이동)
                cnt0 += 1                     # 한 단계 이동할 때마다 0을 하나 더 포함하는 케이스로 확장

        return res                            # 모든 끝점 i에 대해 누적한 dominant 부분문자열 개수 반환
# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 에디토리얼/고득점 풀이 기반 구현으로, 모든 테스트를 통과하는 정답 코드.
#   - 0의 개수를 단계적으로 늘리며, pre 배열을 통해 시작 인덱스 그룹을 점프 방식으로 탐색.
#
# 🔧 아이디어 및 사용된 알고리즘 개념:
#   - 핵심 조건: cnt1 >= (cnt0)^2 를 만족하는 부분문자열 카운팅.
#   - pre 배열:
#       • 각 i에 대해, 왼쪽에서 가장 가까운 0의 위치를 기억해
#         j를 pre[j]로 점프시키며 "0 개수 증가"를 O(√n) 수준으로 관리.
#   - 이중 루프 구조:
#       • 바깥 루프: 끝 인덱스 i를 고정.
#       • 안쪽 while: j를 pre[j]로 줄여가며 0의 개수(cnt0)를 1,2,3,... 식으로 증가.
#       • 각 단계에서 가능한 시작점 개수를 한 번에 더해, O(1) 수준으로 묶음 카운팅.
#   - 가지치기:
#       • cnt0^2 > n 이면, 길이 상한을 넘어 더 이상 성립 가능한 부분문자열이 없으므로 루프 중단.
#
# 📚 시간·공간 복잡도:
#   - 시간: 대략 O(n · √n) 수준 (각 i에서 cnt0가 커지면 조기에 중단되기 때문).
#   - 공간: O(n) (pre 배열만 추가 사용).
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - zeros 인덱스를 따로 모은 뒤,
#     "k개의 연속된 0 묶음 + 양옆의 1 개수(x,y)의 조합"으로 세는 조합론/수식 풀이도 존재한다.
