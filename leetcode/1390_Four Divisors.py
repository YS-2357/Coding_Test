# 1390_Four Divisors.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 1390. Four Divisors
# 🏷️ 유형: 수학 / 약수 탐색 / 브루트포스
#
# ✅ 문제 설명(요약):
#   - 정수 배열 nums가 주어질 때,
#   - 각 원소 중 약수의 개수가 정확히 4개인 수만 골라
#   - 그 약수들의 합을 모두 더한 값을 반환한다.
#
# ✅ 입력 형식(요지):
#   - nums: 정수 배열
#
# ✅ 규칙 요약:
#   - 약수의 개수가 정확히 4개인 경우만 고려한다.
#   - 각 수의 약수는 중복 없이 센다.
#
# 🧠 핵심 불변식(Invariant):
#   - 어떤 수 n에 대해 sqrt(n)까지만 탐색해도 모든 약수 쌍을 찾을 수 있다.
#   - 약수의 개수가 4개를 초과하면 더 이상 탐색할 필요가 없다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                          # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def sumFourDivisors(self, nums: List[int]) -> int:   # 약수 개수가 4개인 수들의 약수 합을 구하는 함수
        ans = 0                                          # 전체 약수 합을 누적할 변수 초기화

        for n in nums:                                  # 입력 배열 nums의 각 정수 n을 순회
            temp = set()                                # 현재 숫자 n의 약수를 중복 없이 저장할 집합 생성
            for d in range(1, int(sqrt(n)) + 1):        # 1부터 sqrt(n)까지 약수 후보를 순회
                if len(temp) > 4:                       # 약수 개수가 이미 4개를 초과한 경우
                    break                               # 더 이상 탐색하지 않고 반복 종료

                if n % d == 0:                          # d가 n의 약수인 경우
                    temp.add(d)                         # d를 약수 집합에 추가
                    temp.add(n // d)                    # 대응되는 약수 n//d를 함께 추가

            if len(temp) == 4:                          # 약수의 개수가 정확히 4개인 경우에만
                for d in temp:                          # 해당 약수들을 하나씩 순회하며
                    ans += d                            # 전체 정답에 약수 값을 누적

        return ans                                      # 모든 수에 대해 계산한 최종 합을 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: 제곱근 기반 약수 탐색, 집합(Set)을 이용한 중복 제거.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(∑√n)  (각 수마다 제곱근까지 탐색)
#   - 공간: O(1)    (각 수마다 최대 4개의 약수만 저장)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 약수 개수가 4개인 수는 p^3 또는 p*q(p≠q, 둘 다 소수) 형태라는 성질을 이용해,
#     소수 판별 기반으로 더 빠르게 판별하는 방식도 가능하다 (개념만).
