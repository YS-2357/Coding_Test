# 3190_Find_Minimum_Operations_to_Make_All_Elements_Divisible_by_Three.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3190. Find Minimum Operations to Make All Elements Divisible by Three
# ✅ 문제 설명(요약):
#   - 정수 배열 nums가 주어질 때,
#     각 원소에 대해 "원소의 값을 증가나 감소하는 1회 연산"을 적용할 수 있다.
#   - 목표: 모든 원소가 3으로 나누어떨어지도록 만들기 위해 필요한 최소 연산 횟수를 구하는 것.
#   - 관찰: 어떤 수 x가 3으로 나누어 떨어지지 않는 경우(x % 3 == 1 또는 2),
#           단 1회 증가/감소만으로 3의 배수로 만들 수 있다.
#
# ✅ 입력 형식(요지):
#   - nums: List[int] — 길이 n의 정수 배열
#
# ✅ 규칙 요약:
#   - num % 3 == 0 → 연산 0회
#   - num % 3 != 0 → 연산 1회
#   - 전체 답 = (3으로 나누어떨어지지 않는 원소의 개수)

# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
#   - nums를 순회하며 3으로 나누어떨어지지 않는 값만 ans를 1 증가.

class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        ans = 0                                # 필요한 총 연산 횟수 누적 변수

        for num in nums:                       # nums의 모든 숫자를 순회
            if num % 3 != 0:                   # 숫자가 3의 배수가 아니라면
                ans += 1                       # +1 또는 -1 한 번으로 3의 배수로 만들 수 있으므로 연산 1회 추가
        
        return ans                              # 전체 필요한 최소 연산 횟수 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - nums의 모든 원소를 순회하여 num % 3 값을 확인하는 즉시 해결 방식.
#   - 조건 자체가 단순하여 첫 제출에서 바로 정답 가능.
#   - 복잡한 처리가 필요 없이 규칙 기반의 카운팅 문제.

# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용한 개념:
#       - 나머지 연산(modulo)을 통한 규칙 단순화
#       - 각 원소를 독립적으로 처리하는 그리디 카운팅
#       - 3으로 나누어떨어지지 않는 모든 값은 단 1회의 증가/감소로 3의 배수가 됨

# 📚 시간·공간 복잡도:
#   - 시간 복잡도: O(n)
#       - nums를 한 번만 순회함.
#   - 공간 복잡도: O(1)
#       - 추가 메모리는 ans(정수) 하나뿐.

# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 현재 풀이가 최적이며 더 개선할 여지는 실제로 없음.
#   - 단, 이 문제는 수학적 성질(mod 3 구조)을 이용해 직관적으로 풀이할 수 있는 대표적인 규칙 문제.
