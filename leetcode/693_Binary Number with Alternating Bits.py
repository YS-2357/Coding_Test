# 693_Binary Number with Alternating Bits.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 693. Binary Number with Alternating Bits
# 🏷️ 유형: 비트 연산 / 문자열 처리
#
# ✅ 문제 설명(요약):
#   - 정수 n의 이진 표현에서 모든 인접한 비트가 서로 달라야 한다.
#   - 즉, 0과 1이 번갈아 나와야 한다.
#
# ✅ 입력 형식(요지):
#   - n: int (양의 정수)
#
# ✅ 규칙 요약:
#   - 이진수로 변환했을 때,
#   - "00" 또는 "11"이 존재하면 False.
#   - 끝까지 인접 비트가 모두 다르면 True.
#
# 🧠 핵심 불변식(Invariant):
#   - i번째 문자까지 검사했을 때,
#   - 바로 직전 비트(prev)와 현재 비트(now)는 항상 달라야 한다.
#   - 한 번이라도 같은 인접 비트가 나오면 즉시 False.
#
# =====================================================
# ✅ 정답 코드 1 (직접 순회 검사)
# =====================================================

class Solution:                                                     # LeetCode 제출용 Solution 클래스 정의
    def hasAlternatingBits(self, n: int) -> bool:                   # 비트가 번갈아 나오는지 확인하는 함수
        b = bin(n)[2:]                                              # 정수를 이진 문자열로 변환하고 '0b' 제거
        prev = ""                                                   # 이전 비트를 저장할 변수 초기화
        for now in str(b):                                          # 이진 문자열을 한 글자씩 순회
            if now == prev:                                         # 현재 비트와 이전 비트가 같으면
                return False                                        # 번갈아 나오지 않으므로 False 반환
            prev = now                                              # 이전 비트를 현재 비트로 갱신
        return True                                                 # 끝까지 문제 없으면 True 반환

# =====================================================
# ✅ 정답 코드 2 (문자열 패턴 검사)
# =====================================================

class Solution:                                                     # LeetCode 제출용 Solution 클래스 정의
    def hasAlternatingBits(self, n: int) -> bool:                   # 비트가 번갈아 나오는지 확인하는 함수
        return "11" not in bin(n) and "00" not in bin(n)            # 이진 문자열에 연속된 동일 비트가 없는지 검사

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 두 풀이 모두 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념:
#     - 풀이 1: 인접 문자 비교를 통한 순차 검증.
#     - 풀이 2: 문자열 패턴 검색을 통한 조건 확인.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(log n)  (이진 문자열 길이만큼)
#   - 공간: O(log n)  (이진 문자열 생성)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - n XOR (n >> 1)이 111... 형태인지 확인하는 비트 트릭 풀이도 존재한다(개념만).
