# 3228_Maximum_Number_of_Operations_to_Move_Ones_to_the_End.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3228. Maximum Number of Operations to Move Ones to the End
# ✅ 문제 설명(요약):
#   - 0과 1로 구성된 문자열 s가 주어진다.
#   - 연산: 인접한 "10" 쌍을 선택해 "01"로 바꾼다.
#   - 가능한 최대 연산 횟수를 구하라.
#
# ✅ 입력 형식(요지):
#   - s: str (0과 1로만 구성)
#   - 길이 1 이상, 전부 0 또는 전부 1일 수도 있음.
#
# ✅ 규칙 요약:
#   - "10" → "01"로 바꾸는 것은 1이 0의 오른쪽으로 이동하는 스왑과 동일하다.
#   - 결국 모든 1이 오른쪽 끝으로 이동할 때까지 가능한 연산 횟수는
#     **초기 상태에서 1이 0을 몇 번이나 앞지르는가(역전쌍 개수)**와 동일하다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
class Solution:
    def maxOperations(self, s: str) -> int:
        ones = 0                 # 지금까지 등장한 1의 누적 개수
        zero = False             # 연속된 0 구간 중 처음 0인지 판별용
        ans = 0                  # 최대 연산 횟수 누적

        for n in s:              # 문자열을 왼쪽→오른쪽 순회
            if n == "1":
                ones += 1        # 1을 만나면 1의 누적 증가
                zero = False     # 새로운 1이 나왔으므로 0구간 초기화
            elif n == "0" and not zero:
                ans += ones      # 0을 처음 만날 때, 앞의 모든 1이 이 0을 앞질러야 함
                zero = True      # 같은 0 구간 내에서 중복 카운트 방지

        return ans               # 전체 가능한 최대 연산 횟수 반환
# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 예제 및 임의 테스트 모두 통과.
#   - "0" 구간이 연속되더라도 한 번만 누적하여 중복 계산을 방지.
#   - 전체 1이 오른쪽으로 이동하기 위한 최대 스왑 수를 정확히 계산.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 사용 개념: Prefix Count (누적합), 역전쌍(Inversion) 계산.
#   - 직관:
#       • "10" → "01" 연산은 '1이 0 하나를 넘어가는' 행위와 같다.
#       • 각 0은 그 이전의 모든 1과 짝을 이루므로, 0을 처음 만날 때
#         이전까지의 1의 누적 수를 합하면 전체 역전쌍 개수를 얻는다.
#       • 연속된 0에 대해 중복 더하지 않기 위해 `zero` 플래그로 첫 0만 처리.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(n)
#   - 공간: O(1)
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 단순 누적합 기반 구현도 가능:
#       ones = 0; ans = 0
#       for ch in s:
#           if ch == '1': ones += 1
#           else: ans += ones
#     → 모든 0마다 이전 1의 개수를 합산 (연속 0도 허용 시 동일 결과)
