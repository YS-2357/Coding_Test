# 2435_Paths_in_Matrix_Whose_Sum_Is_Divisible_by_K.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 2435. Paths in Matrix Whose Sum Is Divisible by K
# ✅ 문제 설명(요약):
#   - m x n 크기의 정수 격자 grid가 주어진다.
#   - 시작점 (0, 0)에서 출발해, 매번 "오른쪽" 또는 "아래"로만 이동하여 (m-1, n-1)에 도달하는 모든 경로를 고려한다.
#   - 각 경로에서 지나간 칸들의 값의 합을 S라고 할 때, S % k == 0 을 만족하는 경로의 수를 구하는 문제이다.
#   - 경로의 수가 매우 클 수 있으므로, 결과는 10^9 + 7 로 나눈 나머지를 반환한다.
#
# ✅ 입력 형식(요지):
#   - grid: List[List[int]] — m x n 정수 격자.
#   - k: int — 나눌 기준이 되는 정수.
#
# ✅ 규칙 요약:
#   - 이동은 항상 격자 범위 내에서, "오른쪽" 또는 "아래" 방향으로만 가능하다.
#   - 각 경로는 (0,0)에서 시작하여 (m-1,n-1)에서 끝나는 단순 경로(뒤로 돌아가지 않음)이다.
#   - 경로에 포함된 grid 값들의 합이 k로 나누어 떨어지는지(S % k == 0) 확인하고, 그 조건을 만족하는 경로의 개수를 센다.
#   - 모듈러 연산(나머지 k)을 이용하여 DP 상태를 정의하는 것이 핵심이다.

# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
#   - 3차원 DP 배열 dp[i][j][r]를 사용한다.
#   - 의미: "1-based 좌표 (i, j)에 도달했을 때, 경로합 % k == r 인 경로의 수".
#   - 격자 좌표를 1-based로 맞추기 위해, dp는 크기 (m+1) x (n+1) x k로 선언하고,
#     실제 grid 인덱스는 grid[i-1][j-1] 형태로 접근한다.
#   - 점화식:
#       dp[i][j][r] =
#           dp[i-1][j][prev_mod] + dp[i][j-1][prev_mod]
#       여기서 prev_mod 는 현재 칸의 값 value 를 더하기 전의 나머지 상태:
#           prev_mod = (r - value + k) % k
#   - 시작점 (1,1)은 grid[0][0] % k 에 해당하는 나머지 상태에 대해 경로 수 1로 초기화한다.
#   - 최종 정답은 (m, n)에 도달했을 때 "나머지가 0"인 상태의 경로 수: dp[m][n][0].

class Solution:
    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
        MOD = 10 ** 9 + 7
        m, n = len(grid), len(grid[0])

        # dp 배열 크기:
        # - 행: 0 ~ m (총 m+1)
        # - 열: 0 ~ n (총 n+1)
        # - 나머지 상태: 0 ~ k-1 (총 k개)
        # dp[i][j][r] = (i, j)에 도달했을 때, 경로 합 % k == r 인 경우의 수
        # i, j는 1-based 좌표로 해석하고, 실제 grid 접근은 grid[i-1][j-1]로 한다.
        dp = [[[0] * k for _ in range(n + 1)] for _ in range(m + 1)]

        for i in range(1, m+1):               # 1 ~ m
            for j in range(1, n+1):           # 1 ~ n
                if i == 1 and j == 1:
                    # 시작점 (0,0)에 해당하는 1-based 좌표 (1,1)
                    # 이 위치의 값 grid[0][0]을 더했을 때, 나머지 상태는 grid[0][0] % k
                    # 그 상태로 가는 경로는 단 하나(시작점 자체)이다.
                    dp[i][j][grid[0][0] % k] = 1
                    continue
                
                value = grid[i-1][j-1] % k    # 현재 칸 값의 나머지 (이 칸을 더할 때의 증가량)
                for r in range(k):            # 현재 칸에 도달했을 때 가지게 될 나머지 상태 r
                    # 현재 칸에서의 r 상태를 만들기 직전의 나머지 상태(prev_mod)를 역산한다.
                    # (prev_mod + value) % k == r  ⇒  prev_mod == (r - value + k) % k
                    prev_mod = (r - value + k) % k

                    # 위쪽에서 내려오는 경우: (i-1, j)에서 prev_mod 상태로 도착했던 경로 수
                    # 왼쪽에서 오는 경우: (i, j-1)에서 prev_mod 상태로 도착했던 경로 수
                    # 둘 다 이 칸의 value를 더해 r 상태가 되므로 합쳐서 dp[i][j][r]에 더한다.
                    dp[i][j][r] = (dp[i - 1][j][prev_mod] + dp[i][j - 1][prev_mod]) % MOD
        
        # 최종 목적지 (m, n)에 도달하는 경로들 중
        # "경로합 % k == 0" 인 경우의 수가 우리가 원하는 정답.
        return dp[m][n][0]

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 2차원 dp로 "합의 나머지"만 저장하려고 했던 초기 시도에서,
#     "각 나머지 상태별 경로 개수"를 저장해야 함을 인지하고 3차원 DP로 전환.
#   - dp[i][j][r] 정의와 prev_mod 역산 로직을 통해,
#     이동 방향(위/왼쪽)과 현재 칸의 값(value)을 결합한 정확한 점화식을 구현했다.
#   - 시작점 (1,1)만 별도 초기화하고 나머지는 점화식에 의해 자동으로 채워지도록 설계.

# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답/실수(초기 접근 기준):
#       - 단순 2D dp[i][j]에 "합 % k 값 하나"만 저장하면,
#         각 나머지에 대응하는 "경로 개수"를 잃어버리기 때문에
#         정답인 "경로 수"를 계산할 수 없음.
#       - 따라서, 나머지 상태 r별로 경로 개수를 모두 추적하는 3D DP가 필요하다.
#   - 사용한 알고리즘/개념:
#       1) 동적 계획법(DP) + 격자 경로:
#          - (i,j)는 항상 (i-1,j) 또는 (i,j-1)에서만 올 수 있다는 점을 이용.
#       2) 모듈러 상태 DP:
#          - 합 전체가 아니라, 합을 k로 나눈 나머지 상태(0~k-1)만 추적.
#       3) 역산식(prev_mod):
#          - 현재 상태 r와 현재 칸 값 value가 주어졌을 때
#            이전 나머지 상태 prev_mod를 (r - value + k) % k 로 역산하는 점화식.

# 📚 시간·공간 복잡도:
#   - 시간 복잡도:
#       - i: 1 ~ m
#       - j: 1 ~ n
#       - r: 0 ~ k-1
#       ⇒ O(m * n * k)
#   - 공간 복잡도:
#       - dp 배열 크기: (m+1) x (n+1) x k
#       ⇒ O(m * n * k)
#   - m, n, k ≤ 50 수준이면 충분히 감당 가능한 범위이다.

# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 공간 최적화:
#       - 현재 로직은 dp를 (m+1) x (n+1) x k 모두 저장하고 있지만,
#         i를 한 줄씩 내려가며 계산할 때 이전 행/현재 행만 유지하는 방식(rolling array)으로
#         공간을 O(n * k) 수준으로 줄일 수 있다.
#   - 그러나, 현재 구현은 직관적이고 디버깅이 쉬운 형태로,
#     문제 제약 내에서는 충분히 효율적이며 명확한 3D DP 정석 풀이이다.
