# 0611_valid_triangle_number.py
# -----------------------------------------------------
# ✅ 제목: Valid Triangle Number (LeetCode 611)
# ✅ 문제 설명(요약):
# - 배열에서 세 변을 골라 유효한 삼각형을 만들 수 있는 조합의 수를 구한다.
#
# ✅ 입력 형식(요지):
# - nums: List[int] (길이 n, n ≥ 0)
#
# ✅ 규칙 요약:
# 1) 유효 삼각형 조건(정렬 후 a ≤ b ≤ c): a + b > c 만 확인하면 충분
# 2) 길이 0은 삼각형을 만들 수 없음(암묵적으로 제외됨)
# 3) 인덱스가 다른 세 원소의 조합을 모두 센다(중복 길이 가능)
#
# ✅ 입출력 예시(1개):
# - nums = [2,2,3,4] → 정답 3
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        if len(nums) < 3:
            return 0
        nums.sort()
        answer = 0

        for k in range(len(nums)-1, 1, -1):
            i, j = 0, k-1
            while i < j:
                if nums[i] + nums[j] > nums[k]:
                    answer += (j - i)
                    j -= 1         
                else:
                    i += 1
        
        return answer

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 초기 버전에서 조건 만족 시 answer += 1만 더해 과소계산.
# - while 조건을 i != j로 두어 교차 후 불필요 비교 가능성.
# - 수정 후( answer += (j - i), while i < j ) 테스트 통과.
#
# 🔧 오답 이유 및 실수:
# - 투 포인터 핵심: nums[i] + nums[j] > nums[k]이면 i..j-1 모두 유효 → 한 번에 (j - i)개 누적 필요.
# - 루프 조건은 i < j가 안전.
#
# 📚 사용된/필수 개념:
# - 정렬 + 투 포인터 단조성 이용
# - 삼각형 부등식 단일 조건(a + b > c)로 축약(정렬 전제)
# - 시간복잡도 O(n^2), 공간복잡도 O(1)
#
# -----------------------------------------------------
# (선택) 다른 효율적인 풀이 또는 제안:
# - 정렬 + 이진 탐색: 각 (i, j)에 대해 a+b를 넘는 첫 k를 이진 탐색 → O(n^2 log n)
# - 값 범위가 작을 때 카운팅 배열 + 누적합으로 조합 수 계산(구현 복잡)
