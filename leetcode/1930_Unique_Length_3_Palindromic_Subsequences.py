# 1930_Unique_Length_3_Palindromic_Subsequences.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 1930. Unique Length-3 Palindromic Subsequences
# ✅ 문제 설명(요약):
#   - 문자열 s가 주어졌을 때, 길이가 정확히 3인 팰린드롬 부분수열(subsequence)의 "서로 다른" 개수를 구하는 문제.
#   - 길이 3 팰린드롬은 항상 a b a 형태이며,
#     - 첫 문자와 세 번째 문자는 같고,
#     - 가운데 문자는 아무 문자나 가능하다.
#   - subsequence이므로 인덱스는 i < j < k 이기만 하면 되고, 연속일 필요는 없다.
#
# ✅ 입력 형식(요지):
#   - s: str
#     - 알파벳 소문자로 이루어진 문자열 (문제 조건 상 길이는 최대 10^5 수준)
#
# ✅ 규칙 요약:
#   - 길이 3, 형태는 항상 s[i] == s[k] 이고, i < j < k 인 세 개의 인덱스 (i, j, k)를 선택해 만든 a b a 구조.
#   - "서로 다른" 팰린드롬 수열만 카운트하므로,
#     - 같은 (a, b, a) 조합이 여러 위치에서 나와도 1개로 본다.
#   - 정답은 가능한 모든 서로 다른 a b a의 개수.

# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
#   - 아래 코드는 바깥 문자를 ch로 Fix하고,
#     맨 오른쪽에서부터 동일한 문자 ch를 찾은 뒤,
#     그 사이 구간에서 등장하는 서로 다른 가운데 문자 c를 세는 방식이다.
#   - meet: 이미 처리한 바깥 문자(outer char)를 기록해,
#     같은 문자를 바깥으로 두는 경우를 한 번만 처리하려는 목적이다.

class Solution:
    def countPalindromicSubsequence(self, s: str) -> int:
        meet = set()                  # 이미 바깥 문자로 사용한 문자(ch)들을 기록하는 집합
        n, ans = len(s), 0            # n: 문자열 길이, ans: 결과(서로 다른 길이 3 팰린드롬 수)

        for i, ch in enumerate(s):    # i: 왼쪽 인덱스, ch: s[i] (바깥 문자 후보)
            end = n - 1               # end: 오른쪽에서부터 같은 문자 ch를 찾기 위한 포인터

            # i와 end가 만나기 전까지, 그리고 아직 ch를 바깥 문자로 처리하지 않았을 때만 탐색
            while i != end and ch not in meet:
                if ch == s[end]:      # 오른쪽 끝에서 같은 문자 ch를 찾은 경우 (s[i] == s[end])
                    meet.add(ch)      # 이 문자 ch는 이제 바깥 문자로 한 번 처리했으므로 meet에 기록
                    dupe = set()      # 중간 문자들의 중복을 막기 위한 집합 (해당 ch에 대해 한 번만 카운트)
                    for c in s[i + 1:end]:
                        # i와 end 사이의 모든 문자 c를 확인하며,
                        # 아직 등장하지 않은 가운데 문자라면 ans를 1 증가
                        if c not in dupe:
                            ans += 1  # (ch, c, ch) 형태의 새로운 길이 3 팰린드롬 하나 발견
                            dupe.add(c)
                            # print(ch, c, ch)  # 디버깅용 출력(주석 처리)
                    break             # 해당 ch에 대해 가장 오른쪽 end를 찾고 처리했으므로 while 종료
                end -= 1              # 아직 같은 문자를 못 찾은 경우 오른쪽 포인터를 한 칸 왼쪽으로 이동

        return ans                    # 최종적으로 서로 다른 길이 3 팰린드롬 수를 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 바깥 문자를 고정(ch = s[i])하고, 오른쪽 끝에서부터 동일 문자 ch를 찾은 뒤,
#     그 사이 구간 (i+1 ~ end-1)에 등장하는 서로 다른 문자 c들을 세어서
#     (ch, c, ch) 구조의 길이 3 팰린드롬 개수를 구하는 방식이다.
#   - meet 집합을 이용해 동일 문자 ch를 바깥 문자로 한 번만 처리하려고 하였고,
#     dupe 집합으로 같은 (ch, c, ch)를 중복 카운트하지 않도록 제어한다.
#   - 값 기준으로 중복 제거(dupe)까지 고려했기 때문에,
#     단순히 end - i - 1을 더하던 기존 방식보다 "종류 수"에 더 근접한 카운팅을 수행한다.

# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 사용한 알고리즘 개념:
#       - 바깥 문자 고정: a b a 구조에서 a에 해당하는 문자를 먼저 선택.
#       - 투 포인터(Left/Right): 왼쪽에서 i, 오른쪽에서 end를 움직이며 동일 문자를 찾는 스캔.
#       - 집합을 활용한 중복 제거: dupe로 중간 문자 b의 중복을 제거, meet로 바깥 문자 a의 중복 처리 방지.
#   - 한계/문제점:
#       1) 시간 복잡도:
#          - 최악의 경우, i를 0~n-1까지 순회하면서,
#            각 i마다 end를 거의 끝에서부터 줄여나갈 수 있다 (O(n^2) 패턴).
#          - 또한, s[i+1:end] 슬라이싱 + 그 구간 전체를 도는 for 루프 때문에,
#            각 바깥 문자 ch 처리에 O(n) 이상 비용이 추가된다.
#          - meet로 인해 각 문자 ch를 한 번만 처리한다고 해도,
#            최악 O(알파벳 수 × n^2)에 가까운 성능을 가질 수 있다.
#       2) 구조적 비효율:
#          - a b a 구조에서, 같은 바깥 문자 a에 대해 필요한 것은
#            "가장 왼쪽 a, 가장 오른쪽 a 사이에 어떤 문자들이 등장하는지" 뿐인데,
#            매 i마다 새롭게 end와 substring을 탐색/순회하고 있다.
#       3) 인덱스·값 분리 부족:
#          - 실제 문제는 인덱스 조합 개수가 아니라 값 조합 (a, b)의 종류 수를 묻는다.
#          - 이 코드는 중간 문자 b에 대해서는 중복을 제거하지만,
#            바깥 문자 a에 대한 first/last 인덱스를 전역적으로 미리 계산해두지 않고
#            매번 i에서 다시 찾는 구조를 사용하고 있어 전체적인 흐름이 비효율적이다.
#   - 요약:
#       - 개념적으로는 "a를 고정하고 그 사이에 오는 서로 다른 b를 센다"는 방향이 맞지만,
#         구현 방식이 매 i 기준 재탐색이라 시간 복잡도가 커지고,
#         first/last 인덱스를 이용한 최적화를 활용하지 못하고 있다.

# 📚 시간·공간 복잡도:
#   - 시간 복잡도 (대략적 상한 추정):
#       - 바깥 루프: i를 0~n-1까지 순회 → O(n)
#       - while 루프에서 end를 줄이는 과정: 최악 시 각 i마다 O(n)에 가까울 수 있음.
#       - s[i+1:end] 슬라이스 생성 + 내부 for 루프: 길이가 O(n)인 구간을 모두 순회.
#       - meet로 인해 한 문자(ch)를 한 번만 처리한다고 해도,
#         한 번 처리 시 O(n)~O(n^2)에 가까운 비용이 발생할 수 있다.
#       - 전체적으로 최악 O(n^2)에 가까운 시간 복잡도를 가진다고 볼 수 있다.
#   - 공간 복잡도:
#       - meet, dupe: 문자 집합 크기(최대 알파벳 수)에 비례 → O(알파벳 수)
#       - 슬라이스 s[i+1:end]는 매번 새 문자열을 만들므로, 순간적으로 O(n) 공간을 사용할 수 있다.
#       - 전반적으로 O(n) 추가 공간이 필요할 수 있다.

# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 더 효율적인 정석 해법 개념:
#       1) 각 문자 a에 대해:
#          - 문자열 s 전체에서 a가 처음 등장하는 위치 first[a],
#            마지막으로 등장하는 위치 last[a]를 기록한다.
#       2) 만약 first[a]와 last[a] 사이에 최소 1칸 이상의 여유가 없다면
#          (즉, last[a] - first[a] <= 1) → 가운데 문자가 존재할 수 없어 a b a 불가.
#       3) 그렇지 않다면, 구간 s[first[a]+1 .. last[a]-1] 안에 등장하는
#          서로 다른 문자 b의 개수를 센다.
#          - 이 개수가 곧 "바깥이 a인 서로 다른 a b a 팰린드롬의 개수".
#       4) 모든 문자 a에 대해 위 개수를 합치면 정답.
#   - 장점:
#       - 각 문자 a는 최대 한 번만 처리하며,
#         내부에서 "가운데 구간"을 한 번만 스캔하면 되므로
#         전체 시간 복잡도는 O(알파벳 수 × n) 수준으로 줄어든다.
#       - 중복 제거도 (a, b) 조합 단위로 자연스럽게 해결된다.
#   - 이 풀이 방향은 현재 코드의 아이디어(바깥 문자 고정 + 가운데 문자의 종류 수 세기)를 유지하면서,
#     인덱스 처리와 중복 제거를 훨씬 효율적으로 만드는 정석적인 최적화 방법이다.
