# 239_Sliding_Window_Maximum.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 239. Sliding Window Maximum
# -----------------------------------------------------
# ✅ 문제 설명(요약):
#   - 정수 배열 nums와 정수 k가 주어졌을 때,
#     길이가 k인 슬라이딩 윈도우를 배열의 왼쪽에서 오른쪽으로 한 칸씩 이동시키면서,
#     각 윈도우 구간의 최댓값을 순서대로 구하는 문제이다.
#   - 윈도우는 인접한 k개의 원소로 이루어진 연속 구간이며,
#     첫 윈도우는 nums[0..k-1], 다음은 nums[1..k], ..., 마지막은 nums[n-k..n-1]이다.
#
# ✅ 입력 형식(요지):
#   - nums: List[int]  (배열 길이 n)
#   - k: int           (윈도우 크기, 1 <= k <= n)
#
# ✅ 규칙 요약:
#   - 각 위치 i에 대해, 윈도우가 [i-k+1 .. i] 구간을 덮을 때의 최댓값을 계산한다.
#   - 정답 리스트의 길이는 총 n - k + 1 이 된다.
#   - 효율적 풀이를 위해, 각 윈도우마다 O(1) 평균 시간에 최댓값을 얻는 것이 중요하다.
#   - 본 풀이는 deque(덱)를 사용해 **단조 감소 큐(monotonic decreasing queue)** 를 유지하는 방식으로 해결한다.

from collections import deque
from typing import List

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        ans = []                # 각 슬라이딩 윈도우의 최댓값을 담을 결과 리스트
        q = deque()             # 윈도우 내 원소들을 "값 기준 내림차순"으로 유지하는 덱

        for i, n in enumerate(nums):     # i: 현재 인덱스, n: nums[i] 값
            # 1) 덱의 뒤에서부터 현재 값 n보다 작은 값들은
            #    앞으로도 최댓값이 될 일이 없으므로 모두 제거한다.
            #    (덱은 항상 앞에서 뒤로 갈수록 값이 감소하는 구조 유지)
            while q and q[-1] < n:
                q.pop()
            q.append(n)         # 현재 값 n을 덱의 뒤에 추가

            # 2) 윈도우가 한 칸 오른쪽으로 움직이며,
            #    윈도우 범위를 벗어난 값을 덱에서 제거해야 한다.
            #    - 윈도우의 시작 인덱스는 (i - k + 1)
            #    - nums[i - k]는 이전 윈도우의 가장 왼쪽 값.
            #    - i >= k 이고, 그 값이 덱의 맨 앞값과 같다면,
            #      더 이상 윈도우 안에 존재하지 않으므로 덱에서 제거.
            if i >= k and nums[i - k] == q[0]:
                q.popleft()

            # 3) i가 k-1 이상일 때부터, 매번 현재 윈도우의 최댓값을 기록한다.
            #    - 덱의 맨 앞값 q[0]이 항상 현재 윈도우의 최댓값.
            if i >= k-1:
                ans.append(q[0])

        return ans              # 모든 윈도우에 대한 최댓값 리스트 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - deque를 이용한 단조 감소 큐 방식으로 각 윈도우의 최댓값을 O(1) 평균 시간에 얻는 풀이이다.
#   - 각 원소는 덱에 최대 한 번 들어가고, 최대 한 번 빠져나오기 때문에,
#     전체 시간 복잡도는 O(n)으로 충분히 효율적이다.
#   - 주어진 테스트 및 예제에 대해 정답을 출력함을 확인하였다.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - (잠재적 오답 접근) 각 윈도우마다 단순히 max(nums[i..i+k-1])를 계산하면 O(nk)로 TLE 위험.
#   - 사용한 알고리즘 개념:
#       1) Monotonic Queue (단조 큐):
#          - 덱을 내림차순으로 유지하여 맨 앞에 항상 최댓값이 오도록 유지.
#          - 새 값이 들어올 때, 뒤에서부터 자기보다 작은 값들을 제거해
#            불필요한 값들을 미리 제거함으로써, O(1) 평균 시간에 최댓값 갱신.
#       2) Sliding Window:
#          - 인덱스 i를 기준으로, 윈도우 범위 [i-k+1 .. i]를 유지하며,
#            범위를 벗어나는 원소가 덱 맨 앞이라면 제거해 윈도우 일관성 유지.
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도: O(n)
#       · 각 원소는 덱에 한 번 들어가고, 최대 한 번 제거된다.
#   - 공간 복잡도: O(k)
#       · 덱에는 항상 현재 윈도우 내 원소들(또는 그 후보)만 저장된다.
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 세그먼트 트리, 스파스 테이블(RMQ) 등을 사용해 O(n log n) 또는 O(n)으로도 해결 가능하지만,
#     구현 복잡도 측면에서 deque 기반 단조 큐 풀이가 가장 널리 쓰이고 직관적이다.
# -----------------------------------------------------
