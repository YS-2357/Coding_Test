# 3454_Separate Squares II.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3454. Separate Squares II
# 🏷️ 유형: 스위프 라인 / 구간 합집합(Union of Intervals) / 기하
#
# ✅ 문제 설명(요약):
#   - 여러 정사각형(축에 평행)이 주어질 때, 수평선 y = t로 잘라
#   - 선 아래 영역의 “합집합 면적”이 전체 합집합 면적의 절반이 되는 t를 구한다.
#   - 면적은 겹치는 부분을 중복으로 세지 않고(합집합) 계산한다.
#
# ✅ 입력 형식(요지):
#   - squares: List[List[int]] 형태의 [x, y, l] 리스트
#     - (x, y)는 정사각형의 좌하단 좌표
#     - l은 한 변의 길이
#
# ✅ 규칙 요약:
#   - 면적 계산은 사각형들의 합집합 면적 기준이다.
#   - y가 변하는 구간(이벤트 사이)에서는 활성 구간들의 x-합집합 길이가 일정하다.
#   - 전체 면적의 절반 지점에 해당하는 y를 실수로 반환한다.
#
# 🧠 핵심 불변식(Invariant):
#   - y 이벤트(시작/끝) 사이 구간에서는 활성 정사각형들의 x-구간 합집합 길이 w가 고정된다.
#   - 따라서 해당 y-스트립의 면적은 h * w로 구간별로 정확히 분해된다.
#   - 구간별 면적을 누적하다가 전체의 절반을 넘는 구간에서 선형 보간으로 답을 계산한다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                                                  # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def separateSquares(self, squares: List[List[int]]) -> float:                # 합집합 면적을 절반으로 나누는 y값을 찾는 함수
        events = []                                                              # y 스위프를 위한 이벤트 리스트 초기화
        for x, y, l in squares:                                                  # 각 정사각형 [x, y, l]을 순회하며
            events.append((y, 1, x, x + l))                                      # 정사각형이 시작되는 y에서 활성 구간 추가 이벤트 등록
            events.append((y + l, -1, x, x + l))                                 # 정사각형이 끝나는 y에서 활성 구간 제거 이벤트 등록

        events.sort()                                                           # y 기준으로 이벤트를 정렬하여 아래에서 위로 스위프 가능하게 함
        xs = []                                                                 # 현재 y에서 활성화된 x-구간들을 저장하는 리스트 초기화
        prev_y = events[0][0]                                                   # 스위프 시작 y를 첫 이벤트 y로 설정
        total = 0                                                               # 전체 합집합 면적을 누적할 변수 초기화
        areas = []                                                              # (구간 시작 y, 높이 h, 폭 w) 스트립 정보를 저장할 리스트 초기화

        def union_len(intervals):                                               # x-구간들의 합집합 길이를 계산하는 함수 정의
            intervals.sort()                                                    # 구간들을 시작점 기준으로 정렬하여 병합 계산 준비
            res = cur = 0                                                       # res는 합집합 길이 누적, cur는 사용하지 않는 변수(원본 유지)
            end = -10**30                                                       # 현재 병합된 구간의 끝점을 매우 작은 값으로 초기화
            for a, b in intervals:                                              # 정렬된 각 구간 (a, b)를 순회하며
                if a > end:                                                     # 이전 구간과 겹치지 않으면
                    res += b - a                                                # 새 구간 길이를 그대로 더함
                    end = b                                                     # 병합 구간의 끝점을 b로 갱신
                elif b > end:                                                   # 일부만 겹치고 더 오른쪽으로 확장된다면
                    res += b - end                                              # 겹치지 않는 추가 부분만 더함
                    end = b                                                     # 병합 구간의 끝점을 b로 갱신
            return res                                                          # 계산된 합집합 길이를 반환

        for y, typ, x1, x2 in events:                                           # 정렬된 이벤트를 y 오름차순으로 순회
            if y > prev_y and xs:                                               # 이벤트 간 높이가 있고 활성 구간이 존재하는 경우
                h = y - prev_y                                                  # 현재 스트립(수평 띠)의 높이 h를 계산
                w = union_len(xs)                                               # 현재 활성 x-구간들의 합집합 길이 w를 계산
                areas.append((prev_y, h, w))                                    # 이후 절반 지점 탐색을 위해 스트립 정보를 저장
                total += h * w                                                  # 전체 합집합 면적에 현재 스트립 면적을 누적
            if typ == 1:                                                        # 시작 이벤트라면
                xs.append((x1, x2))                                             # 활성 x-구간 리스트에 (x1, x2)를 추가
            else:                                                               # 종료 이벤트라면
                xs.remove((x1, x2))                                             # 활성 x-구간 리스트에서 (x1, x2)를 제거
            prev_y = y                                                          # 다음 이벤트 처리를 위해 prev_y를 현재 y로 갱신

        half = total / 2                                                        # 전체 합집합 면적의 절반을 목표 면적으로 설정
        acc = 0                                                                 # 아래부터 누적된 면적을 저장할 변수 초기화
        for y, h, w in areas:                                                   # 저장된 각 스트립(구간)을 아래에서 위로 순회
            if acc + h * w >= half:                                             # 이 스트립 안에 절반 지점이 포함되면
                return y + (half - acc) / w                                     # 남은 면적을 폭 w로 나눠 필요한 높이를 보간하여 y값 반환
            acc += h * w                                                        # 절반 지점이 아니면 이 스트립 면적을 누적에 더함

        return 0.0                                                              # 예외적으로 못 찾는 경우를 대비한 기본 반환값

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: y-스위프 라인 + 활성 x-구간의 합집합 길이 계산 + 스트립 면적 누적 후 선형 보간.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(E * K log K)  (E는 이벤트 수=2n, 각 이벤트에서 union_len이 활성 구간 정렬을 수행)
#   - 공간: O(n)            (events/xs/areas 저장)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 활성 구간의 합집합 길이를 매 이벤트마다 정렬로 계산하지 않고,
#     좌표 압축 + 세그먼트 트리로 동적 갱신하면 더 큰 입력에서도 효율적으로 처리할 수 있다 (개념만).
