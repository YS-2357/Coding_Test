# 401_Binary Watch.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 401. Binary Watch
# 🏷️ 유형: 브루트포스 / 비트 카운팅(popcount) / 비트마스크 열거
#
# ✅ 문제 설명(요약):
#   - 이진 시계는 시(hour) 4비트(0~11), 분(minute) 6비트(0~59)로 표현된다.
#   - 켜진 LED(=1 비트) 개수가 turnedOn과 정확히 같은 모든 시간을 "H:MM" 형식으로 반환한다.
#
# ✅ 입력 형식(요지):
#   - turnedOn: int
#
# ✅ 규칙 요약:
#   - 시간은 0~11, 분은 0~59 범위만 유효하다.
#   - 출력 분은 항상 두 자리로 0 패딩해야 한다(예: 3:07).
#   - 켜진 비트 수는 hour의 1비트 개수 + minute의 1비트 개수로 계산한다.
#
# 🧠 핵심 불변식(Invariant):
#   - 모든 가능한 (h, m)을 열거하면 누락 없이 정답 후보를 검사할 수 있다.
#   - popcount(1비트 개수)가 turnedOn과 같을 때만 결과에 추가한다.
#   - 10비트를 하나의 정수 i로 합쳐서(상위 4비트=시간, 하위 6비트=분) 열거해도 동일한 후보 공간(0..1023)을 완전 탐색하게 된다.
#
# =====================================================
# ✅ 정답 코드 1 (시간/분 직접 열거)
# =====================================================

class Solution:                                                     # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def readBinaryWatch(self, turnedOn: int) -> List[str]:          # 가능한 시간 문자열 리스트를 반환하는 함수
        ans = list()                                                # 정답 문자열을 담을 리스트 초기화

        for h in range(12):                                         # 가능한 시(hour) 0..11을 순회
            for m in range(60):                                     # 가능한 분(minute) 0..59를 순회
                if bin(h).count("1") + bin(m).count("1") == turnedOn:  # h와 m의 1비트 개수 합이 turnedOn이면
                    ans.append(f"{h}:{m:02d}")                      # "H:MM" 형식으로 추가

        return ans                                                  # 결과 리스트를 반환

# =====================================================
# ✅ 정답 코드 2 (10비트 정수 0..1023 완전 탐색)
# =====================================================

class Solution:                                                     # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def readBinaryWatch(self, turnedOn: int) -> List[str]:          # 가능한 시간 문자열 리스트를 반환하는 함수
        ans = list()                                                # 정답 문자열을 담을 리스트 초기화
        for i in range(1024):                                       # 10비트(4+6) 조합을 0..1023으로 완전 탐색
            h, m = (                                                # i에서 시간과 분을 분리 추출
                i >> 6,                                             # 상위 4비트(시간)를 오른쪽 시프트로 추출
                i & 0x3F,                                           # 하위 6비트(분)를 마스크로 추출
            )  # Extract the high 4 bits and low 6 bits using bitwise operations  # 비트 연산으로 분리했다는 설명 주석
            if h < 12 and m < 60 and bin(i).count("1") == turnedOn: # 유효 범위 검사 + i의 1비트 개수가 turnedOn이면
                ans.append(f"{h}:{m:02d}")                          # "H:MM" 형식으로 추가
        return ans                                                  # 결과 리스트를 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 두 풀이 모두 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념:
#     - 풀이 1: 가능한 시간/분 조합을 직접 브루트포스로 검사.
#     - 풀이 2: 10비트 비트마스크를 완전 탐색하며 비트 추출로 (h,m) 복원.
#
# 📚 시간·공간 복잡도:
#   - 풀이 1: 시간 O(12*60), 공간 O(1) (출력 제외)
#   - 풀이 2: 시간 O(1024), 공간 O(1) (출력 제외)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 미리 “시간별 popcount 목록”과 “분별 popcount 목록”을 그룹화해 조합하는 방식으로도 풀 수 있다(개념만).
