# 960_Delete_Columns_to_Make_Sorted_III.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 960. Delete Columns to Make Sorted III
# ✅ 문제 설명(요약):
#   - 동일 길이의 문자열 배열 strs가 주어진다.
#   - 일부 열(column)을 삭제하여, 남은 열들로 구성된 문자열 배열이 사전식(lexicographic) 비내림차순이 되게 한다.
#   - 최소 삭제 열 개수를 반환한다.
#
# ✅ 입력 형식(요지):
#   - strs: 길이가 같은 문자열들의 리스트 (각 문자열 길이 = n)
#
# ✅ 규칙 요약:
#   - 열 삭제는 모든 행(문자열)에 동일하게 적용된다.
#   - 목표는 최종적으로 strs[0] <= strs[1] <= ... <= strs[m-1] (사전식 비내림차순) 만족.
#   - “삭제 최소화”는 “남길 열 최대화”와 동치이므로,
#     선택 가능한 열 인덱스의 최장 길이를 구한 뒤 (n - 그 길이)를 반환하는 접근이 가능하다.
#   - 현재 풀이는 열 i 다음에 열 j를 이어 붙일 수 있는 조건을
#     모든 행에 대해 row[i] <= row[j]가 성립하는지로 정의하여 DP를 수행한다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
#   - 아래는 사용자가 제출/채택한 최종 정답 코드이며,
#     이 단계에서는 코드 내용을 변경하지 않고,
#     각 줄마다 설명 주석만 추가한다.

class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        n = len(strs[0])                                     # 열(column) 개수(각 문자열 길이)
        dp = [1] * n                                         # dp[i]: 열 i를 시작(또는 포함)했을 때 만들 수 있는 최대 선택 열 길이

        for i in range(n-2, -1, -1):                         # 뒤에서 앞으로 순회(후속 열 j의 dp가 먼저 계산되도록)
            for j in range(i+1, n):                          # i보다 오른쪽에 있는 열 후보 j들 탐색
                if all(row[i] <= row[j] for row in strs):    # 모든 행에서 열 i의 문자 <= 열 j의 문자인지(열 i -> j 전이 가능 조건)
                    dp[i] = max(dp[i], 1 + dp[j])            # 전이 가능하면 LIS 유사 DP 갱신
                    print(dp)                                # 디버깅 출력(최종 제출/정리에서는 제거 권장)

        return n - max(dp)                                   # 남길 수 있는 최대 열 길이를 빼서 최소 삭제 열 수 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 제공된 테스트에서 디버깅 출력(Stdout)이 발생할 수 있으나, 반환값 계산 로직과는 무관.
#   - 단, 3단계 산출물에서는 print 같은 디버깅 출력이 남아 있으면 안 된다(제거 권장).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 사용한 핵심 알고리즘/개념:
#     - “삭제 최소화” = “유지(선택) 가능한 열 최대화”로 변환
#     - 열 인덱스에 대한 DP(LIS 변형):
#       - i < j일 때, 모든 행에서 row[i] <= row[j]이면 i 다음에 j를 둘 수 있다고 정의
#       - dp[i] = 1 + max(dp[j]) (가능한 j들 중) 형태로 갱신
#   - 주의 포인트:
#     - 본 코드에 포함된 print(dp)는 디버깅용이며, 최종 제출에는 남기지 않는 것이 원칙이다.
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도: O(n^2 * R)
#     - n = 열 개수, R = 행(문자열) 개수 = len(strs)
#     - 각 (i, j)마다 all(...)로 R개 행을 확인
#   - 공간 복잡도: O(n)
#     - dp 배열만 사용(입력 제외)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 전이 조건 검사(all(row[i] <= row[j]))를 빠르게 하기 위해
#     열 쌍 비교를 캐시하거나, 문자 비교를 미리 전처리하여 상수항을 줄이는 최적화가 가능하다(코드 변경 필요).
#   - 일반적으로는 n(열)이 최대 1000 수준일 때 O(n^2 * R)는 부담될 수 있어,
#     입력 제약에 따라 추가 최적화가 필요할 수 있다(코드 변경 필요).
