# 3577_count_computer_unlocking_permutations.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3577 - Count the Number of Computer Unlocking Permutations
#
# ✅ 문제 설명(요약):
#   - 컴퓨터 0은 이미 잠금 해제된 상태.
#   - 컴퓨터 i(>0)를 열기 위해서는, 이미 열린 컴퓨터 중 j<i 이면서
#     complexity[j] < complexity[i] 인 j가 최소 1개 필요.
#   - 가능한 모든 잠금 해제 순서(퍼뮤테이션)의 개수를 구한다.
#
# ✅ 입력 형식(요지):
#   - complexity: 길이 n의 정수 배열 (복잡도)
#
# ✅ 규칙 요약:
#   - 컴퓨터 0이 시작점이므로, complexity[0] < 모든 complexity[i] (i>0)가 필수.
#   - 이 조건이 깨지면 어떤 순서로도 조건을 만족할 수 없으므로 정답은 0.
#   - 조건을 만족하면, 나머지 (n-1)개의 컴퓨터는 어떤 순서로든 열 수 있어 (n-1)! 개.
#
# -----------------------------------------------------
# ✅ 정답 코드 (사용자 풀이; 수정 금지, 주석만 추가)

class Solution:
    def countPermutations(self, complexity: List[int]) -> int:
        MOD = 10**9 + 7                # 모듈러 값 정의
        n = len(complexity)            # 전체 컴퓨터 개수
        
        # 컴퓨터 0의 복잡도가 모든 다른 컴퓨터보다 엄격히 작아야 조건을 만족한다.
        # 만약 complexity[0] >= complexity[i] 인 i>0 이 존재하면 잠금 불가 → 0 반환
        for c in complexity[1:]:
            if complexity[0] >= c:
                return 0
        
        # 조건을 만족하면 컴퓨터 1..n-1 의 순열은 모두 가능 → (n-1)! % MOD
        return factorial(n-1) % MOD    # 팩토리얼 계산 후 모듈러 적용

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 문제의 구조를 정확히 분석하여, (n-1)! 공식을 적용한 단순한 풀이로 해결.
#   - 첫 제출에서 통과 가능성이 매우 높음.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 핵심 개념: "모든 i>0 에 대해 complexity[0] < complexity[i]" 여야만
#     컴퓨터 0 하나로 모든 잠금 조건(j<i 이면서 복잡도 작은 j 존재)을 충족 가능.
#   - 이를 만족하지 않으면 의존성이 깨져 어떤 순서도 불가능 → 0.
#   - 조건을 만족하면 더 이상 그래프/DP가 필요 없고, 단순 조합론 문제로 귀결됨.
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도: O(n)  (조건 검사 + 팩토리얼)
#   - 공간 복잡도: O(1)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 팩토리얼 계산을 반복문이 아닌 누적 전처리(미리 팩토리얼 테이블)로 가속 가능.
#   - 그러나 n이 크지 않다면 현재 방식으로 충분히 최적.
