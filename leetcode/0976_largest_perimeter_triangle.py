# 0976_largest_perimeter_triangle.py
# -----------------------------------------------------
# ✅ 제목: Largest Perimeter Triangle (LeetCode 976)
# ✅ 문제 설명(요약):
# - 배열에서 세 변을 골라 유효한 삼각형을 만들 수 있을 때, 가능한 둘레의 최댓값을 구한다.
# - 만들 수 없다면 0을 반환한다.
#
# ✅ 입력 형식(요지):
# - nums: List[int]
#
# ✅ 규칙 요약:
# 1) 정렬 후 a ≤ b ≤ c라면 유효 조건은 a + b > c (등호 불가).
# 2) 가장 큰 변부터 연속된 세 변을 검사하면 최대 둘레를 빠르게 찾을 수 있다.
# 3) 길이 3 미만이면 0.
#
# ✅ 입출력 예시(1개):
# - nums = [2,1,2] → 5
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort()                         # 오름차순 정렬
        n = len(nums)
        i = n                               # 마지막 인덱스 기준으로 뒤에서부터 검사
        while i > 2:                        # 최소 3개 요소 필요
            if nums[i-1] < nums[i-2] + nums[i-3]:    # 삼각형 부등식(가장 큰 변 < 나머지 두 변 합)
                return nums[i-1] + nums[i-2] + nums[i-3]  # 처음 성립하는 순간이 최대 둘레
            i -= 1                          # 가장 큰 변을 하나 낮춰 다음 삼중쌍 검사
        return 0                            # 어떤 조합도 유효하지 않음

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 정렬 후 뒤에서부터 연속 3개를 검사하는 탐욕 로직으로 정답 도출.
#
# 🔧 오답 이유 및 실수(있다면) / 점검 포인트:
# - 등호(==)를 허용하면 면적 0이므로 반드시 '>'여야 함. 코드에서 '<' 비교로 올바르게 처리.
# - 인덱스 경계: while 조건을 i > 2로 두어 i-3 접근 안전.
#
# 📚 사용된/필수 개념:
# - 삼각형 부등식(정렬 상태에서 a+b>c만 검사)
# - 탐욕 + 단일 스캔: 가장 큰 변부터 확인하면 처음 만족하는 합이 최대 둘레
# - 시간복잡도: O(n log n) (정렬 지배), 공간복잡도: O(1)
#
# -----------------------------------------------------
# (선택) 다른 효율적인 풀이 또는 알고리즘 제안:
# - 내림차순 정렬 후 앞에서부터 연속 세 변을 검사해도 동일한 복잡도와 결과.
# - 정렬 없이 투 포인터로도 가능하지만 둘레 최댓값 목적에는 위 탐욕이 가장 간결.
