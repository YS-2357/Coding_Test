# 2169_Count_Operations_to_Obtain_Zero.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 2169. Count Operations to Obtain Zero
# ✅ 문제 설명(요약):
#   두 정수 num1, num2가 주어진다. 다음 연산을 반복한다:
#     - 큰 값에서 작은 값을 뺀다(>=인 쪽에서 -=).
#   둘 중 하나가 0이 될 때까지의 연산 횟수를 구한다.
#
# ✅ 입력 형식(요지):
#   num1: int, num2: int
#
# ✅ 규칙 요약:
#   - 매 스텝에서 max(num1, num2)에서 min(num1, num2)를 뺀다.
#   - 두 수 중 하나가 0이면 중단.
#   - 연산 횟수를 반환.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
class Solution:
    def countOperations(self, num1: int, num2: int) -> int:
        if num1 == 0 or num2 == 0:        # 한쪽이 0이면 더 이상 연산 불필요
            return 0
                                               
        if num1 == num2:                  # 두 수가 같으면 한 번 빼면 바로 0
            return 1

        if num1 < num2:                   # 항상 num1 >= num2 유지
            num1, num2 = num2, num1

        ans = 0                           # 연산 횟수 누적
        while num2:                       # 유클리드 호제법 형태로 반복
            ans += num1 // num2           # num1에서 num2를 몇 번 뺄 수 있는지(몫) = 한번에 묶은 연산 수
            num1, num2 = num2, num1 % num2# 다음 상태: (작은 수, 나머지)
                                          # num2가 0이 되면 종료
        return ans                        # 총 연산 횟수 반환
# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 정답 일치. 모든 기본·에지 케이스 통과.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 사용 개념: 유클리드 호제법(Euclidean Algorithm), 반복적 몫-나머지 갱신.
#   - 아이디어: "큰 값에서 작은 값을 계속 빼기"를 한 번에 합치면,
#       각 단계의 연산 횟수 = ⌊num1 / num2⌋ 이고, 다음 상태는 (num2, num1 % num2).
#     이 과정을 num2가 0이 될 때까지 반복하면 총 연산 수 = 각 단계의 몫의 합.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(log max(num1, num2)) — 유클리드 호제법과 동일.
#   - 공간: O(1).
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 재귀형:
#       count(a, b) = 0 (b=0)
#       count(a, b) = ⌊a/b⌋ + count(b, a%b)  (a ≥ b, a,b>0)
#   - 수학적 해석:
#       총 연산 수 = 유클리드 과정에서 나온 모든 몫의 합.
