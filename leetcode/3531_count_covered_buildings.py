# 3531_count_covered_buildings.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3531 - Count Covered Buildings
#
# ✅ 문제 설명(요약):
#   - n×n 격자 위에 여러 개의 건물이 있고, 각 건물의 위치가 (x, y) 형태로 주어진다.
#   - 특정 건물 (x, y)가 "covered" 되었다는 것은,
#     같은 행 y 위의 다른 건물들 사이에 x가 끼어 있고,
#     동시에 같은 열 x 위의 다른 건물들 사이에 y가 끼어 있는 경우이다.
#   - 즉, 가로/세로 모두에서 양쪽에 건물이 존재하는, 내부에 위치한 건물의 개수를 구하는 문제.
#
# ✅ 입력 형식(요지):
#   - n: 격자의 크기 (1 ~ n 까지 좌표 사용)
#   - buildings: List[List[int]] 형태의 좌표 목록, 각 원소는 [x, y] (건물 위치)
#
# ✅ 규칙 요약:
#   - 행(y) 기준: 해당 y에 있는 건물들 중 최소 x, 최대 x를 구한다.
#   - 열(x) 기준: 해당 x에 있는 건물들 중 최소 y, 최대 y를 구한다.
#   - 건물 (x, y)가 covered 되려면:
#       x_min[y] < x < x_max[y]  AND  y_min[x] < y < y_max[x]
#     를 만족해야 한다. (양 끝 건물은 포함 안 됨, strict inequality)
#
# -----------------------------------------------------
# ✅ 정답 코드(사용자 풀이; 절대 수정 금지, 주석만 추가)

class Solution:
    def countCoveredBuildings(self, n: int, buildings: List[List[int]]) -> int:
        # 각 행/열별로 건물 좌표의 최솟값/최댓값을 기록할 배열 초기화
        x_max = [0] * (n+1)        # y를 인덱스로 사용, 해당 행(y)에서의 x 최댓값
        x_min = [n+1] * (n+1)      # y를 인덱스로 사용, 해당 행(y)에서의 x 최솟값
        y_max = [0] * (n+1)        # x를 인덱스로 사용, 해당 열(x)에서의 y 최댓값
        y_min = [n+1] * (n+1)      # x를 인덱스로 사용, 해당 열(x)에서의 y 최솟값

        # 1차 스캔: 모든 건물에 대해 행/열별 최소·최대 좌표를 갱신
        for x, y in buildings:
            x_max[y] = max(x_max[y], x)   # 행 y에서 x의 최댓값 갱신
            x_min[y] = min(x_min[y], x)   # 행 y에서 x의 최솟값 갱신
            y_max[x] = max(y_max[x], y)   # 열 x에서 y의 최댓값 갱신
            y_min[x] = min(y_min[x], y)   # 열 x에서 y의 최솟값 갱신

        ans = 0
        # 2차 스캔: 각 건물이 양쪽에 이웃을 가지는지(covered) 조건 확인
        for x, y in buildings:
            # 같은 행(y)에서 왼쪽/오른쪽에 다른 건물이 존재해야 하므로:
            #   x_min[y] < x < x_max[y]
            # 같은 열(x)에서 아래/위에 다른 건물이 존재해야 하므로:
            #   y_min[x] < y < y_max[x]
            if x_min[y] < x < x_max[y] and y_min[x] < y < y_max[x]:
                ans += 1   # 두 조건을 모두 만족하면 covered 건물로 카운트
        
        return ans         # 최종 covered 건물의 개수 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 행/열 별로 최소/최댓값을 미리 계산한 뒤,
#     각 건물이 그 사이에 strictly 포함되는지 검사하는 방식으로 풀이.
#   - 로직이 간단하며, 별도의 복잡한 자료구조 없이도 모든 건물을 선형 시간에 처리 가능.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 잠재적 실수 포인트:
#       - 경계 포함 여부: "사이에 있다"는 것은 양 끝 건물이 아니라 내부여야 하므로
#         <=, >=가 아닌 <, >를 사용해야 한다.
#       - 좌표 인덱싱: 1~n 범위를 사용하는데 배열을 0~n까지 만들고, 인덱스를 그대로 사용하는 방식.
#   - 사용한 개념:
#       - 각 축(행/열)에 대해 최소/최대 좌표만 알면,
#         한 점이 내부에 있는지 O(1)로 파악 가능하다는 아이디어.
#       - 결국, 모든 건물에 대해 O(1) 체크 → 전체 O(m) (m: 건물 수).
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도:
#       - 한 번 순회하며 min/max 갱신: O(m)
#       - 다시 한 번 순회하며 조건 검사: O(m)
#       - 전체: O(m)
#   - 공간 복잡도:
#       - x_min, x_max, y_min, y_max 배열 4개: O(n)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 현재 풀이가 이미 최적인 수준(O(m + n))이라,
#     일반적인 입력 크기에서는 더 복잡한 자료구조(세그먼트 트리, 펜윅 트리 등)는 불필요하다.
#   - 만약 좌표가 훨씬 크고 희소하다면, 해시맵으로 각 행/열의 min/max를 관리하는 방식도 가능하다.
