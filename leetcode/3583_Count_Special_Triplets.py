# 3583_Count_Special_Triplets.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3583. Count Special Triplets
# -----------------------------------------------------
# ✅ 문제 설명(요약):
#   - 정수 배열 nums가 주어진다.
#   - 어떤 (i, j, k)가 조건을 만족할 때 이를 "special triplet"이라 하고,
#     이러한 triplet의 개수를 10^9+7로 나눈 값을 구하는 문제이다.
#   - 이 풀이는 에디토리얼 아이디어를 기반으로,
#     각 원소를 가운데 원소로 두고, 앞/뒤 구간의 빈도를 이용해
#     조건을 만족하는 (i, j, k)를 효율적으로 세는 방식이다.
#
# ✅ 입력 형식(요지):
#   - nums: List[int]
#       · 길이 n인 정수 배열.
#
# ✅ 규칙 요약(코드 관점에서의 해석):
#   - 배열을 순회하면서, 각 원소 n을 j 위치(= 가운데 원소)로 보고:
#       · target = 2 * n 을 기준으로,
#       · j 이전 구간에서 값이 target인 원소 개수 (freq_prev[target])
#       · j 이후 구간에서 값이 target인 원소 개수 (freq_next[target])
#     를 곱해 해당 j를 가운데로 갖는 special triplet 수를 계산한다.
#   - 모든 j에 대해 이를 합산한 뒤, MOD = 10^9 + 7로 나눈 값을 결과로 반환한다.
#
# -----------------------------------------------------
# ✅ 정답 코드 (나의 최종 풀이; 절대 수정 금지, 주석만 추가)
# -----------------------------------------------------

class Solution:
    def specialTriplets(self, nums: List[int]) -> int:
        MOD = 10**9 + 7                 # 결과를 나눌 모듈러
        freq_prev, freq_next = Counter(), Counter(nums)
        # freq_prev: 현재 인덱스 이전 구간에 등장한 값들의 빈도
        # freq_next: 현재 인덱스 이후(포함) 구간에 등장한 값들의 빈도 (초기에는 전체)

        ans = 0                          # 정답(특별한 triplet 수)을 누적할 변수
        for n in nums:                   # nums를 왼쪽에서 오른쪽으로 한 번 순회
            target = 2 * n               # 가운데 값 n을 기준으로 사용할 타깃 값

            # 현재 위치의 값 n을 "가운데 원소"로 사용하려 하므로,
            # freq_next에서는 "아직 처리되지 않은 뒤쪽 구간"에 n이 있다고 가정하고,
            # 이 위치를 지나갈 때 n을 하나 제거하여 "앞으로는 뒤쪽에 없다"고 처리.
            freq_next[n] -= 1

            # 현재 원소 n을 가운데로 두었을 때,
            #   · 앞쪽에서 값이 target인 개수: freq_prev[target]
            #   · 뒤쪽에서 값이 target인 개수: freq_next[target]
            # 이 둘의 곱이, 이 n을 가운데로 갖는 special triplet의 개수가 된다.
            ans = (ans + freq_next[target] * freq_prev[target]) % MOD

            # 이제 n은 앞으로 "이전 구간"에 포함되므로 freq_prev에 반영
            freq_prev[n] += 1

        return ans                       # 누적된 special triplet 수 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 전체 배열을 한 번 순회하면서,
#     각 위치를 "가운데 j"로 두고, 이전/이후 구간의 빈도 정보를 이용해
#     special triplet 개수를 O(1)로 갱신하는 방식으로 정답을 계산하였다.
#   - Counter 두 개(freq_prev, freq_next)를 사용하여 각 값의 등장 횟수를 관리한다.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - (잠재적인 오답 시도)
#       · 세 인덱스 (i, j, k)를 삼중 반복문으로 모두 탐색하면 O(n^3)로 시간 초과가 발생한다.
#   - 이 풀이에서 사용한 핵심 개념:
#       1) 빈도 카운팅(Frequency counting):
#          - freq_prev: j보다 앞에 있는 값들의 빈도
#          - freq_next: j 포함 이후에 있는 값들의 빈도
#       2) 한 번의 선형 순회:
#          - j를 왼쪽에서 오른쪽으로 옮기면서,
#            "현재 j를 가운데로 하는 triplet 수"를 freq_prev와 freq_next에서 바로 계산.
#       3) 누적 갱신:
#          - j 위치를 지나갈 때마다 freq_next[n]을 감소시키고,
#            freq_prev[n]을 증가시켜 경계를 이동.
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도:
#       · nums를 한 번 순회 → O(n)
#       · Counter 접근은 평균적으로 O(1) → 전체 O(n).
#   - 공간 복잡도:
#       · freq_prev, freq_next에 서로 다른 값 개수만큼 저장 → O(m) (m은 서로 다른 값의 수, m ≤ n)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 값의 범위가 작다면 배열을 이용한 카운팅 배열로 대체해
#     상수 계수를 더 줄일 수 있다.
#   - 혹은 정렬/투 포인터 기반 접근도 생각해볼 수 있으나,
#     현재 해법은 Counter를 활용한 가장 직관적이고 효율적인 O(n) 풀이에 해당한다.
# -----------------------------------------------------
