# 799_Champagne Tower.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 799. Champagne Tower
# 🏷️ 유형: DP / 시뮬레이션 / 누적 분배
#
# ✅ 문제 설명(요약):
#   - 꼭대기 잔(0,0)에 poured 만큼 샴페인을 붓는다.
#   - 각 잔은 최대 1.0만 담을 수 있고, 초과분은 아래 두 잔으로 동일하게 절반씩 흘러내린다.
#   - query_row, query_glass 위치의 잔에 담긴 양(최대 1.0)을 반환한다.
#
# ✅ 입력 형식(요지):
#   - poured: int
#   - query_row: int
#   - query_glass: int
#
# ✅ 규칙 요약:
#   - 잔 (r,c)의 용량은 1.0이며, tower[r][c] > 1이면 초과분만 아래로 전달한다.
#   - 초과분은 (tower[r][c] - 1.0) / 2.0 이고, (r+1,c)와 (r+1,c+1)에 더해진다.
#   - query_row까지만 시뮬레이션하면 query 위치 값을 얻을 수 있다.
#
# 🧠 핵심 불변식(Invariant):
#   - tower[r][c]는 “r행 c열 잔에 현재까지 도달한 총 샴페인 양”을 저장한다.
#   - 각 잔을 처리할 때, 1.0을 넘는 부분만 아래로 흘려 보내며, 잔 자체는 1.0으로 캡핑한다.
#   - 위에서 아래로 행 순서대로 처리하면, 아래 행의 입력이 누락되지 않는다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                                     # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:  # query 위치의 샴페인 양을 반환하는 함수
        tower = [[0] * 102 for _ in range(102)]                     # 충분한 크기의 DP 테이블(탑)을 0으로 초기화
        tower[0][0] = poured                                        # 꼭대기 잔에 poured만큼 붓기
        
        for r in range(query_row + 1):                              # query_row까지 각 행을 순회
            for c in range(r + 1):                                  # 해당 행의 유효한 잔(0..r)을 순회
                if tower[r][c] > 1:                                 # 잔의 용량(1.0)을 초과하면
                    excess = (tower[r][c] - 1.0) / 2.0              # 초과분을 절반으로 나눠 아래로 흘릴 양 계산
                    tower[r][c] = 1                                 # 현재 잔은 최대치 1.0으로 캡핑
                    tower[r+1][c] += excess                         # 왼쪽 아래 잔으로 초과분을 전달
                    tower[r+1][c+1] += excess                       # 오른쪽 아래 잔으로 초과분을 전달
                    
        return tower[query_row][query_glass]                        # query 위치에 남아있는 최종 양을 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: DP 테이블로 각 잔의 유입량을 누적하고, 초과분만 아래로 분배하는 시뮬레이션.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(query_row^2)  (삼각형 영역 순회)
#   - 공간: O(1)~O(query_row^2) 수준(구현은 고정 102×102 테이블 사용)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 행 단위 1차원 DP로 줄여 공간을 O(query_row)로 최적화할 수 있다(개념만).
