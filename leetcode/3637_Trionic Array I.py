# 3637_Trionic Array I.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3637. Trionic Array I
# 🏷️ 유형: 배열 / 단조 구간 판별 / 기울기 변화(턴) 카운팅
#
# ✅ 문제 설명(요약):
#   - nums가 “trionic” 조건을 만족하는지 판별한다.
#   - 인접 원소가 같으면 즉시 실패한다.
#   - 전체가 3개의 단조 구간으로 나뉘는 형태(방향 전환이 정확히 2번 발생)를 만족해야 한다.
#
# ✅ 입력 형식(요지):
#   - nums: List[int]
#
# ✅ 규칙 요약:
#   - 시작은 반드시 증가( nums[0] < nums[1] )여야 한다.
#   - 인접 원소가 같으면 False.
#   - 기울기(증가/감소) 방향이 바뀌는 횟수를 세어, 총 구간 수가 정확히 3이어야 한다.
#
# 🧠 핵심 불변식(Invariant):
#   - (nums[i-2] - nums[i-1])와 (nums[i-1] - nums[i])의 곱이 음수이면,
#     두 차분의 부호가 다르므로 “증가↔감소” 방향 전환이 발생한 것이다.
#   - cnt는 현재까지 확인된 단조 구간의 개수를 의미하며,
#     시작 구간을 1로 두고 방향 전환이 있을 때마다 1씩 증가한다.
#   - 최종적으로 cnt == 3이면 정확히 3구간(전환 2번) 조건을 만족한다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                                     # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def isTrionic(self, nums: List[int]) -> bool:                   # trionic 여부를 True/False로 반환하는 함수
        n = len(nums)                                               # 배열 길이를 저장

        if nums[0] >= nums[1]:                                      # 시작이 증가가 아니면(같거나 감소면)
            return False                                            # 조건 위반이므로 False 반환

        cnt = 1                                                     # 시작 단조 구간을 1개로 카운트
        for i in range(2, n):                                       # i=2부터 끝까지 순회하며 방향 전환을 검사
            if nums[i-1] == nums[i]:                                # 인접 원소가 같으면
                return False                                        # 즉시 실패 조건이므로 False 반환
            
            if (nums[i-2] - nums[i-1]) * (nums[i-1] - nums[i]) < 0: # 연속 차분의 부호가 달라 방향 전환이면
                cnt += 1                                            # 단조 구간 수를 1 증가
        
        return cnt == 3                                             # 최종 단조 구간 수가 3이면 True, 아니면 False

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: 차분 부호 변화(턴) 카운팅으로 단조 구간 개수 판별.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(n)  (한 번 순회)
#   - 공간: O(1)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 증감 상태(inc/dec)를 명시적으로 두고 구간을 단계별로 소비하는 3포인터 방식도 가능하다(개념만).
