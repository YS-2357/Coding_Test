# 2536_Increment_Submatrices_by_One.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 2536. Increment Submatrices by One
# ✅ 문제 설명(요약):
#   - n×n 영행렬에서, 각 쿼리 [r1, c1, r2, c2]에 대해 부분행렬 (r1..r2, c1..c2)을 모두 +1 증가시킨다.
#   - 모든 쿼리 적용 후의 최종 행렬을 반환한다.
#
# ✅ 입력 형식(요지):
#   - n: int
#   - queries: List[List[int]]  (각 원소는 [r1, c1, r2, c2])
#
# ✅ 규칙 요약:
#   - 쿼리 수가 많고 n도 클 수 있으므로, 매 쿼리마다 전 구간을 직접 더하면 TLE.
#   - 2D 차분 배열(diff)로 각 쿼리를 O(1)에 기록하고, 최종적으로 2D prefix sum(누적합)으로 복원.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
class Solution:
    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:
        diff = [[0] * (n + 1) for _ in range(n + 1)]          # (n+1)×(n+1) 차분 배열(경계 처리용 패딩)

        for r1, c1, r2, c2 in queries:                         # 각 쿼리에 대해 2D 차분 기록
            diff[r1][c1] += 1                                  # 좌상단 +1
            diff[r2+1][c1] -= 1                                # 하한 경계 아래 -1
            diff[r1][c2+1] -= 1                                # 우측 경계 오른쪽 -1
            diff[r2+1][c2+1] += 1                              # 우하단 바깥 +1 (상쇄용)

        mat = [[0] * n for _ in range(n)]                      # 결과 행렬
        for i in range(n):                                     # 2D 누적합(가우스 사각형 공식)로 복원
            for j in range(n):
                up = mat[i - 1][j] if i > 0 else 0             # 위쪽 누적
                left = mat[i][j - 1] if j > 0 else 0           # 왼쪽 누적
                diag = mat[i - 1][j - 1] if i > 0 and j > 0 else 0  # 겹친 영역 보정
                mat[i][j] = diff[i][j] + up + left - diag      # 포함-배제 원리로 최종값 복원

        return mat                                             # 모든 쿼리 적용 후 최종 행렬 반환
# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 2D 차분 + 2D 누적합으로 모든 쿼리를 O(1) 기록, O(n^2) 복원.
#   - 직관적 구현과 일치하며 예제 통과.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 사용 개념: 2차원 차분 배열(Diff 2D), 2차원 누적합(Prefix Sum 2D), 포함-배제.
#   - 핵심 아이디어:
#       • 사각형 시작점에서 +1, 경계 밖에서 -1을 배치해 “효과만” 기록
#       • 이후 up+left−diag 누적으로 실제 값 복원
#
# 📚 시간·공간 복잡도:
#   - 시간: O(n^2 + Q) (Q는 쿼리 수; 기록 O(Q), 복원 O(n^2))
#   - 공간: O(n^2) (diff와 결과 행렬)
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 메모리 감소가 필요하면 행 단위로 누적 처리하되, 열 누적 시 별도 버퍼를 재사용.
#   - 여러 값으로 증가(가중치)하는 변형도 동일하게 ±k로 차분 기록 가능.
