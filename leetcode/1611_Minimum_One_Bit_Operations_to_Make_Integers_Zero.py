# 1611_Minimum_One_Bit_Operations_to_Make_Integers_Zero.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 1611. Minimum One Bit Operations to Make Integers Zero
# ✅ 문제 설명(요약):
#   정수 n을 0으로 만들기 위한 최소 연산 횟수를 구한다.
#   허용 연산:
#     (1) 0번째 비트(가장 오른쪽 비트) 반전
#     (2) i번째 비트 반전: 단, 0..(i-2)비트는 모두 0이고 (i-1)비트가 1이어야 함
#   목적: 위 규칙만 사용하여 n → 0로 만드는 최소 연산 횟수 반환.
#
# ✅ 입력/출력 형식:
#   입력: n: int
#   출력: int  (최소 연산 횟수)
#
# ✅ 제약:
#   0 <= n <= 10^9
#
# ✅ 규칙 요약:
#   - 연산 규칙은 Gray code 전이와 동치 → n을 0으로 되돌리는 단계 수 = n의 Gray 순서 인덱스
#   - 재귀 성질: 최상위 1비트(2^m)를 기준으로
#       f(n) = (2^(m+1) - 1) - f(n - 2^m)
#     (여기서 m = floor(log2(n)))
#
# ✅ 정답 코드(나의 풀이; 각 줄 주석)  ※ 비트연산을 사용한 참고 공식을 그대로 구현
class Solution:
    def minimumOneBitOperations(self, n: int) -> int:
        def f(n):                                  # f(n): n을 0으로 만드는 최소 연산 횟수
            if n == 0:                             # n=0이면 연산 필요 없음
                return 0
            msb = n.bit_length() - 1               # m = floor(log2(n)) (최상위 1비트의 위치)
            mask = 1 << msb                        # 2^m
            # (2^(m+1)-1)는 0..m 비트를 모두 토글하는 데 필요한 총 단계 수
            # n에서 최상위 비트를 내린 나머지(n ^ 2^m)에 대해 재귀적으로 계산한 값을 빼서 최소값을 얻음
            return (1 << (msb + 1)) - 1 - f(n ^ mask)
        return f(n)                                 # 최종 결과 반환
# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 소수 예제 및 대다수 랜덤 케이스에서 정답 일치.
#   - 재귀 깊이는 n의 비트수 O(log n) 이내.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 사용 개념: Gray code 성질, 분할 정복 재귀
#   - 핵심 아이디어:
#       • 최상위 1비트가 2^m일 때, 그 비트를 0으로 만들려면
#         0..m 비트를 모두 순회하는 데 (2^(m+1)-1) 단계가 필요.
#       • 그러나 n의 하위 부분(n - 2^m)을 다시 되돌리는 비용을 상쇄하므로
#         f(n) = (2^(m+1)-1) - f(n - 2^m).
#       • 코드에서는 n.bit_length, 시프트, XOR로 이를 구현.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(log n)  (비트 길이만큼 재귀)
#   - 공간: O(log n)  (재귀 스택)
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - “숫자만”으로 동일 재귀를 구현하려면:
#       1) m = floor(log2(n))를 수치적으로 구함 (예: while p*2 <= n: p*=2 로 p=2^m)
#       2) f(n) = (2*p - 1) - f(n - p) 를 재귀/반복으로 계산
#     → 비트연산 대신 거듭제곱 p(=2^m)만 유지해도 동일한 공식으로 O(log n)에 계산 가능.
