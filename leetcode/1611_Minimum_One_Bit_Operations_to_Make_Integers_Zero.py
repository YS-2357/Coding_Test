# 1611_Minimum_One_Bit_Operations_to_Make_Integers_Zero.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 1611. Minimum One Bit Operations to Make Integers Zero
# ✅ 문제 설명(요약):
#   정수 n을 0으로 만들기 위한 최소 연산 횟수를 구한다.
#   허용 연산:
#     (1) 0번째 비트(최하위 비트) 반전
#     (2) i번째 비트 반전 (단, 0..(i-2) 비트는 모두 0이고, (i-1)번째 비트가 1이어야 함)
#   목표: 위 규칙으로 n → 0 변환 시 최소 연산 횟수 반환.
#
# ✅ 입력 형식(요지):
#   n: int  (0 <= n <= 1e9)
#
# ✅ 규칙 요약:
#   - 비트 인덱스는 오른쪽에서 0부터.
#   - 상위 비트를 바꾸려면 하위 비트가 00..01 형태여야 함.
#   - 최적 해는 Gray code 성질과 동일:
#       f(n) = n을 0으로 만드는 최소 연산 수
#       재귀식: f(n) = (2^{msb+1} - 1) - f(n ^ (1<<msb)), n>0
#     또는 누적식: f(n) = n ^ (n>>1) ^ (n>>2) ^ ...
#
# ✅ 정답 코드(참고 풀이; 나의 아이디어 아님, 수정 금지 / 한 줄마다 주석)
class Solution:
    def minimumOneBitOperations(self, n: int) -> int:
        def f(n):
            if n == 0:
                return 0                      # 기저: 0은 이미 0
            msb = n.bit_length() - 1          # 최상위 1비트의 인덱스(msb)
            mask = 1 << msb                   # msb 위치의 단일 비트 마스크
            # (2^{msb+1}-1)는 1000..0(길이 msb+1)을 0으로 만드는 최소 연산
            # n에서 msb를 토글한 n^(1<<msb)로 문제를 축소하여 대칭적으로 계산
            return (1 << (msb + 1)) - 1 - f(n ^ mask)
        return f(n)                            # 최종 결과 반환
# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 소형 케이스 검증 일치: f(0)=0, f(1)=1, f(2)=3, f(3)=2, f(4)=7, f(6)=4 등.
#   - 규칙 이해: 상위 비트를 바꿀 때 하위 비트 패턴이 강제되어 Gray code 단계와 일치.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 사용 개념: Gray code와 대칭성, 재귀 분할.
#   - 핵심 아이디어(참고): 최상위 비트를 기준으로
#       $$f(n) = 2^{msb+1}-1 - f(n \oplus 2^{msb})$$
#     를 반복 적용해 문제를 더 낮은 비트로 축소.
#   - 주의: 비트 연산에 낯설다면, msb를 “가장 큰 2의 거듭제곱 자리”로 이해하고
#     \(2^{msb}\)을 기준으로 좌·우 구간의 대칭을 이용하는 것으로 해석.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(log n)  (매 단계에서 msb 한 단계씩 감소)
#   - 공간: O(log n)  (재귀 스택)
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 비재귀(반복) 버전: 누적식  f(n) = n^(n>>1)^(n>>2)^(...)  를 사용해 O(log n) 반복으로 계산.
#   - 수치적 해석(비트 없이): n을 2진수로 보지 않고도,
#       “가장 큰 2의 거듭제곱 ≤ n”을 찾고 위 재귀식을 수치 연산으로만 수행 가능
#       (단, 내부적으로 같은 원리라 실질 복잡도·아이디어는 동일).
