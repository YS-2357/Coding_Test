# 1877_Minimize Maximum Pair Sum in Array.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 1877. Minimize Maximum Pair Sum in Array
# 🏷️ 유형: 정렬 / 투 포인터(대칭 페어링)
#
# ✅ 문제 설명(요약):
#   - 배열 nums에서 모든 원소를 정확히 한 번씩 사용해 n/2개의 쌍을 만든다.
#   - 각 쌍의 합 중 최댓값을 최소화하도록 쌍을 구성한다.
#   - 그때의 “최소 가능한 최대 쌍 합”을 반환한다.
#
# ✅ 입력 형식(요지):
#   - nums: List[int] (짝수 길이 배열)
#
# ✅ 규칙 요약:
#   - 각 원소는 정확히 한 번만 사용된다.
#   - 쌍의 개수는 len(nums) // 2 이다.
#
# 🧠 핵심 불변식(Invariant):
#   - 가장 작은 값과 가장 큰 값을 한 쌍으로 묶는 것이 최대 쌍 합을 최소화한다.
#   - 정렬 후 양 끝에서 안쪽으로 페어링하면, 모든 쌍 중 최대 합이 최솟값이 된다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                                     # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def minPairSum(self, nums: List[int]) -> int:                   # 최소 가능한 최대 쌍 합을 반환하는 함수
        nums.sort()                                                 # 배열을 오름차순으로 정렬
        ans = 0                                                     # 현재까지의 최대 쌍 합을 저장할 변수 초기화

        for i in range(len(nums) // 2):                             # 배열의 절반 길이만큼 인덱스 i를 순회
            ans = max(ans, nums[i] + nums[-1 - i])                  # i번째 최소값과 i번째 최대값의 합으로 최대 쌍 합을 갱신
        
        return ans                                                  # 계산된 최소 가능한 최대 쌍 합을 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: 정렬 후 양 끝 원소를 묶는 그리디 페어링 전략.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(n log n)  (정렬 비용)
#   - 공간: O(1)        (제자리 정렬 기준 추가 공간 없음)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 계수 정렬이 가능한 범위라면 O(n) 시간으로도 해결할 수 있다(개념만).
