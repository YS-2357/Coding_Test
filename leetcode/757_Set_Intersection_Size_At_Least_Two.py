# 757_Set_Intersection_Size_At_Least_Two.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 757. Set Intersection Size At Least Two
# ✅ 문제 설명(요약):
#   - intervals[i] = [start_i, end_i] 꼴의 닫힌 구간들이 여러 개 주어진다.
#   - 어떤 정수 집합 S를 선택했을 때, 모든 구간 interval[i]에 대해
#       |S ∩ [start_i, end_i]| ≥ 2
#     즉, "각 구간마다 S 안에 그 구간에 속하는 정수가 최소 2개 이상"이 되도록 해야 한다.
#   - 이러한 집합 S 중에서, 원소의 개수가 최소가 되도록 할 때 그 크기를 반환하는 문제이다.
#
# ✅ 입력 형식(요지):
#   - intervals: List[List[int]]
#     - 각 원소는 [start, end] 형태의 두 정수.
#     - 0 <= start < end <= 10^8
#     - intervals.length <= 3000 (문제 조건 참조)
#
# ✅ 규칙 요약:
#   - 모든 구간 [s, e]에 대해, S 안에 포함된 정수들 중 [s, e] 범위에 있는 것이 2개 이상이 되어야 한다.
#   - S의 크기를 최소화해야 하므로,
#     - 가능한 한 같은 점(정수)을 여러 구간에서 재사용하는 것이 중요하다.
#   - 전형적인 풀이 전략:
#     - 구간을 끝점 기준으로 정렬 (end 오름차순, start 내림차순)
#     - "지금까지 선택한 점들 중 가장 큰 두 개"를 관리하면서,
#       각 구간을 순회할 때 그 구간 안에 이미 몇 개가 들어와 있는지 세고,
#       부족한 개수(0 또는 1개)만큼 오른쪽 끝에서부터 새 점을 추가하는 그리디 전략을 사용한다.
#
# ✅ 정답 코드(나의 원본 풀이; 절대 수정 금지)
#   - 아래 코드는 위 그리디 전략을 구현한 것으로,
#     intervals를 정렬한 뒤, 각 구간을 순서대로 보면서
#     "현재까지 선택한 점(prev1, prev2)이 이 구간에 몇 개 포함되는지"를 계산하고,
#     부족한 만큼만 새 점(e, e-1)을 추가하는 방식이다.

class Solution:
    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:
        intervals.sort(key=lambda x: (x[1], -x[0]))
        # intervals를 (끝점 오름차순, 시작점 내림차순)으로 정렬
        # - 끝점이 작은 구간부터 처리하면, 오른쪽 끝에 찍는 점들이
        #   이후의 구간에도 재사용될 가능성이 커진다.
        # - 같은 끝점을 가진 구간들에서는 시작점을 큰 것부터 처리함으로써
        #   더 긴 구간이 나중에 오도록 한다(그리디 전략에 유리).

        ans = 0
        prev1, prev2 = 10 ** 8  + 1,  10 ** 8  + 1
        # 지금까지 선택한 점들 중 "가장 큰 두 점"을 prev1, prev2로 관리
        # - 초기값은 모든 가능한 구간 범위 밖(10^8+1)으로 설정하여
        #   어떤 구간에도 포함되지 않도록 함.
        # - 관례상 prev1: 가장 큰 점, prev2: 두 번째로 큰 점을 의미하도록 유지.

        for s, e in intervals:
            # 각 구간 [s, e]에 대해,
            # 이미 선택한 점(prev1, prev2) 중 몇 개가 이 구간 안에 들어있는지 센다.
            cnt = 0
            if s <= prev1 <= e:
                cnt += 1  # prev1이 현재 구간 [s, e] 안에 포함되면 카운트 증가
            if s <= prev2 <= e:
                cnt += 1  # prev2도 포함되면 추가로 카운트 증가

            if cnt == 2:
                # 이미 이 구간 안에 선택된 점이 2개 이상 있으므로
                # 새로운 점을 추가할 필요가 없음.
                continue
            elif cnt == 1:
                # 이 구간 안에는 현재까지 선택된 점이 1개만 있으므로,
                # 하나만 더 추가하면 된다.
                # 그리디 전략상, "가장 오른쪽 끝 e"에 점을 추가하는 것이
                # 이후 구간들에도 재사용될 가능성이 높다.
                prev1, prev2 = e, prev1
                # e를 가장 큰 점(prev1)으로 두고,
                # 기존의 prev1를 prev2로 내려 배치.
                # (현재 코드에서는 어떤 점이 실제로 구간 안에 있었는지는
                #  별도로 구분하지 않고 단순히 prev1/prev2를 재배치하는 방식으로 처리.)
                ans += 1
            elif cnt == 0:
                # 이 구간 안에 선택된 점이 하나도 없으므로,
                # 이 구간을 만족시키기 위해 최소 2개의 점을 새로 추가해야 한다.
                # 그리디 전략상, 가장 오른쪽 두 점인 (e-1, e)를 선택하는 것이
                # 뒤에 나올 구간들에서 재사용성을 극대화하는 선택이다.
                prev1, prev2 = e, e - 1
                # 가장 큰 점(prev1) = e, 두 번째 점(prev2) = e-1로 설정한다.
                ans += 2
        return ans
        # ans에는 지금까지 추가한 점 개수(집합 S의 크기)가 누적되어 있으며,
        # 모든 구간이 |S ∩ interval| ≥ 2 를 만족하도록 만든 최소 크기이다.

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 구간을 (끝점 오름차순, 시작점 내림차순) 정렬한 뒤,
#     현재까지 선택한 점 중 가장 큰 두 개(prev1, prev2)를 유지하면서
#     각 구간에 대해 이미 포함된 점의 개수(cnt)를 세고,
#     부족한 만큼만 오른쪽 끝에서 채워 넣는 그리디 아이디어를 코드로 구현하였다.
#   - cnt == 2인 경우: 이미 이 구간에는 충분한 점이 있으므로 아무 것도 하지 않음.
#   - cnt == 1인 경우: e를 새로 선택하여 하나만 추가.
#   - cnt == 0인 경우: (e-1, e)를 새로 선택하여 두 개 추가.
#   - 이러한 방식으로 모든 구간을 처리하여, 전체적으로 필요한 점의 수(ans)를 구한다.

# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 알고리즘 개념:
#     1) 구간 정렬 + 그리디(Interval scheduling 계열):
#        - 끝점 기준 정렬은 "가장 일찍 끝나는 구간부터 처리"하는 전형적인 패턴으로,
#          이후에 나오는 구간들과의 겹침을 최대화하여 선택한 점을 재사용하려는 전략이다.
#     2) "현재까지 선택한 점 중 가장 큰 두 점" 관리:
#        - 각 구간이 최소 2개의 교점을 가져야 하므로, 전역적으로 모든 점을 기억할 필요 없이
#          "가장 오른쪽에 있는 두 점"만으로도 이후 구간에 대한 커버 여부를 추적할 수 있다.
#     3) 부족한 개수만 채우는 그리디:
#        - 이미 구간 안에 포함된 점의 개수를 세고,
#          부족한 만큼(0, 1, 2)만 오른쪽 끝에서 채워 넣으면 항상 최적해를 만든다.
#   - 이 풀이 자체는 그리디 정해 아이디어에 해당하며,
#     시간 복잡도와 풀이 구조 면에서 문제 조건을 만족하는 효율적인 해법이다.
#   - 구현 세부에서는 prev1/prev2가 "항상 가장 큰 두 점"이라는 불변식을 유지하도록 설계되어 있으며,
#     각 구간 처리 시에는 포함 여부만 판별해 cnt 값을 갱신한다.

# 📚 시간·공간 복잡도:
#   - 시간 복잡도:
#     - intervals.sort(...)    → O(n log n)
#     - for s, e in intervals: → O(n) (각 구간당 상수 시간 연산)
#     - 전체 시간: O(n log n)
#   - 공간 복잡도:
#     - intervals 정렬은 제자리에서 이뤄진다고 가정하면,
#       추가로 사용하는 변수는 ans, prev1, prev2, s, e, cnt 정도로 상수 개수.
#     - 전체 공간: O(1) (입력 intervals 외 추가 메모리는 상수)

# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 집합(Set)에 실제로 선택한 모든 점을 저장한 뒤,
#     각 구간마다 "구간 안에 포함된 점이 몇 개 있는지"를 매번 검사하고 부족한 만큼 새로 추가하는 방법도 있다.
#     - 다만 이 경우, 매번 포함 여부를 확인하는 과정에서 시간/공간 비용이 증가할 수 있다.
#   - 현재 풀이처럼 "가장 오른쪽 두 점(prev1, prev2)"만 관리하는 방식은
#     이 문제 구조에서 사실상 최적에 해당하며,
#     시간복잡도 O(n log n), 공간복잡도 O(1)로 동작하는 것이 장점이다.
