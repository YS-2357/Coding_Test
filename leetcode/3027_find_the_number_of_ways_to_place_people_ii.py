# 3027_find_the_number_of_ways_to_place_people_ii.py
# -----------------------------------------------------
# ✅ 제목: Find the Number of Ways to Place People II (LeetCode 3027)
# ✅ 문제 설명(요약):
# - 주어진 평면 점 집합에서 두 점 (xi, yi), (xj, yj)을 선택.
# - 이 두 점을 직사각형의 좌상단과 우하단으로 했을 때,
#   직사각형 내부 및 경계에 다른 점이 없어야 유효한 쌍으로 센다.
# - 가능한 유효 쌍의 개수를 반환.
#
# ✅ 입력 형식(요지):
# - points: List[List[int]], 각 점은 [xi, yi], 모든 점은 유일.
#
# ✅ 규칙 요약:
# 1) 직사각형 좌상단(A)은 x가 작고 y가 커야 함.
# 2) 직사각형 내부와 경계에는 제3의 점이 존재하면 안 됨.
# 3) 유효한 쌍만 카운트.
#
# ✅ 입출력 예시(1개):
# - 입력: points = [[1,5],[2,4],[3,3]]
# - 가능한 쌍: (1,5)-(2,4) → 내부/경계에 다른 점 없음
# - (1,5)-(3,3)은 (2,4)가 포함되어 불가능
# - 출력: 1
#
# ✅ 정답 코드(나의 풀이; 한 줄마다 주석):
class Solution:
    def numberOfPairs(self, points: List[List[int]]) -> int:
        # x 오름차순, y 내림차순 정렬 → 동일 x일 때 위쪽 점이 먼저 옴
        points.sort(key=lambda x: (x[0], -x[1]))
        n = len(points)
        answer = 0

        for i in range(n):
            maxY = -10**9 - 1                # 초기값: 충분히 작은 값
            yi = points[i][1]                # 기준 점의 y좌표
            for j in range(i+1, n):
                yj = points[j][1]
                # 조건: (1) j가 i보다 아래 있어야 함 (yj ≤ yi)
                #      (2) 지금까지 본 후보들보다 아래쪽에서 새롭게 열림 (yj > maxY)
                if yj <= yi and yj > maxY:
                    answer += 1
                    maxY = yj                 # 막는 경계 갱신
        return answer

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 올바른 정렬 + maxY 불변 조건으로 Accepted.
#
# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - 단순히 yi ≥ yj만 검사하면 직사각형 내부/경계에 다른 점이 있어도 카운트됨.
# - maxY를 두어 i와 j 사이에 끼어드는 점을 자동 배제하도록 수정.
# - 조건을 yj > maxY로 설정해야 경계/중복 제거가 정확히 동작함.
#
# 📚 사용된/필수 개념(최소):
# - 점 정렬 (x↑, y↓) → 동일 x 처리 안전.
# - 스캔 중 maxY 불변량으로 내부/경계 점 배제.
# - 시간복잡도: O(n^2), 공간복잡도: O(1).
