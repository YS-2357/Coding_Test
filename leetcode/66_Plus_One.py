# 66_Plus_One.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 66. Plus One
# ✅ 문제 설명(요약):
#   - 비음수 정수를 각 자릿수로 나눈 배열 digits가 주어진다.
#   - 이 정수에 1을 더한 결과를 다시 자릿수 배열 형태로 반환한다.
#   - 가장 왼쪽이 가장 높은 자릿수이며, 선행 0은 없다.
#
# ✅ 입력 형식(요지):
#   - digits: List[int], 각 원소는 0~9 사이의 한 자리 숫자
#
# ✅ 규칙 요약:
#   - 배열이 표현하는 정수에 +1 연산을 수행한다.
#   - 자리 올림(carry)이 연속으로 발생할 수 있다.
#   - 결과 자릿수가 늘어날 수 있다 (예: [9,9] → [1,0,0]).
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
#   - 아래는 사용자가 제출/채택한 최종 정답 코드이며,
#     이 단계에서는 코드 내용을 변경하지 않고,
#     각 줄마다 설명 주석만 추가한다.

class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        temp = 1                                   # 최종 정수값을 누적할 변수(초기값은 +1 반영)
        power = 0                                  # 현재 자릿수의 10의 거듭제곱 지수

        while digits:                              # digits가 빌 때까지 반복(뒤에서부터 처리)
            n = digits.pop()                       # 가장 낮은 자릿수부터 하나씩 꺼냄
            temp += n * (10 ** power)              # 해당 자릿수를 정수값으로 환산해 temp에 더함
            power += 1                             # 다음 자릿수로 이동

        return list(map(int, str(temp)))           # 계산된 정수를 문자열로 바꾼 뒤 각 자릿수를 다시 리스트로 변환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 시도에서 정답 처리됨.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 사용한 핵심 개념:
#     - 자릿수 배열을 실제 정수로 복원한 뒤 +1 수행
#     - 파이썬의 arbitrary-precision integer 특성을 활용
#   - 주의 포인트:
#     - 입력 digits 리스트를 pop으로 소모하므로, 원본 보존이 필요하면 별도 처리 필요
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도: O(n)
#     - n은 digits의 길이
#   - 공간 복잡도: O(n)
#     - 정수 → 문자열 → 리스트 변환 과정에서 자릿수 크기만큼 사용
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 실제 정수로 변환하지 않고,
#     배열 끝에서부터 carry를 전파하는 방식으로
#     O(1) 추가 공간으로도 풀이 가능하다(개념만, 코드 X).
