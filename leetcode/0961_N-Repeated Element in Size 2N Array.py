# 0961_N-Repeated Element in Size 2N Array.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 961. N-Repeated Element in Size 2N Array
# 🏷️ 유형: 해시 / 카운팅
#
# ✅ 문제 설명(요약):
#   - 길이가 2N인 배열에서 정확히 하나의 원소가 N번 반복된다.
#   - 해당 원소를 찾아 반환한다.
#
# ✅ 입력 형식(요지):
#   - nums: 길이가 2N인 정수 배열
#
# ✅ 규칙 요약:
#   - 반복되는 원소는 정확히 하나만 존재한다.
#   - N은 len(nums) // 2 로 계산된다.
#
# 🧠 핵심 불변식(Invariant):
#   - 모든 원소의 등장 횟수를 세면, 값이 N인 원소는 항상 유일하다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def repeatedNTimes(self, nums: List[int]) -> int:  # 2N 배열에서 N번 반복되는 원소를 찾는 함수
        cnt = Counter(nums)                    # 배열의 각 원소 등장 횟수를 해시맵(Counter)로 계산
        n = len(nums) // 2                     # 전체 길이의 절반 N을 계산하여 목표 반복 횟수로 설정
        
        for k, v in cnt.items():               # 각 원소(k)와 그 등장 횟수(v)를 순회
            if v == n:                         # 등장 횟수가 정확히 N인 원소인지 확인
                return k                       # 조건을 만족하는 원소를 즉시 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 바로 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: 해시맵(Counter)을 이용한 빈도 카운팅.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(n)  (배열 순회 및 카운팅)
#   - 공간: O(n)  (Counter에 원소 저장)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 배열 특성상 반복 원소는 가까운 위치에서 재등장하므로,
#     인접 원소 비교(O(1) 공간) 방식의 풀이도 가능하다 (개념 설명만).
