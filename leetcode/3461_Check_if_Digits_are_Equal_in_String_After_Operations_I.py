# 3461_Check_if_Digits_are_Equal_in_String_After_Operations_I.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3461. Check if Digits Are Equal in String After Operations I
# ✅ 문제 설명(요약):
#   문자열 s의 각 인접한 숫자를 더한 뒤 10으로 나눈 나머지를 이어붙이는 연산을 반복한다.
#   문자열의 길이가 2가 될 때까지 반복하며, 최종 두 자리가 같은 숫자인지 확인한다.
#
# ✅ 입력 형식(요지):
#   - s: 숫자로만 이루어진 문자열 (2 ≤ len(s) ≤ 100)
#
# ✅ 규칙 요약:
#   - 각 단계에서 s[i], s[i+1]의 합을 10으로 나눈 나머지를 새 문자열에 더한다.
#   - 길이가 2가 되면 두 숫자가 같은지 비교하여 True/False를 반환한다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
class Solution:
    def hasSameDigits(self, s: str) -> bool:
        # 문자열 길이가 2 이하가 될 때까지 반복
        while len(s) > 2:
            temp = ""  # 새로운 문자열을 저장할 임시 변수
            for i in range(len(s) - 1):  # 인접한 두 자리씩 확인
                digit = (int(s[i]) + int(s[i+1])) % 10  # 두 자리 합의 1의 자리 계산
                temp += str(digit)  # 문자열로 이어붙이기
            s = temp  # 새로 만든 문자열로 교체

        # 최종 두 자리가 같은 숫자인지 비교
        if s[0] == s[1]:
            return True
        else:
            return False
# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 모든 테스트케이스 정답 일치 (정상 작동)
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 문자열을 매 단계 새로 생성하며 인접 합을 반복 계산하는 단순 시뮬레이션 방식.
#   - 오류 없음. 단, 비효율적(O(n²)) 구조.
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도: O(n²)
#       (매 단계 길이 감소에 따라 (n−1)+(n−2)+...+1 연산)
#   - 공간 복잡도: O(n)
#       (각 단계에서 새 문자열 temp 생성)
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 수학적 접근: 최종 두 자리는 원본 자리수들의 이항계수 조합 mod 10으로 표현 가능.
#   - Lucas 정리와 CRT를 활용해 이항계수를 mod 10로 계산하면 O(n log n)으로 단축 가능.
