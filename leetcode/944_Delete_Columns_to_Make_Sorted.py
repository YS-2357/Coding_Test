# 944_Delete_Columns_to_Make_Sorted.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 944. Delete Columns to Make Sorted
# ✅ 문제 설명(요약):
#   - 동일 길이의 문자열 배열 strs가 주어진다.
#   - 각 열(column)을 위에서 아래로 읽었을 때, 사전순(비내림차순)으로 정렬되어 있어야 한다.
#   - 정렬 조건을 만족하지 않는 열은 삭제할 수 있으며, 최소 삭제 열 개수를 구한다.
#
# ✅ 입력 형식(요지):
#   - strs: 길이가 같은 문자열들의 리스트
#
# ✅ 규칙 요약:
#   - 각 열 j에 대해, 모든 i(0..n-2)에 대해 strs[i][j] <= strs[i+1][j] 이어야 “정렬된 열”.
#   - 어떤 한 쌍이라도 위 조건을 깨면 해당 열은 삭제해야 한다.
#   - 열 단위로 독립적으로 판단 가능(열을 삭제해도 다른 열의 정렬 조건이 바뀌지 않음).
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
#   - 아래는 사용자가 제출/채택한 최종 정답 코드이며,
#     이 단계에서는 코드 내용을 변경하지 않고,
#     각 줄마다 설명 주석만 추가한다.

class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        ans = 0                                         # 삭제해야 하는 열 개수 누적
        n, m = len(strs), len(strs[0])                  # n: 문자열 개수(행), m: 문자열 길이(열 개수)
        grid = [[ord(ch) for ch in s] for s in strs]    # 문자를 아스키(유니코드) 정수로 변환해 2D 배열로 저장

        for j in range(m):                              # 각 열 j에 대해 검사
            # (i+1행의 값 - i행의 값 >= 0) 여부를 i=0..n-2에 대해 계산한 불리언들을 set으로 모음
            # True만 있으면 "모든 쌍이 비내림차순", False가 하나라도 있으면 "정렬 위반 존재"
            temp = set(grid[i+1][j] - grid[i][j] >= 0 for i in range(n-1))

            if len(temp) == 2:                          # {True, False} 두 값이 모두 존재 -> 정렬 위반(False) 존재
                ans += 1                                # 해당 열 삭제
            elif not temp.pop():                        # set에 값이 하나뿐인데 그 값이 False인 경우 -> 전부 위반(적어도 한 쌍이 음수)
                ans += 1                                # 해당 열 삭제

        return ans                                      # 최소 삭제 열 개수 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - (기록 없음) 위 코드는 열 단위 조건을 직접 검사하여 정답 처리 가능.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 사용한 핵심 개념:
#     - 열(column) 단위 독립 검사
#     - 인접한 행 쌍에 대해 비내림차순 조건(strs[i][j] <= strs[i+1][j]) 위반 여부 확인
#   - 구현 특징:
#     - 각 열에서 비교 결과(True/False)를 set으로 모아 False 존재 여부를 판단
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도: O(n * m)
#     - 모든 열(m)에 대해 인접 행 비교(n-1)를 수행
#   - 공간 복잡도: O(n * m)
#     - grid를 별도로 구성(원문 strs를 직접 비교하면 O(1) 추가공간으로도 가능하나, 본 코드는 grid를 사용)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - grid를 만들지 않고, strs[i][j]를 직접 비교하면 공간을 O(1)로 줄일 수 있다(코드 변경 필요).
#   - set 대신, 한 번이라도 strs[i][j] > strs[i+1][j]가 나오면 즉시 ans += 1 하고 다음 열로 넘어가는
#     "조기 종료(early break)" 방식이 더 직관적이고 상수 시간이 작다(코드 변경 필요).
