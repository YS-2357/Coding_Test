# 868_Binary_Gap.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 868. Binary Gap
# 🏷️ 유형: Bit Manipulation, Simulation
#
# ✅ 문제 설명(요약):
#   - 정수 n의 이진수 표현에서 연속된 두 '1' 사이의 거리 중 최댓값을 구한다.
#
# ✅ 입력 형식(요지):
#   - n: int (양의 정수)
#
# ✅ 규칙 요약:
#   - 두 '1' 사이의 거리는 비트 인덱스 차이로 정의된다.
#   - 인접한 1이 하나도 없으면 0을 반환한다.
#
# 🧠 핵심 불변식(Invariant):
#   - max_dist는 지금까지 발견한 두 1 사이 거리의 최댓값을 유지한다.
#   - curr_dist는 마지막으로 등장한 1 이후 현재까지의 거리(비트 수)를 유지한다.
#   - found_first_one은 첫 번째 1을 이미 만났는지 여부를 나타낸다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:
    def binaryGap(self, n: int) -> int:                     # n의 이진수에서 최대 binary gap을 구하는 함수
        max_dist = 0                                        # 두 1 사이의 최대 거리를 저장할 변수
        curr_dist = 0                                       # 현재 진행 중인 거리(마지막 1 이후 비트 수)
        found_first_one = False                             # 첫 번째 1을 이미 찾았는지 여부
        
        while n > 0:                                        # 모든 비트를 처리할 때까지 반복
            bit = n % 2                                     # 현재 최하위 비트를 추출 (0 또는 1)
            
            if bit == 1:                                    # 현재 비트가 1인 경우
                if found_first_one:                         # 이전에 1을 이미 본 적이 있다면
                    max_dist = max(max_dist, curr_dist)     # 현재 거리와 기존 최대 거리 중 큰 값으로 갱신
                
                curr_dist = 1                               # 새로운 거리 계산 시작 (현재 1 포함)
                found_first_one = True                      # 첫 1을 발견했음을 표시
            else:                                           # 현재 비트가 0인 경우
                if found_first_one:                         # 첫 1을 이미 본 이후라면
                    curr_dist += 1                          # 거리 증가 (0도 거리 계산에 포함)
            
            n //= 2                                         # n을 오른쪽으로 한 비트 시프트(다음 비트 처리)
            
        return max_dist                                     # 최종적으로 계산된 최대 거리 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 정상 동작 (의도한 로직으로 최대 거리 계산 가능).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 가능한 실수:
#     - 첫 번째 1 이전의 0을 거리 계산에 포함하면 오답 발생 가능.
#     - curr_dist를 0으로 초기화하면 거리 정의와 맞지 않아 오프바이원 발생 가능.
#   - 사용 개념:
#     - 비트 연산(나머지 및 정수 나눗셈을 이용한 비트 순회)
#     - 상태 기반 시뮬레이션
#
# 📚 시간·공간 복잡도:
#   - 시간: O(log n) (비트 수만큼 반복)
#   - 공간: O(1) (상수 변수만 사용)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 비트 인덱스를 직접 추적하여 이전 1의 위치를 저장하는 방식도 가능.
#   - 내장 비트 길이/비트 마스크 연산을 활용하면 더 직관적으로 구현할 수 있다.
