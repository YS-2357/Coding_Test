# 3512_Minimum_Operations_to_Make_Array_Sum_Divisible_by_K.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3512. Minimum Operations to Make Array Sum Divisible by K
# ✅ 문제 설명(요약):
#   - 정수 배열 nums와 정수 k가 주어진다.
#   - 배열 원소에 대해 어떤 연산(예: 값을 증가/감소, 교체 등)을 수행해서,
#     전체 합(sum(nums))이 k로 나누어떨어지도록 만들고자 한다.
#   - 이때 필요한 "최소 연산 횟수"를 구하는 문제이다.
#   - 현재 코드는 단순히 sum(nums) % k 값을 반환하고 있어,
#     "연산 횟수"가 아니라 "현재 합의 나머지"만 돌려주는 상태이다.
#
# ✅ 입력 형식(요지):
#   - nums: List[int]  — 정수 배열
#   - k: int           — 나눌 기준이 되는 양의 정수
#
# ✅ 규칙 요약:
#   - 목표는 sum(nums) % k == 0 이 되도록 만드는 것.
#   - 문제에서 정의한 "연산"의 정확한 내용(허용되는 값 변경 방식)에 따라,
#     실제 최소 연산 횟수 로직은 훨씬 복잡해질 수 있다.
#   - 하지만 이 풀이에서는 그 연산 정의를 전혀 사용하지 않고,
#     단지 현재 합의 나머지만 반환하고 있다.

# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
#   - 현재 구현은 "배열의 합을 k로 나눈 나머지"를 반환하는 코드이다.
#   - 즉, 합이 k로 나누어떨어지는지(0)와, 아니라면 몇 만큼 모자라거나 넘치는지(나머지)를 알려줄 뿐이다.
#   - "최소 연산 횟수"를 계산하는 로직은 포함되어 있지 않다.

class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        return sum(nums) % k              # 현재 배열 합의 k에 대한 나머지를 그대로 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - sum(nums) % k를 계산해 반환함으로써,
#     "현재 합이 k로 나누어떨어지는지 여부"는 알 수 있다.
#   - 하지만 문제에서 요구하는 것은
#     "합을 k로 나누어떨어지게 만들기 위해 필요한 최소 연산 횟수"이며,
#     그 연산 정의(예: 원소를 1씩 증가/감소, 다른 값으로 치환 등)를 고려해야 한다.
#   - 따라서 이 코드는 문제의 요구사항을 충족시키지 못한다.

# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답/실수:
#       1) 리턴값의 의미 혼동:
#          - sum(nums) % k는 단지 "현재 합의 나머지"일 뿐,
#            "최소 연산 횟수"와 직접적으로 대응되지 않는다.
#          - 예를 들어, 어떤 연산이 "원소 하나를 어떤 값으로든 바꿀 수 있다"라면,
#            나머지가 0이 아니더라도 1회 연산으로 해결 가능할 수 있다.
#       2) 문제의 연산 정의를 사용하지 않음:
#          - 최소 연산 횟수를 구하려면,
#            어떤 연산으로 어떤 값을 만들 수 있는지,
#            그리고 그로 인해 sum(nums)가 어떻게 바뀌는지 등을 고려해야 한다.
#          - 현재 코드는 그 어떤 연산 모델도 고려하지 않는다.
#   - 사용한 개념:
#       - 모듈러 연산: sum(nums) % k를 통해 나머지를 구하는 것 자체는 올바른 수학적 연산이지만,
#         그것을 곧바로 "연산 횟수"로 해석하는 것은 잘못된 적용이다.

# 📚 시간·공간 복잡도:
#   - 시간 복잡도:
#       - sum(nums): O(n)
#       - 나머지 연산: O(1)
#       - 전체: O(n)
#   - 공간 복잡도:
#       - 추가 배열이나 자료구조가 없으므로 O(1)
#   - 복잡도 자체는 효율적이지만, 문제 요구사항에 맞는 값을 계산하지 못한다는 점이 핵심이다.

# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안 (개념만):
#   - 실제 정답 로직을 설계하려면 반드시 다음을 고려해야 한다:
#       1) "연산"의 정확한 정의:
#          - 한 번의 연산으로 원소를 1 증가/감소할 수 있는가?
#          - 임의의 값으로 바로 교체 가능한가?
#          - 특정 범위 내에서만 변경 가능한가?
#       2) 합의 나머지 조정:
#          - sum(nums) % k = r 이라면, 합을 k로 나누어떨어지게 만들기 위해
#            r를 어떻게 0으로 만들지(추가/감소, 특정 원소 조정 등)를 설계해야 한다.
#       3) 각 연산이 "합에 어떤 변화를 주는지"를 기반으로,
#          나머지 r을 0으로 만들기 위한 최소 연산 수를 계산하는 구조가 필요하다.
#   - 즉, 모듈러 연산은 "얼마나 조정해야 하는지"를 힌트로 주지만,
#     그 자체가 곧 연산 횟수가 되지는 않는다.
