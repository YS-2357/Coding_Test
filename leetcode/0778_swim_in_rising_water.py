# 0778_swim_in_rising_water.py
# -----------------------------------------------------
# ✅ 제목: Swim in Rising Water (LeetCode 778)
# ✅ 문제 설명(요약):
# - n×n 격자에서 각 칸의 높이 grid[i][j]가 주어진다.
# - 시간 t가 흐르면 높이 ≤ t인 칸만 이동 가능하다.
# - (0,0)에서 (n-1,n-1)까지 도달 가능한 최소 t를 구하라.
#
# ✅ 입력 형식(요지):
# - grid: List[List[int]], n×n 정수 격자, 0 ≤ grid[i][j] < n²
#
# ✅ 규칙 요약:
# 1) 한 칸 이동은 상하좌우 4방향.
# 2) 경로의 "최대 높이"가 작을수록 더 빠르게 도달 가능.
# 3) 정답은 (n-1,n-1)에 도착하기 위해 경로에서 마주친 최대 높이의 최소값.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지) — 한 줄 주석 포함
import heapq as hq                                               # 최소 힙 사용

class Solution:
    def swimInWater(self, grid: List[List[int]]) -> int:
        n = len(grid)                                            # 격자 한 변의 길이
        visited = [[False] * n for _ in range(n)]                # 방문 여부
        dirs = [(1,0), (0,1), (-1,0), (0,-1)]                   # 이동 4방향

        q = [(grid[0][0], 0, 0)]                                # 힙에 (현재 경로의 최대 높이, 좌표)
        visited[0][0] = True                                    # 시작점 방문 처리

        while q:                                                 # 힙이 빌 때까지 반복
            h, x, y = hq.heappop(q)                             # 가장 낮은 최대 높이 경로 우선 탐색
            if x == n-1 and y == n-1:                            # 도착점 도달 시
                return h                                         # 현재 높이가 최소 수위

            for dx, dy in dirs:                                  # 4방향 탐색
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny]:  # 유효 범위 & 미방문
                    visited[nx][ny] = True                       # 방문 확정
                    nh = max(h, grid[nx][ny])                    # 경로의 최대 높이 갱신
                    hq.heappush(q, (nh, nx, ny))                 # 새로운 상태를 힙에 추가

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 최소 힙 기반의 다익스트라식 탐색으로 정답 도출.
#
# 🔧 오답 이유 및 실수, 사용한 알고리즘 개념:
# - 핵심 개념: “경로 중 가장 높은 칸의 높이”를 최소화하는 최소 비용 경로 탐색.
#   → 다익스트라 알고리즘의 변형: 비용 = max(이전까지의 최대 높이, 현재 칸 높이)
# - 실수 가능 지점:
#   1) visited를 늦게 표시하면 중복 푸시 발생.
#   2) h를 갱신할 때 min이 아니라 max를 사용해야 함.
#
# 📚 시간·공간 복잡도:
# - 시간: O(n² log n) (각 칸이 힙에 최대 한 번 삽입)
# - 공간: O(n²) (visited, 힙)
#
# -----------------------------------------------------
# (선택) 다른 효율적인 풀이 또는 알고리즘 제안:
# - 이분 탐색 + BFS로도 가능 (t값에 대해 도달 가능 여부 판정).
# - 그러나 최소 힙 방식이 상수 시간 측면에서 더 효율적이고 구현 간결.
