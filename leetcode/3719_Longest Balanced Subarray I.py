# 3719_Longest Balanced Subarray I.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3719. Longest Balanced Subarray I
# 🏷️ 유형: 브루트포스 / 해시맵(빈도) / 부분배열 탐색
#
# ✅ 문제 설명(요약):
#   - 정수 배열 nums에서 “balanced subarray”의 최대 길이를 구한다.
#   - 코드 기준으로 balanced의 의미는:
#     - 부분배열 내에서 “서로 다른 홀수 값의 개수”와 “서로 다른 짝수 값의 개수”가 같으면 balanced이다.
#   - 모든 부분배열을 검사해 조건을 만족하는 최대 길이를 반환한다.
#
# ✅ 입력 형식(요지):
#   - nums: List[int]
#
# ✅ 규칙 요약:
#   - 부분배열은 연속 구간이다.
#   - 홀수/짝수는 값의 패리티로 분류한다.
#   - ‘개수’는 빈도 합이 아니라 “서로 다른 값의 수(len(dict))”로 비교한다.
#
# 🧠 핵심 불변식(Invariant):
#   - i를 시작점으로 고정하면, j를 늘려가면서 odd/even 딕셔너리에 “현재 부분배열의 값 등장 여부/빈도”를 누적한다.
#   - len(odd)는 부분배열에서 등장한 서로 다른 홀수 값의 수를 의미한다.
#   - len(even)은 부분배열에서 등장한 서로 다른 짝수 값의 수를 의미한다.
#   - 매 (i, j)에서 len(odd) == len(even)이면 현재 길이(j - i + 1)가 balanced 후보가 된다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                                     # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def longestBalanced(self, nums: List[int]) -> int:              # balanced 부분배열의 최대 길이를 반환하는 함수
        max_len = 0                                                 # 최대 길이를 저장할 변수 초기화

        for i in range(len(nums)):                                  # 부분배열 시작점 i를 0..n-1까지 순회
            odd = {}                                                # 현재 시작점 i에 대한 홀수 값 빈도 딕셔너리 초기화
            even = {}                                               # 현재 시작점 i에 대한 짝수 값 빈도 딕셔너리 초기화

            for j in range(i, len(nums)):                           # 끝점 j를 i..n-1까지 확장하며 모든 부분배열을 검사
                if nums[j] & 1:                                     # nums[j]가 홀수이면
                    odd[nums[j]] = odd.get(nums[j], 0) + 1          # 홀수 딕셔너리에 해당 값의 빈도를 1 증가
                else:                                               # nums[j]가 짝수이면
                    even[nums[j]] = even.get(nums[j], 0) + 1        # 짝수 딕셔너리에 해당 값의 빈도를 1 증가

                if len(odd) == len(even):                           # 서로 다른 홀수 값 개수와 짝수 값 개수가 같으면
                    max_len = max(max_len, j - i + 1)               # 현재 부분배열 길이로 최대값을 갱신

        return max_len                                              # 최종 최대 길이를 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 제출 코드 기준: 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: 모든 시작점 i에 대해 끝점 j를 확장하며 해시맵으로 “서로 다른 값 수”를 추적하는 브루트포스.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(n^2)  (모든 (i, j) 부분배열 검사)
#   - 공간: O(n)    (최악의 경우 딕셔너리에 많은 값이 들어갈 수 있음)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - “서로 다른 홀수/짝수 개수 차이”를 상태로 보고, 처음 등장한 상태 인덱스를 해시로 저장하는 방식으로 O(n) 최적화가 가능할 수 있다(개념만).
