# 1437_Check_If_All_1s_Are_At_Least_Length_K_Places_Away.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 1437. Check If All 1's Are at Least Length K Places Away
# ✅ 문제 설명(요약):
#   - 이진 배열 nums가 주어질 때, 모든 1들이 서로 최소 k개의 0 이상 떨어져 있는지 확인하는 문제.
#   - 즉, 두 1 사이의 거리(인덱스 차이)가 항상 k+1 이상이어야 한다.
#   - 조건을 위반하는 1 쌍이 하나라도 존재하면 False, 모든 구간이 조건을 만족하면 True.

# ✅ 입력 형식(요지):
#   - nums: 정수 배열(0 또는 1)
#   - k: 최소 떨어져 있어야 하는 0의 개수

# ✅ 규칙 요약:
#   - 첫 번째 1은 기준점 역할만 하므로 바로 거리 검사하지 않음.
#   - 이후 등장하는 모든 1은 이전 1과의 간격이 k 이상이어야 한다.
#   - 1 사이의 거리 < k 이면 즉시 False.

# ✅ 정답 코드(나의 원본 풀이; 절대 수정 금지)
#   - 코드 내용은 그대로 두고, 각 줄/블록마다 설명 주석만 추가한다.

class Solution:
    def kLengthApart(self, nums: List[int], k: int) -> bool:
        d = 0                       # 연속된 0의 개수를 세는 거리 카운터
        First1 = True               # 첫 번째 1을 아직 본 적 있는지 여부
        for i, num in enumerate(nums):  # nums 전체를 순회하며 인덱스와 값을 확인
            if num == 0:
                d += 1              # 0이면 거리 증가 (1 사이의 간격 누적)
            elif num == 1 and First1:
                First1 = False      # 첫 번째 1을 만나면 기준점 설정
                d = 0               # 거리 카운터 초기화
            else:
                if d < k:           # 두 번째 이후의 1에서 거리 조건 검사
                    return False    # 간격이 k 미만이면 조건 위반 → False
                d = 0               # 조건 충족 시 거리 초기화 후 다음으로 진행
        return True                 # 모든 검사 통과 시 True

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 문제 조건과 동일한 방식으로 거리 카운터를 유지하며 올바른 검사를 수행.
#   - 첫 번째 1은 특별 취급하고, 이후 등장하는 1마다 간격을 검사하는 구조가 맞게 구현됨.
#   - 제출 시 정상 통과하는 정답 풀이.

# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음. 첫 번째 1 처리, 거리 누적, k 미만 판단 등 핵심 조건이 정확히 충족됨.
#   - 사용 개념: 선형 스캔(linear scan), 상태 플래그(First1), 간격 카운팅.

# 📚 시간·공간 복잡도:
#   - 시간 복잡도: O(n) — nums를 한 번만 순회.
#   - 공간 복잡도: O(1) — 추가 변수 몇 개만 사용.

# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 인덱스를 추적해 마지막 1의 위치를 저장하는 방법도 존재하지만, 시간·공간은 동일 O(n), O(1).
#   - 현재 풀이가 명확하고 빠르며 최적.
