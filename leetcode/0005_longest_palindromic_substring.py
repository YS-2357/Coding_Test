# 0005_longest_palindromic_substring.py
# -----------------------------------------------------
# ✅ 제목: Longest Palindromic Substring
# ✅ 문제 설명(요약):
# - 문자열 s가 주어질 때, 가장 긴 팰린드롬 부분문자열을 반환한다.
# - 팰린드롬은 정방향과 역방향이 동일한 문자열을 의미한다.
#
# ✅ 입력 형식(요지):
# - s: str (1 ≤ len(s) ≤ 1000)
#
# ✅ 규칙 요약:
# 1) 부분문자열은 반드시 연속 구간이어야 한다.
# 2) 가장 긴 팰린드롬 하나를 반환. 여러 개면 아무거나 가능하다.
#
# ✅ 입출력 예시(1개):
# - s = "babad" → "bab" (또는 "aba")
#
# ✅ 정답 코드(너의 풀이; 한 줄마다 주석):
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if len(s) < 2:                      # 문자열 길이가 1이면 그대로 반환
            return s

        def expand(L: int, R: int) -> tuple[int, int]:
            # L,R을 중심으로 좌우 확장하며 최대 팰린드롬 구간 반환
            while L >= 0 and R < len(s) and s[L] == s[R]:
                L -= 1                      # 왼쪽으로 확장
                R += 1                      # 오른쪽으로 확장
            return L + 1, R - 1             # 확장 실패 직전의 유효 구간 반환

        bestL, bestR = 0, 0                 # 현재까지 찾은 가장 긴 팰린드롬 구간
        for i in range(len(s)):
            l1, r1 = expand(i, i)           # 홀수 길이 중심 확장
            l2, r2 = expand(i, i + 1)       # 짝수 길이 중심 확장
            if r1 - l1 > bestR - bestL:     # 홀수 중심 결과로 더 긴 경우 갱신
                bestL, bestR = l1, r1
            if r2 - l2 > bestR - bestL:     # 짝수 중심 결과로 더 긴 경우 갱신
                bestL, bestR = l2, r2
        return s[bestL:bestR + 1]           # 최종 가장 긴 팰린드롬 부분문자열 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 부분문자열 전부 생성 후 뒤집어 검사하는 O(n³) 풀이로 시간초과 발생.
#
# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - (이전) 모든 구간을 직접 확인해 비효율적.
#   → (수정) 각 인덱스를 중심으로 확장하는 슬라이딩 윈도우 방식 적용.
#   → 시간복잡도를 O(n²)로 줄이고, 공간은 O(1)로 해결.
#
# 📚 사용된/필수 개념(최소):
# - 투 포인터(양끝 확장), 슬라이딩 윈도우(가변 크기 중심 확장)
# - 문자열 인덱스 관리 및 부분문자열 반환
# - 시간복잡도: O(n²), 공간복잡도: O(1)
