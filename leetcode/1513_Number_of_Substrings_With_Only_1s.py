# 1513_Number_of_Substrings_With_Only_1s.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 1513. Number of Substrings With Only 1s
# ✅ 문제 설명(요약):
#   - 이진 문자열 s가 주어졌을 때, 오직 '1'로만 이루어진 모든 부분 문자열(substring)의 개수를 구하는 문제.
#   - '0'은 부분 문자열을 끊는 역할을 하며, 연속된 '1' 구간의 길이를 이용해 각 구간 내에서 만들 수 있는 substring 수를 계산해야 한다.
#   - 최종 결과는 1e9+7 로 나눈 값을 출력한다.
#
# ✅ 입력 형식(요지):
#   - 문자열 s (문자들은 '0' 또는 '1')
#
# ✅ 규칙 요약:
#   - 연속된 1의 길이가 L이면 그 구간에서 L*(L+1)/2 개의 부분 문자열이 생성됨.
#   - 전체 문자열에서 모든 연속된 1의 구간을 분리하여 각각 더하기.
#   - 결과는 항상 MOD = 10^9+7 로 모듈러 처리.
#
# ✅ 정답 코드(나의 원본 풀이; 절대 수정 금지)
#   - 아래는 사용자가 제출한 최종 정답 코드이며,
#     코드 내용은 변경하지 않고, 각 줄에 주석만 추가한다.

class Solution:
    def numSub(self, s: str) -> int:
        n = len(s)              # 문자열 길이 n
        k = 0                   # 현재 연속된 '1'의 길이를 세는 카운터
        MOD = 10 ** 9 + 7       # 문제에서 요구하는 모듈러 값

        ans = 0                 # 최종 답을 누적할 변수
        for i in range(n):      # 문자열을 왼쪽부터 한 번 순회
            if s[i] == "0":     # '0'을 만나면 이전까지의 연속된 1 구간이 종료되는 시점
                ans += (k * (k + 1) // 2) % MOD  # L*(L+1)/2 공식 적용하여 더함
                k = 0           # 연속 길이 초기화
            else:
                k += 1          # '1'이면 연속된 1의 길이 증가

        ans += (k * (k + 1) // 2) % MOD  # 마지막 구간이 '1'으로 끝났을 때 처리
        return ans             # 최종 결과 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 연속된 1 구간을 L로 보고 L*(L+1)/2씩 누적하는 접근은 정답 아이디어와 동일.
#   - 마지막 구간 처리 누락 여부가 흔한 실수지만, 이 코드는 마지막에 추가로 처리해 해결함.
#   - 모듈러 연산도 반영되어 제출 시 정상 통과됨.

# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 특별한 오답은 없으며, 접근 자체가 정해와 동일함.
#   - 핵심 알고리즘은 "연속된 1 구간(run length)"을 이용한 누적 합.
#   - 덩어리마다 L*(L+1)/2를 더하는 조합론적 계산 사용.

# 📚 시간·공간 복잡도:
#   - 시간 복잡도: O(n) — 문자열을 한 번만 순회.
#   - 공간 복잡도: O(1) — 상수 변수만 사용.

# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 이 문제는 이미 최적 해법(O(n), O(1))이므로 더 나은 알고리즘은 존재하지 않음.
#   - 다만 Python에서 매우 긴 문자열 처리 시 itertools.groupby로 run-length를 구할 수도 있음 (개념만).
