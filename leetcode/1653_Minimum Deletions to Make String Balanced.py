# 1653_Minimum Deletions to Make String Balanced.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 1653. Minimum Deletions to Make String Balanced
# 🏷️ 유형: 그리디 / 누적 카운트 / 문자열
#
# ✅ 문제 설명(요약):
#   - 문자열 s는 'a'와 'b'로만 구성된다.
#   - 모든 'a'가 모든 'b'보다 앞에 오도록 문자열을 만들고 싶다.
#   - 이를 위해 삭제해야 하는 최소 문자 개수를 구한다.
#
# ✅ 입력 형식(요지):
#   - s: str
#
# ✅ 규칙 요약:
#   - 최종 문자열은 "aaaa...bbbb" 형태여야 한다.
#   - 문자를 재배치할 수 없고, 삭제만 가능하다.
#
# 🧠 핵심 불변식(Invariant):
#   - 어느 지점을 기준으로 왼쪽에는 'a'만, 오른쪽에는 'b'만 남긴다고 생각할 수 있다.
#   - 또는, 문자열을 왼쪽부터 보며 "이미 나온 b 뒤에 a가 나오면" 그 a를 지우거나,
#     이전 b를 지우는 선택 중 최소를 취하는 그리디로 해결할 수 있다.
#
# =====================================================
# ✅ 정답 코드 1 (prefix/suffix 카운트 기반 풀이)
# =====================================================

class Solution:                                                     # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def minimumDeletions(self, s: str) -> int:                      # 최소 삭제 횟수를 반환하는 함수
        res = len(s)                                                # 최악의 경우 전체 삭제를 초기값으로 설정
        a = 0                                                       # 현재 위치 오른쪽에 남아있는 'a'의 개수
        b = 0                                                       # 현재 위치 왼쪽에 남아있는 'b'의 개수

        for c in s:                                                 # 문자열 전체를 한 번 순회하며
            a += (c == 'a')                                         # 전체 'a'의 개수를 미리 계산

        for c in s:                                                 # 다시 왼쪽부터 순회
            a -= (c == 'a')                                         # 현재 위치를 기준으로 오른쪽 'a' 개수 감소
            res = min(res, a + b)                                   # 오른쪽 a 삭제 + 왼쪽 b 삭제의 최소값 갱신
            b += (c == 'b')                                         # 왼쪽에 'b'가 하나 더 생김

        return res                                                  # 최소 삭제 횟수 반환

# =====================================================
# ✅ 정답 코드 2 (그리디 단일 패스 풀이)
# =====================================================

class Solution:                                                     # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def minimumDeletions(self, s: str) -> int:                      # 최소 삭제 횟수를 반환하는 함수
        res = 0                                                     # 지금까지의 최소 삭제 횟수
        b = 0                                                       # 현재까지 등장한 'b'의 개수

        for c in s:                                                 # 문자열을 왼쪽부터 한 번만 순회
            if c == 'b':                                            # 'b'를 만나면
                b += 1                                              # b 개수를 증가
            elif b:                                                 # 'a'를 만났고, 그 앞에 'b'가 존재하면
                res += 1                                            # 이 'a'를 삭제하는 선택
                b -= 1                                              # 또는 이전 'b' 하나를 삭제한 효과로 b 감소

        return res                                                  # 누적된 최소 삭제 횟수 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 두 풀이 모두 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념:
#     - 풀이 1: 분할 지점 기준 왼쪽/오른쪽 삭제 비용 최소화.
#     - 풀이 2: "b 뒤에 a가 나오면 충돌"이라는 관찰을 이용한 그리디.
#
# 📚 시간·공간 복잡도:
#   - 두 풀이 모두 시간 O(n)
#   - 공간:
#     - 풀이 1: O(1)
#     - 풀이 2: O(1)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - DP로도 해결 가능하지만, 상태가 단순해 그리디가 가장 직관적이고 효율적이다.
