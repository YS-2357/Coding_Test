# 1984_Minimum Difference Between Highest and Lowest of K Scores.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 1984. Minimum Difference Between Highest and Lowest of K Scores
# 🏷️ 유형: 정렬 / 슬라이딩 윈도우
#
# ✅ 문제 설명(요약):
#   - 학생 점수 배열 nums에서 정확히 k명의 점수를 선택한다.
#   - 선택된 점수들 중 최댓값과 최솟값의 차이를 최소화한다.
#   - 그 최소 차이를 반환한다.
#
# ✅ 입력 형식(요지):
#   - nums: List[int] (학생 점수 배열)
#   - k: int (선택할 학생 수)
#
# ✅ 규칙 요약:
#   - k == 1 인 경우 항상 차이는 0이다.
#   - 점수는 정수이며, 배열 길이는 k 이상이다.
#
# 🧠 핵심 불변식(Invariant):
#   - 정렬된 배열에서 길이 k의 연속 구간을 선택하면,
#     해당 구간의 맨 끝과 맨 앞의 차이가 그 구간의 최대-최소 차이다.
#   - 모든 길이 k 구간 중 이 차이의 최소값이 정답이다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                                     # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def minimumDifference(self, nums: List[int], k: int) -> int:    # k개의 점수를 선택했을 때 최소 차이를 구하는 함수
        nums.sort()                                                 # 점수 배열을 오름차순으로 정렬하여 구간 비교 가능하게 함
        return min(                                                 # 모든 길이 k 구간 중 최소 차이를 반환
            nums[i + k - 1] - nums[i]                               # i번째부터 i+k-1번째까지 구간의 최대-최소 차이
            for i in range(len(nums) - k + 1)                       # 가능한 모든 시작 인덱스 i를 순회
        )

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: 정렬 후 고정 길이 슬라이딩 윈도우로 최소 범위 탐색.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(n log n)  (정렬 비용)
#   - 공간: O(1)        (제자리 정렬 기준)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 점수 범위가 매우 작다면 카운팅 정렬로 O(n)에 정렬 가능하다(개념만).
