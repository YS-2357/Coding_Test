# 3650_Minimum Cost Path with Edge Reversals.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3650. Minimum Cost Path with Edge Reversals
# 🏷️ 유형: 그래프 / 다익스트라 / 가중치 변환(역방향 비용 모델링)
#
# ✅ 문제 설명(요약):
#   - n개의 노드(0..n-1)와 간선 정보 edges가 주어진다.
#   - 0번 노드에서 n-1번 노드까지 도달하는 최소 비용을 구한다.
#   - 특정 간선을 “뒤집어” 사용할 때 비용이 추가되는 형태를 가중치로 모델링하여 최단거리를 계산한다.
#   - 도달 불가능하면 -1을 반환한다.
#
# ✅ 입력 형식(요지):
#   - n: int
#   - edges: List[List[int]]  (각 원소는 [x, y, w])
#
# ✅ 규칙 요약:
#   - 입력 간선 [x, y, w]에 대해:
#     - x -> y 이동은 비용 w로 간주한다.
#     - y -> x 이동은 비용 2*w로 간주한다(역방향 사용 비용을 반영).
#   - 위 모델에서 0에서 n-1까지의 최소 비용을 구한다.
#
# 🧠 핵심 불변식(Invariant):
#   - 모든 간선 비용이 음수가 아니므로 다익스트라로 최단거리 계산이 가능하다.
#   - dist[v]는 시작점(0)에서 v까지 알려진 최소 비용을 저장하며, 힙에서 꺼낸 노드는 확정된다(visited로 관리).
#   - 그래프를 양방향 인접 리스트로 만들되, 역방향 비용을 2*w로 변환하여 저장한다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                                         # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def minCost(self, n: int, edges: List[List[int]]) -> int:            # 0에서 n-1까지의 최소 비용을 반환하는 함수
        g = [[] for _ in range(n)]                                       # 각 노드의 인접 리스트를 담을 그래프 g를 초기화
        for x, y, w in edges:                                            # 주어진 간선 리스트를 순회하며
            g[x].append((y, w))                                          # 정방향 x->y 비용을 w로 추가
            g[y].append((x, 2 * w))                                      # 역방향 y->x 비용을 2*w로 추가하여 모델링

        dist = [inf] * n                                                 # 각 노드까지의 최단거리 배열을 무한대로 초기화
        visited = [False] * n                                            # 다익스트라 확정(방문) 여부를 저장할 배열 초기화
        dist[0] = 0                                                      # 시작 노드(0)의 거리를 0으로 설정
        heap = [(0, 0)]                                                  # (현재거리, 노드) 형태의 최소 힙을 시작점으로 초기화

        while heap:                                                      # 힙이 빌 때까지 최단거리 탐색 반복
            cur_dist, x = heapq.heappop(heap)                            # 힙에서 현재까지 비용이 가장 작은 노드를 꺼냄

            if x == n - 1:                                               # 목적지 노드에 도달하면
                return cur_dist                                          # 현재 거리가 최단이므로 즉시 반환

            if visited[x]:                                               # 이미 최단거리가 확정된 노드라면
                continue                                                 # 중복 처리를 피하기 위해 건너뜀
            visited[x] = True                                            # 현재 노드를 확정 처리

            for y, w in g[x]:                                            # 현재 노드 x의 모든 이웃 y와 간선 비용 w를 순회
                new_dist = cur_dist + w                                  # x를 거쳐 y로 가는 새로운 거리 후보를 계산
                if new_dist < dist[y]:                                   # 더 짧은 경로를 찾았다면
                    dist[y] = new_dist                                   # 최단거리 배열을 갱신
                    heapq.heappush(heap, (new_dist, y))                  # 갱신된 거리로 힙에 삽입하여 후속 탐색

        return -1                                                        # 목적지에 도달하지 못하면 -1 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: 역방향 이동 비용을 가중치로 변환해 그래프를 구성한 뒤, 다익스트라로 최단경로 계산.
#
# 📚 시간·공간 복잡도:
#   - 시간: O((n + m) log n)  (m은 edges 개수; 힙 기반 다익스트라)
#   - 공간: O(n + m)          (인접 리스트와 dist/visited/heap)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 역방향 비용이 0/1처럼 이진 가중치로 떨어지는 변형이라면 0-1 BFS로도 풀 수 있다(개념만).
