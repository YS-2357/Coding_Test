# 696_Count Binary Substrings.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 696. Count Binary Substrings
# 🏷️ 유형: 문자열 / 그리디 / 그룹 길이 누적
#
# ✅ 문제 설명(요약):
#   - 문자열 s에서,
#   - 0과 1이 연속된 그룹으로 나뉘고,
#   - 0의 개수와 1의 개수가 같으며,
#   - 0과 1이 각각 연속되어 있는 부분 문자열의 개수를 구한다.
#
# ✅ 입력 형식(요지):
#   - s: str (0과 1로만 구성된 문자열)
#
# ✅ 규칙 요약:
#   - 연속된 같은 문자 그룹의 길이를 센다.
#   - 인접한 두 그룹의 길이가 각각 a, b라면,
#   - 해당 경계에서 만들 수 있는 유효 부분 문자열 수는 min(a, b)개이다.
#
# 🧠 핵심 불변식(Invariant):
#   - prev는 직전 그룹의 길이,
#   - strk는 현재 그룹의 길이를 의미한다.
#   - 현재 그룹 길이(strk)가 이전 그룹 길이(prev) 이하일 때마다
#     하나의 유효한 부분 문자열이 추가된다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                                      # LeetCode 제출용 Solution 클래스 정의
    def countBinarySubstrings(self, s: str) -> int:                  # 조건을 만족하는 부분 문자열 개수를 반환하는 함수
        res = 0                                                      # 정답(부분 문자열 개수) 초기화
        prev = 0                                                     # 이전 연속 그룹의 길이 저장 변수
        strk = 1                                                     # 현재 연속 그룹의 길이 (첫 글자 기준 1로 시작)

        for i in range(1, len(s)):                                   # 두 번째 문자부터 순회
            if s[i] == s[i - 1]:                                      # 이전 문자와 같으면
                strk += 1                                             # 현재 그룹 길이 증가
            else:                                                     # 이전 문자와 다르면
                prev = strk                                           # 현재 그룹 길이를 prev로 저장
                strk = 1                                              # 새로운 그룹 시작 → 길이 1로 초기화

            if strk <= prev:                                          # 현재 그룹 길이가 이전 그룹 길이 이하라면
                res += 1                                              # 유효한 부분 문자열 1개 추가

        return res                                                    # 최종 개수 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념:
#     - 연속 구간(run length) 기반 그룹화
#     - 인접 그룹 길이 비교를 통한 부분 문자열 개수 누적
#
# 📚 시간·공간 복잡도:
#   - 시간: O(n)
#   - 공간: O(1)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 먼저 모든 그룹 길이를 배열에 저장한 뒤,
#     인접한 그룹 쌍마다 min(a, b)를 더하는 방식으로도 구현 가능(개념만).
