# 2125_Number_of_Laser_Beams_in_a_Bank.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 2125. Number of Laser Beams in a Bank
# ✅ 문제 설명(요약):
#   각 행은 0과 1로 이루어진 문자열로, 1은 보안 장치(security device)를 의미한다.
#   같은 행 내에서는 레이저가 발사되지 않고, 서로 다른 행의 장치 간에만 레이저가 생긴다.
#   단, 두 행 사이에 장치가 없는 행이 있으면 그 사이의 레이저는 차단된다.
#   전체 은행에서 가능한 모든 레이저 빔의 수를 구하라.
#
# ✅ 입력 형식(요지):
#   - bank: List[str], 각 문자열은 0과 1로 구성됨 (길이 n)
#
# ✅ 규칙 요약:
#   - 각 행에서 '1'의 개수를 구한다.
#   - 장치가 하나도 없는 행(0)은 무시한다.
#   - 연속된 두 non-zero 행의 장치 개수를 곱하여 모두 더한 값이 정답이다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
class Solution:
    def numberOfBeams(self, bank: List[str]) -> int:
        temp = dict()                                 # 각 행의 '1' 개수를 저장할 딕셔너리
        for i, row in enumerate(bank):                # 모든 행을 순회
            for cell in row:                          # 각 행의 문자 검사
                if cell == "1":                       # 장치 발견 시
                    temp[i] = temp.get(i, 0) + 1      # 해당 행의 개수를 1 증가
        if len(temp) == 1:                            # 장치가 있는 행이 1개면 레이저 불가
            return 0
        cnt = list(temp.values())                     # 장치가 있는 행들의 개수만 추출
        ans = sum(cnt[i] * cnt[i+1] for i in range(0, len(cnt)-1))  # 인접한 행 간의 곱 누적
        return ans                                    # 총 레이저 수 반환
# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 대부분의 테스트 통과.
#   - 장치가 없는 행은 temp에 저장되지 않아 자동 건너뜀.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 아이디어: 각 non-zero row의 장치 수를 구한 뒤, 연속한 행끼리 곱해 누적.
#   - 사용 개념: 문자열 순회 + 딕셔너리 누적 + 인접 곱의 합.
#   - 개선 여지:
#       • temp 대신 리스트 사용 가능(딕셔너리 불필요).
#       • len(temp)==1 검사 대신 len(cnt)<2로 단순화 가능.
#
# 📚 시간·공간 복잡도:
#   - 시간복잡도: O(m×n)  (m=행 수, n=열 수)
#   - 공간복잡도: O(m)    (각 행별 장치 수 저장)
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 불필요한 딕셔너리 없이 리스트로 직접 처리:
#       prev = 0
#       ans = 0
#       for row in bank:
#           curr = row.count("1")
#           if curr:
#               ans += prev * curr
#               prev = curr
#       return ans
#     → 같은 논리지만 더 간결하고 O(1) 공간으로 해결 가능.
