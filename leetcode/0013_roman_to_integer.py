# 0013_roman_to_integer.py
# -----------------------------------------------------
# ✅ 제목: Roman to Integer
# ✅ 문제 설명(요약):
# - 로마 숫자 문자열 s를 정수로 변환한다.
# - 로마 숫자 기호:
#   I=1, V=5, X=10, L=50, C=100, D=500, M=1000
# - 감산 표기: IV=4, IX=9, XL=40, XC=90, CD=400, CM=900
#
# ✅ 입력 형식(요지):
# - s: str (1 ≤ len(s) ≤ 15, 값은 1~3999 사이의 올바른 로마 숫자)
#
# ✅ 규칙 요약:
# 1) 큰 값 기호부터 차례로 매칭.
# 2) 감산 표기 6개를 반드시 포함해야 정확히 매칭된다.
# 3) 앞에서부터 잘라내면서 num에 값을 더한다.
#
# ✅ 입출력 예시(1개):
# - s = "MCMXCIV" → 1994
#
# ✅ 정답 코드(너의 풀이; 한 줄마다 주석):
class Solution:
    def romanToInt(self, s: str) -> int:
        pairs = [                               # (값, 기호) 쌍을 내림차순으로 준비
            (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),
            (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),
            (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I'),
        ]

        num = 0

        for n, roman in pairs:                  # 큰 값 기호부터 차례로 검사
            if not s:                           # 남은 문자열이 없으면 종료
                break
            while s.startswith(roman):          # 현재 로마 기호로 시작하면
                s = s[len(roman):]              # 해당 기호만큼 앞에서 잘라내고
                num += n                        # 정수 값 더하기
                # print(s, num)                 # 디버깅용 출력
        return num                              # 최종 정수 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - 변환은 되었지만 감산 표기(IV, IX, XL 등)를 순서대로 고려하지 않으면 잘못 해석될 수 있음.
#
# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - (이전) 단일 문자만 처리하거나 순서 정렬이 잘못되어 감산 표기를 놓침.
#   → (수정) 감산 표기를 포함한 내림차순 쌍 리스트를 앞에서부터 매칭.
#
# 📚 사용된/필수 개념(최소):
# - 문자열 startswith()로 접두사 매칭
# - 그리디 매칭: 큰 단위부터 소진
# - 감산 표기 6개를 포함해야 유효한 해석 가능
# - 시간복잡도: O(n * k) (n은 문자열 길이, k는 기호 수=13 → 사실상 O(n)), 공간복잡도: O(1)

# -----------------------------------------------------
# 다른 풀이
# class Solution:
#     def romanToInt(self, s: str) -> int:
#         value = {                         # 각 로마 문자에 대응하는 정수 값 매핑
#             'I': 1, 'V': 5, 'X': 10,
#             'L': 50, 'C': 100, 'D': 500, 'M': 1000
#         }
#         total = 0                         # 누적 합계
#         n = len(s)                        # 문자열 길이 미리 저장

#         i = 0                             # 인덱스 포인터
#         while i < n:                      # 문자열 끝까지 스캔
#             cur = value[s[i]]             # 현재 문자의 값
#             # 다음 문자가 있고, 현재 값 < 다음 값이면 감산 표기
#             if i + 1 < n and cur < value[s[i + 1]]:
#                 total -= cur              # 현재 값을 빼주고
#             else:
#                 total += cur              # 그렇지 않으면 더한다
#             i += 1                        # 다음 문자로 이동

#         return total                      # 최종 정수 반환
