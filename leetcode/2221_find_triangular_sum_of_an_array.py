# 2221_find_triangular_sum_of_an_array.py
# -----------------------------------------------------
# ✅ 제목: Find Triangular Sum of an Array (LeetCode 2221)
# ✅ 문제 설명(요약):
# - 배열 nums가 주어진다.
# - 매 단계에서 인접한 두 원소를 더해 mod 10 한 값을 새로운 배열로 만든다.
# - 길이가 1이 될 때까지 반복하고, 최종 하나 남은 값이 정답이다.
#
# ✅ 입력 형식(요지):
# - nums: List[int], 원소 범위 0~9
# - 1 ≤ len(nums) ≤ 1000
#
# ✅ 규칙 요약:
# 1) 인접 쌍 합을 mod 10 → 새로운 배열.
# 2) 길이가 1이 될 때까지 반복.
# 3) 최종 원소 반환.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
import math

class Solution:
    def triangularSum(self, nums: List[int]) -> int:
        answer = 0
        n = len(nums)
        for i in range(n):
            answer = (answer + math.comb(n-1, i) * nums[i]) % 10
        return answer % 10

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - math.comb로 이항계수 방식 구현.
# - 정답 도출 가능.
#
# 🔧 오답 이유 및 실수(있다면):
# - 직접 반복 시뮬레이션 O(n²) 풀이 대신,
#   "최종 값 = Σ C(n-1,i)·nums[i] (mod 10)" 공식을 적용.
# - Python에서는 math.comb로 큰 정수를 계산하므로
#   시간은 O(n), 공간은 O(1)이나, 중간 정수 크기는 커질 수 있음.
# - 하지만 n ≤ 1000이라 파이썬에서 문제 없음.
#
# 📚 사용된 알고리즘 개념:
# - 이항계수 기반 선형결합:
#   최종 남는 값 = (n-1)번째 파스칼 삼각형 계수와 nums의 내적 mod 10.
# - 시간복잡도: O(n), 공간복잡도: O(1).
#
# -----------------------------------------------------
# (선택) 다른 효율적인 풀이 제안:
# - 제자리 시뮬레이션: nums 배열을 매번 갱신, O(n²), 공간 O(1).
#   구현 단순.
# - math.comb 방식은 이론적으로 O(n)으로 더 빠르지만,
#   파이썬 big int 처리 오버헤드가 있으므로 체감 속도는 O(n²)와 비슷하거나 약간 빠른 정도.
