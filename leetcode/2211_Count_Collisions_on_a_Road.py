# 2211_Count_Collisions_on_a_Road.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 2211. Count Collisions on a Road
# -----------------------------------------------------
# ✅ 문제 설명(요약):
#   - 일렬로 놓인 도로 위에 여러 차량이 있고, 각 차량은 다음 셋 중 하나의 상태를 갖는다.
#       · 'L' : 왼쪽으로 이동
#       · 'R' : 오른쪽으로 이동
#       · 'S' : 정지
#   - 모든 차량이 더 이상 움직이지 않을 때까지 충돌을 반복한다고 할 때,
#     전체 과정에서 발생하는 충돌 횟수의 합을 구하는 문제이다.
#   - 충돌 규칙:
#       · R → ← L  : 서로 마주보며 이동 중이면 2번의 충돌(각각 멈춤)
#       · R → S    : 오른쪽으로 가는 차가 정지한 차와 부딪히면 1번 충돌 후 멈춤
#       · S ← L    : 왼쪽으로 가는 차가 정지한 차와 부딪히면 1번 충돌 후 멈춤
#       · 모든 충돌 후에는 해당 위치에 정지 상태('S')의 차가 남는다.
#
# ✅ 입력 형식(요지):
#   - directions: str
#       · 길이 n (1 <= n <= 10^5)
#       · 각 문자는 'L', 'R', 'S' 중 하나.
#
# ✅ 규칙 요약:
#   - 도로의 양 끝으로 빠져나가는 차(처음부터 연속된 'L', 끝에서 연속된 'R')는 충돌에 관여하지 않는다.
#   - 중앙 구간에 남는 'L' 또는 'R'은 결국 언젠가는 충돌을 통해 멈추게 된다.
#   - 이 풀이에서는 전체 시뮬레이션 대신:
#       · 왼쪽에서 오는 R 들의 "개수(r_cnt)"를 세고
#       · S 또는 L과 만날 때, 그 순간에 연쇄 충돌 횟수를 한 번에 증가시키는 방식으로 계산한다.
#
# -----------------------------------------------------
# ✅ 정답 코드 (나의 최종 풀이; 절대 수정 금지, 주석만 추가)
# -----------------------------------------------------

class Solution:
    def countCollisions(self, directions: str) -> int:
        n = len(directions)          # 문자열 길이(사용하진 않지만 입력 크기 정보)

        ans, state = 0, directions[0]  # ans: 총 충돌 횟수, state: 왼쪽 구간의 "마지막 상태"
        r_cnt = 0                    # r_cnt: 아직 멈추지 않고 오른쪽으로 달리는 'R' 차량의 개수

        for i, d in enumerate(directions):  # 각 위치 i에서 차량 상태 d를 순회
            if d == "R":
                # 새로운 'R'을 만나면, 오른쪽으로 진행 중인 R 차량 수를 1 증가
                r_cnt += 1
                state = "R"           # 최근 관찰 상태를 'R'로 설정 (왼쪽에 달리는 차가 있다는 의미)

            elif d == "S":
                # 정지 상태 'S'를 만나면,
                #   - 왼쪽에서 달려오던 모든 'R'들이 이 위치에서 멈추며 각각 1번씩 충돌한다.
                ans += r_cnt          # 달리고 있던 R 개수만큼 충돌
                r_cnt = 0             # 모두 멈췄으므로 더 이상 진행 중인 R은 없음
                state = "S"           # 이 위치에 정지한 차가 존재하므로 상태를 'S'로 고정

            else:
                # d == "L" 인 경우 (왼쪽으로 이동하는 차량)
                if r_cnt > 0:
                    # 왼쪽에 아직 멈추지 않은 R 차량들이 있다면:
                    #   - 패턴: ... R R R L
                    #   - 이 L은 가장 오른쪽 R과 먼저 부딪혀 1번 충돌 후 멈추고(S),
                    #   - 나머지 R 들은 이 정지 상태 'S'에 차례대로 부딪히며 각각 1번씩 더 충돌한다.
                    #   → 총 충돌 횟수: r_cnt(각 R) + 1(L이 부딪힐 때) = r_cnt + 1
                    ans += r_cnt + 1  # 연쇄 충돌 횟수를 한 번에 반영
                    r_cnt = 0         # 모든 R이 멈췄으므로 진행 중인 R 없음
                    state = "S"       # 충돌 이후 이 위치는 정지 상태 'S'

                else:
                    # 왼쪽에 진행 중인 R이 하나도 없는 경우:
                    #   - 이 L은 왼쪽 끝으로 그냥 빠져나가거나,
                    #   - 혹은 이미 정지 상태 'S'와 부딪힐 수도 있다.
                    if state == "S":
                        # 바로 왼쪽에 정지 상태가 있는 경우:
                        #   - 패턴: ... S L
                        #   - 이 L은 그 S에 부딪혀 1번 충돌 후 멈춘다.
                        ans += 1      # S와의 충돌 1회
                        state = "S"   # 충돌 후에도 그 위치에는 S(정지)가 남음
                    else:
                        # state가 'R'도 'S'도 아닌 경우(초기 L 구간 등):
                        #   - 왼쪽에 정지한 차도, R도 없으므로 충돌 없이 왼쪽으로 빠져나간다.
                        #   - 단지 상태를 'L'로 유지하여, 이후 로직에서 "왼쪽에 S가 없다"는 정보를 반영.
                        state = "L"

        return ans                    # 계산된 총 충돌 횟수 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 초기에는 직전 문자(state)와 단순 collision 플래그만으로 충돌을 세려다,
#     연속된 R 뒤에 L 또는 S가 오는 경우(연쇄 충돌)를 정확히 처리하지 못해 오답이 발생했다.
#   - 이후, "왼쪽에 아직 멈추지 않은 R의 개수(r_cnt)를 상태값으로 둔다"는 관점으로 전환하여,
#     R-덩어리와 S/L의 만남을 한 번에 처리하도록 수정한 버전이다.
#   - 이 코드로 여러 케이스에서 정답이 검증되었다.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답의 원인:
#       · 충돌이 "인접한 두 문자"만의 문제가 아니라,
#         왼쪽에 쌓여 있는 여러 R 차량이 한 번에 멈추는 연쇄 충돌 구조라는 점을 간과함.
#       · 단일 collision 플래그로는 "얼마나 많은 R이 남았는지"를 표현할 수 없어,
#         실제보다 적거나 많은 충돌을 세게 되는 문제가 발생.
#   - 이 풀이에서 사용한 핵심 개념:
#       1) 진행 중인 R 차량 카운트(r_cnt):
#          - 도로를 왼쪽에서 오른쪽으로 스캔하면서,
#            아직 멈추지 않은 R 차량의 개수를 누적.
#          - S 또는 L을 만나면 이 r_cnt를 기반으로 한 번에 충돌 횟수 계산.
#       2) 상태(state)를 통한 S 존재 여부 관리:
#          - state == 'S' 인 경우,
#            왼쪽에 이미 정지한 차량이 있어 L이 그 S에 부딪힐 수 있음을 의미.
#          - state가 'L'인 경우, 왼쪽에 아직 S도 R도 없어 L이 그냥 빠져나감.
#       3) 물리 시뮬레이션 대신 "결과 상태 기반 카운팅":
#          - 실제로 매 초마다 차를 움직이는 대신,
#            "언젠가 반드시 멈추는 R/L들은 모두 최소 한 번씩 충돌한다"는 관찰을 이용해
#            한 번의 스캔으로 충돌 수를 계산.
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도:
#       · directions를 한 번만 순회하므로 O(n).
#   - 공간 복잡도:
#       · 추가 변수는 상수 개(r_cnt, state, ans)뿐이므로 O(1).
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 잘 알려진 다른 정답 접근:
#       · 문자열에서 맨 왼쪽 연속된 'L'과 맨 오른쪽 연속된 'R'을 잘라내고,
#         남은 중앙 구간에서 'L'과 'R'의 개수를 세는 방식도 있다.
#       · 이때 중앙 구간의 'L'/'R' 개수 = 결국 충돌로 인해 멈추게 되는 차량의 수 = 충돌 횟수.
#   - 현재 풀이는 그 아이디어를 "실제 스캔 로직" 형태로 옮긴 구현이라고 볼 수 있다.
# -----------------------------------------------------
