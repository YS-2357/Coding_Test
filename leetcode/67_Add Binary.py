# 67_Add Binary.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 67. Add Binary
# 🏷️ 유형: 비트 연산 / 덧셈 시뮬레이션
#
# ✅ 문제 설명(요약):
#   - 이진 문자열 a, b가 주어진다.
#   - 두 이진수를 더한 결과를 이진 문자열로 반환한다.
#
# ✅ 입력 형식(요지):
#   - a: str (binary string)
#   - b: str (binary string)
#
# ✅ 규칙 요약:
#   - XOR(^)는 자리 올림 없는 덧셈 결과를 만든다.
#   - AND(&)는 자리 올림이 발생하는 위치를 구한다.
#   - 자리 올림은 왼쪽으로 한 칸 이동(<< 1)한다.
#   - carry가 0이 될 때까지 반복하면 최종 합이 완성된다.
#
# 🧠 핵심 불변식(Invariant):
#   - x는 현재까지 계산된 “자리 올림을 제외한 합”을 저장한다.
#   - y는 현재 단계에서 발생한 “자리 올림”만 저장한다.
#   - (x ^ y)는 새로운 합, (x & y) << 1 은 다음 단계의 carry가 된다.
#   - y가 0이 되면 더 이상 자리 올림이 없으므로 연산이 종료된다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                        # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def addBinary(self, a, b) -> str:                  # 두 이진 문자열을 더해 결과를 반환하는 함수
        x, y = int(a, 2), int(b, 2)                    # 이진 문자열을 정수로 변환
        while y:                                       # 자리 올림이 존재하는 동안 반복
            x, y = x ^ y, (x & y) << 1                 # XOR로 합 계산, AND 후 좌측 이동으로 carry 계산
        return bin(x)[2:]                              # 결과를 이진 문자열로 변환 후 '0b' 제거하여 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: 비트 연산 기반 덧셈 (XOR = 합, AND+Shift = 자리올림).
#
# 📚 시간·공간 복잡도:
#   - 시간: O(k)  (k는 비트 길이; carry 전파 횟수에 비례)
#   - 공간: O(1)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 문자열을 뒤에서부터 직접 더하며 carry를 관리하는 방식도 가능하다(개념만).
