# 3075_Maximize_Happiness_of_Selected_Children.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3075. Maximize Happiness of Selected Children
# ✅ 문제 설명(요약):
#   - 각 아이의 행복도가 주어진 배열 happiness와 선택할 아이 수 k가 주어진다.
#   - 아이를 한 명 선택할 때마다, 이후에 선택되는 아이들의 행복도는 1씩 감소한다.
#   - 정확히 k명의 아이를 선택하여 얻을 수 있는 행복도의 합을 최대로 만든다.
#
# ✅ 입력 형식(요지):
#   - happiness: 각 아이의 초기 행복도를 나타내는 정수 배열
#   - k: 선택할 아이의 수
#
# ✅ 규칙 요약:
#   - 아이를 선택한 순서에 따라, i번째로 선택된 아이의 실제 기여 행복도는
#     max(happiness - (i-1), 0) 이다.
#   - 음수가 되는 행복도는 0으로 처리한다.
#   - k명은 반드시 선택해야 하며, 선택 순서는 자유롭게 정할 수 있다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
#   - 아래는 사용자가 첫 시도에서 제출하여 정답 처리된 코드이며,
#     이 단계에서는 코드 내용을 변경하지 않고,
#     각 줄마다 설명 주석만 추가한다.

class Solution:
    def maximumHappinessSum(self, happiness: List[int], k: int) -> int:
        happiness.sort()                               # 행복도를 오름차순 정렬(뒤에서부터 큰 값 선택 목적)
        ans, cnt = 0, 0                                # ans: 누적 행복도 합, cnt: 지금까지 선택한 아이 수

        while cnt < k:                                 # k명의 아이를 선택할 때까지 반복
            max_happy = happiness.pop()                # 현재 남아 있는 아이 중 가장 큰 행복도 선택
            # 선택 순서(cnt)에 따라 감소된 행복도를 계산,
            # 음수가 되면 0으로 처리
            ans += max_happy - cnt if max_happy - cnt > 0 else 0
            cnt += 1                                  # 선택한 아이 수 증가

        return ans                                     # 최대 행복도 합 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 바로 정답 처리됨.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 사용한 핵심 알고리즘:
#     - 그리디(Greedy)
#       - 가장 큰 행복도를 가진 아이부터 선택하는 것이 항상 최적.
#       - 선택 순서가 뒤로 갈수록 감소량(cnt)이 커지므로,
#         초기 값이 큰 아이를 먼저 선택해야 손실을 최소화할 수 있음.
#   - 핵심 아이디어:
#     - 실제 기여값은 happiness[i] - 선택순서 이므로,
#       내림차순 선택 + 순서 기반 감소 처리로 최적해 도출.
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도: O(n log n)
#     - n = len(happiness), 정렬 비용이 지배적
#   - 공간 복잡도: O(1) 추가
#     - 제자리 정렬 및 pop 사용(입력 제외)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 내림차순 정렬 후 for-loop로 상위 k개만 순회하는 방식도 가능하며,
#     pop 대신 인덱싱을 사용하면 리스트 변경 비용을 줄일 수 있다(코드 변경 필요).
