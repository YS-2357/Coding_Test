# 1458_Max Dot Product of Two Subsequences.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 1458. Max Dot Product of Two Subsequences
# 🏷️ 유형: DP / 2차원 DP / 수열
#
# ✅ 문제 설명(요약):
#   - 두 정수 배열 nums1, nums2에서 각각 비어있지 않은 부분수열을 하나씩 선택한다.
#   - 같은 길이로 정렬된 두 부분수열의 대응 원소 곱을 모두 더한 값(내적)을 최대화한다.
#   - 가능한 최대 내적 값을 반환한다.
#
# ✅ 입력 형식(요지):
#   - nums1: List[int]
#   - nums2: List[int]
#
# ✅ 규칙 요약:
#   - 각 배열에서 선택하는 부분수열은 반드시 비어있지 않아야 한다.
#   - 부분수열은 원래 순서를 유지한다.
#
# 🧠 핵심 불변식(Invariant):
#   - dp[i][j]는 nums1의 앞 i개와 nums2의 앞 j개를 고려했을 때 만들 수 있는 최대 내적 값을 의미한다.
#   - (i, j)에서 새 쌍을 선택하면 curr_prod 또는 curr_prod + dp[i-1][j-1]로 확장 가능하다.
#   - 새 쌍을 선택하지 않으면 dp[i-1][j], dp[i][j-1]로 이전 최댓값을 유지한다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                                         # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int: # 두 부분수열의 최대 내적을 반환하는 함수
        r, c = len(nums1), len(nums2)                                    # 각각 nums1, nums2의 길이를 r, c로 저장
        dp = [[-10**6 for j in range(c+1)] for i in range(r+1)]          # dp 테이블을 매우 작은 값으로 초기화하여 공집합 선택을 방지

        for i in range(1, r+1):                                          # nums1의 앞 i개를 고려하는 구간을 순회
            for j in range(1, c+1):                                      # nums2의 앞 j개를 고려하는 구간을 순회
                curr_prod = nums1[i-1] * nums2[j-1]                      # 현재 원소를 서로 짝지었을 때의 곱을 계산
                dp[i][j] = max(                                          # 가능한 모든 선택지 중 최댓값으로 dp[i][j]를 갱신
                    dp[i][j],                                            # (초기값 유지; 사실상 안전장치)
                    curr_prod,                                           # 현재 (i-1, j-1) 원소만 새로 시작하는 경우
                    dp[i-1][j],                                          # nums1의 i번째 원소를 버리고 이전 최댓값을 가져오는 경우
                    dp[i][j-1],                                          # nums2의 j번째 원소를 버리고 이전 최댓값을 가져오는 경우
                    curr_prod + dp[i-1][j-1]                             # 현재 곱을 이전 최댓값(dp[i-1][j-1])에 이어붙이는 경우
                )
        print(dp)                                                        # (디버깅 출력) dp 테이블 전체를 출력함

        return dp[r][c]                                                  # 전체 구간에서의 최대 내적 값을 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 3단계 규칙(A. 디버깅 출력)에 위배: print(dp)로 stdout 출력이 포함됨.
#   - 정답 여부와 무관하게, 3단계 산출물 규칙상 print는 제거되어야 함 (코드 수정 금지이므로 주석으로만 경고).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 잠재 이슈: dp 초기값 -10**6은 입력 범위/길이에 따라 충분히 작지 않을 수 있어 안전하지 않을 수 있다.
#   - 사용 개념: 2차원 DP(부분수열 정렬 매칭), 선택/스킵/확장 전이.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(r*c)
#   - 공간: O(r*c)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - dp를 -inf로 두고, 확장 항에서 dp[i-1][j-1]가 -inf일 때는 curr_prod만 허용하는 방식으로 공집합을 더 엄격히 차단할 수 있다 (개념만).
