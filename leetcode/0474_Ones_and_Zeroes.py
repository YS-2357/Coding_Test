# 0474_Ones_and_Zeroes.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 474. Ones and Zeroes
# ✅ 문제 설명(요약):
#   - 문자열 배열 strs가 주어진다.
#   - 각 문자열은 '0'과 '1'로 구성되어 있다.
#   - 최대 m개의 '0'과 n개의 '1'만 사용할 수 있을 때,
#     선택할 수 있는 문자열의 최대 개수를 구하라.
#
# ✅ 입력 형식(요지):
#   - strs: List[str], 각 문자열은 0/1로만 구성
#   - m, n: int — 사용할 수 있는 0과 1의 최대 개수
#
# ✅ 규칙 요약:
#   - 각 문자열은 한 번만 사용할 수 있다. (0/1 배낭 문제)
#   - 각 문자열은 “0 개수 = 무게1”, “1 개수 = 무게2”, “문자열 1개 = 가치1”로 본다.
#   - dp[i][j] = 0을 i개, 1을 j개까지 써서 얻을 수 있는 최대 문자열 개수
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        dp = [[0] * (n + 1) for _ in range(m + 1)]  # dp[i][j]: i개의 0, j개의 1로 만들 수 있는 최대 문자열 개수

        for s in strs:                               # 각 문자열을 하나의 아이템으로 생각
            zeros, ones = s.count("0"), s.count("1") # 소비되는 0,1의 개수 계산
            for i in range(m, zeros - 1, -1):        # 역순: 같은 문자열 중복 방지 (0/1 배낭 표준)
                for j in range(n, ones - 1, -1):
                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)
                    # 선택 안함: dp[i][j]
                    # 선택함: dp[i - zeros][j - ones] + 1 (현재 문자열 추가)
        
        return dp[m][n]                              # 최대 m개의 0, n개의 1로 만들 수 있는 최대 문자열 개수
# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 모든 테스트케이스 통과.
#   - DP 테이블이 0/1 배낭 문제 구조와 동일하게 작동함.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 사용 개념: 2차원 0/1 배낭(Dynamic Programming)
#   - 핵심 아이디어:
#       • “0”과 “1”을 두 가지 제한 자원(capacity)으로 취급.
#       • 문자열 하나를 넣을 때 (zeros, ones)를 동시에 소비.
#       • DP 역순 갱신으로 중복 선택 방지.
#   - 직관: 문자열은 ‘2차원 무게’를 가진 아이템, m과 n은 가방의 용량.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(len(strs) × m × n)
#   - 공간: O(m × n)
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 공간 최적화:
#       dp를 2D 대신 1D 배열로 줄일 수 있음 (m, n 각각 역순으로 순회 유지)
#       예: dp[i][j]만 유지, 이전 상태는 덮어쓰기 전 접근 불가하도록 역순 루프 유지.
