# 3625_Count_Number_of_Trapezoids_II.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3625. Count Number of Trapezoids II
# -----------------------------------------------------
# ✅ 문제 설명(요약):
#   - 2차원 평면 위에 n개의 서로 다른 점이 주어진다.
#   - 이 중 네 점을 선택해, 적어도 한 쌍의 대변이 서로 평행한 볼록 사각형(= 사다리꼴)의 개수를 구하는 문제이다.
#   - 평행사변형(두 쌍의 대변이 모두 평행한 경우)도 사다리꼴에 포함되지만,
#     동일한 사각형은 한 번만 세야 하므로, 평행사변형이 여러 방식으로 중복 카운트되지 않도록 조정해야 한다.
#
# ✅ 입력 형식(요지):
#   - points: List[List[int]]
#       · points[i] = [x_i, y_i] 꼴의 정수 좌표
#       · 모든 점은 서로 다른 위치
#
# ✅ 규칙 요약:
#   - 사다리꼴:
#       · 볼록 사각형이고, 적어도 한 쌍의 서로 평행한 변이 존재
#   - 평행사변형:
#       · 두 쌍의 변이 모두 서로 평행한 사각형 → 사다리꼴의 특수한 경우
#   - 핵심 아이디어:
#       1) 같은 기울기(slope)를 갖는 직선들을 모아, 서로 다른 직선 쌍에서 선분을 하나씩 선택하는 조합 수를 센다.
#          → “평행한 두 변”을 기준으로 하는 사다리꼴 + 평행사변형의 총 카운트
#       2) 대각선의 중점(midpoint)와 기울기 조합을 이용해, 평행사변형 개수를 따로 센 뒤,
#          앞에서 구한 값에서 빼서 “중복 카운트”를 제거한다.
#   - 좌표/점 개수 범위 때문에, 전체 알고리즘은 O(n^2) 수준의 점쌍 처리로 구성된다.
#
# -----------------------------------------------------
# ✅ 정답 코드 (나의 풀이; 절대 수정 금지, 주석만 추가)
# -----------------------------------------------------

from collections import defaultdict
from math import gcd
from typing import List

class Solution:
    def countTrapezoids(self, points: List[List[int]]) -> int:
        MOD = 10**9 + 7              # 결과를 나눌 모듈러 값
        n = len(points)              # 점의 개수

        # 기울기 정규화 함수: 두 점 (x1, y1), (x2, y2)를 잇는 선분의 "표준화된 방향 벡터"를 구한다.
        # - dx, dy를 gcd(|dx|, |dy|)로 나누어 기울기를 정규화하고
        # - 수직선: (0, 1), 수평선: (1, 0) 으로 고정된 표현을 사용한다.
        def slope_form(x1: int, y1: int, x2: int, y2: int):
            dx = x1 - x2             # x 좌표 차이
            dy = y1 - y2             # y 좌표 차이

            if dx < 0:               # 방향의 부호를 통일하기 위해 dx를 항상 0 이상으로 맞춘다.
                dx = -dx
                dy = -dy

            if dx == 0:              # 수직선: dx = 0 → 기울기 '무한대'를 (0, 1)로 표현
                return (0, 1)        # vertical
            if dy == 0:              # 수평선: dy = 0 → 기울기 0을 (1, 0)으로 표현
                return (1, 0)        # horizontal

            g = gcd(abs(dx), abs(dy))  # dx, dy의 최대공약수
            dx //= g                  # dx, dy를 gcd로 나누어 기울기를 기약 비율로 정규화
            dy //= g
            return (dx, dy)           # 정규화된 방향 벡터(기울기 표현) 반환

        # mp[slope][intercept] = 해당 slope와 intercept를 갖는 "직선 위의 선분 개수"
        # - slope: 정규화된 (dx, dy)
        # - intercept: 같은 slope에서 직선을 분리하는 ID 역할 (dy * x - dx * y 형태)
        mp = defaultdict(lambda: defaultdict(int))

        # 대각선의 중점 기준으로 평행사변형을 카운트하기 위해 사용하는 자료구조들
        mids = defaultdict(int)                      # mids[(mx, my)] = 해당 중점을 갖는 "모든 대각선의 수"
        mids_diff = defaultdict(lambda: defaultdict(int))
        # mids_diff[(mx, my)][slope] = 해당 중점과 해당 slope를 갖는 대각선의 수

        pgram = 0  # 평행사변형 개수(나중에 ans에서 빼줄 값)

        # 1. 모든 점쌍을 순회하며:
        #    - 기울기와 직선 ID(intercept)를 계산해 mp에 선분 개수 누적
        #    - 동시에 두 점을 "대각선 후보"로 보고, 중점 + 기울기 정보로 평행사변형 개수를 센다.
        for i in range(n):
            x1, y1 = points[i]
            for j in range(i + 1, n):
                x2, y2 = points[j]

                # (i, j)를 잇는 선분의 정규화된 기울기(방향 벡터)
                s = slope_form(x1, y1, x2, y2)
                dx, dy = s

                # 같은 기울기를 가진 직선을 dy * x - dx * y = c 꼴로 표현
                # - (dx, dy)가 동일하고 c가 같다면 동일한 직선 위에 있음
                intercept = dy * x1 - dx * y1
                mp[s][intercept] += 1   # 해당 직선 위의 선분 개수 +1

                # (x1, y1), (x2, y2)를 "대각선"으로 보고,
                # 중점 (mx/2, my/2)를 나타내는 정수 key (mx, my) = (x1 + x2, y1 + y2)를 사용
                mx = x1 + x2            # 실제 중점의 x좌표는 mx / 2 이지만, 비교용으로 합만 사용
                my = y1 + y2            # 실제 중점의 y좌표는 my / 2

                # 같은 중점을 가지는 모든 대각선 쌍은 "평행사변형"을 만들 수 있는 후보이다.
                # 그중에서도 서로 다른 기울기의 대각선 쌍만 평행사변형을 만든다.
                #
                # mids[(mx, my)]         : 지금까지 같은 중점을 가진 모든 대각선의 수
                # mids_diff[(mx, my)][s] : 그 중, slope = s 인 대각선의 수
                #
                # 현재 대각선(s, (mx, my))가 추가되기 전에,
                #   - 같은 중점 (mx, my)를 가진 기존 대각선은 mids[(mx, my)] 개
                #   - 그 중 기울기 s를 가진 것은 mids_diff[(mx, my)][s] 개이므로
                #   - "기울기가 다른" 대각선은 mids[(mx, my)] - mids_diff[(mx, my)][s] 개
                # 이 각각과 현재 대각선을 짝지으면 평행사변형 1개씩 생성.
                pgram += mids[(mx, my)] - mids_diff[(mx, my)][s]

                # 상태 업데이트: 현재 대각선을 중점/기울기 카운트에 반영
                mids[(mx, my)] += 1
                mids_diff[(mx, my)][s] += 1

        # 2. slope별로 "평행한 두 직선 쌍"을 이용해 만들 수 있는 사다리꼴/평행사변형 개수 카운트
        #    - mp[slope][intercept] = 해당 직선 위 선분 개수
        #    - 같은 slope 안에서, 서로 다른 intercept를 갖는 두 직선을 선택하고,
        #      각 직선에서 선분을 하나씩 고르는 모든 조합 수를 합산한다.
        ans = 0
        for slope, vals in mp.items():
            tot = 0                        # 현재 slope에서 이전까지 처리한 모든 직선의 선분 개수 총합
            for cnt in vals.values():      # cnt: 특정 intercept 직선 위의 선분 개수
                # 서로 다른 두 직선을 선택해, 각 직선에서 선분을 하나씩 선택하는 조합:
                #   - 이전까지 존재한 선분 수 tot 와 현재 직선의 선분 수 cnt 의 곱
                ans = (ans + cnt * tot) % MOD
                tot += cnt                 # 누적 선분 개수 업데이트

        # 3. 평행사변형 제거(중복 카운트 보정)
        #    - 위 ans에는 일반 사다리꼴 + 평행사변형이 모두 포함되어 있고,
        #      특히 평행사변형은 "두 가지 기울기(s1, s2)"에서 각각 한 번씩 중복 카운트된다.
        #    - pgram은 "서로 다른 기울기의 대각선 쌍"을 이용해 세어낸 평행사변형 개수이다.
        #    - 따라서 최종 정답은 ans - pgram.
        ans = (ans - pgram) % MOD

        return ans                        # 중복이 보정된 최종 사다리꼴 개수 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 평행한 두 직선 쌍(같은 slope, 다른 intercept)의 조합으로
#     사다리꼴/평행사변형을 모두 세고,
#   - 대각선 중점 + 기울기를 이용해 평행사변형 개수를 빼는 방식으로
#     최종적으로 "서로 다른 사다리꼴 개수"를 정확히 얻는 풀이이다.
#   - 점의 개수가 n ≤ 500 수준이므로, 모든 점쌍을 순회하는 O(n^2) 구조로 충분히 통과한다.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 직관적으로는 "같은 기울기의 선분 쌍"만 세면 될 것 같지만,
#     평행사변형이 두 가지 기울기에서 각각 한 번씩 중복 카운트된다는 함정이 있다.
#   - 이 풀이는:
#       1) slope + intercept 해싱:
#          - dy * x - dx * y = c 꼴의 정수 표현으로 직선을 구분하고,
#            같은 (slope, c)를 같은 직선으로 묶는다.
#       2) 중점(midpoint) + slope 해싱:
#          - (x1 + x2, y1 + y2)를 중점 key로 사용해,
#            같은 중점을 갖는 대각선들을 모으고 기울기별로 나누어
#            "서로 다른 기울기의 대각선 쌍"을 평행사변형으로 센다.
#       3) 누적 조합 계산:
#          - 누적 합 tot, mids 등을 사용해,
#            모든 쌍을 일일이 순회하지 않고 count * tot 형태로 O(k) 내에서 쌍의 개수를 계산.
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도:
#       · 모든 점쌍 순회: O(n^2)
#       · 각 slope/intercept, midpoint 그룹에 대해 값들을 한 번씩만 순회: O(n^2)
#       · 전체적으로 O(n^2) (gcd 계산 포함 시 O(n^2 log C) 정도)
#   - 공간 복잡도:
#       · mp, mids, mids_diff에 점쌍당 정보 저장: O(n^2)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 현재 풀이는 정수 기반 slope + line ID + midpoint 해싱 구조로,
#     부동소수점 오차 없이 안정적으로 동작한다는 장점이 있다.
#   - 기울기 정규화를 보다 엄밀히 하거나,
#     직선 ID를 다른 정수 표현(ax + by + c = 0 꼴)으로 바꾸는 변형도 가능하지만,
#     전체 알고리즘 구조(1) 평행 직선 쌍 카운트, (2) 평행사변형 보정은 그대로 유지된다.
# -----------------------------------------------------
