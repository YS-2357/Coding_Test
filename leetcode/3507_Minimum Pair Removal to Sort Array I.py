# 3507_Minimum Pair Removal to Sort Array I.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3507. Minimum Pair Removal to Sort Array I
# 🏷️ 유형: 시뮬레이션 / 그리디(최소 인접합 선택)
#
# ✅ 문제 설명(요약):
#   - 배열 nums가 오름차순(비내림차순)이 될 때까지 다음 연산을 반복한다.
#   - 인접한 두 원소(nums[i], nums[i+1])를 선택해 제거하고, 그 자리에 두 원소의 합을 하나의 원소로 넣는다.
#   - 오름차순이 되기까지 필요한 최소 연산 횟수를 구한다(본 풀이 로직 기준).
#
# ✅ 입력 형식(요지):
#   - nums: List[int]
#
# ✅ 규칙 요약:
#   - 한 번의 연산은 인접한 두 원소를 하나로 합치는 것(길이 1 감소)이다.
#   - 배열이 이미 오름차순이면 연산을 중단한다.
#
# 🧠 핵심 불변식(Invariant):
#   - 매 반복에서 현재 배열이 오름차순인지 검사하며, 아니라면 인접쌍 합이 최소인 위치를 선택해 합친다.
#   - 길이는 매 연산마다 정확히 1 줄어들며, count는 수행한 연산 횟수를 누적한다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                                     # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def minimumPairRemoval(self, nums: List[int]) -> int:           # 배열을 오름차순으로 만들기 위한 연산 횟수를 반환하는 함수
        count = 0                                                   # 수행한 연산 횟수를 저장할 변수 초기화

        while len(nums) > 1:                                        # 배열 길이가 1이 될 때까지(또는 중간에 정렬되면 종료) 반복
            isAscending = True                                      # 현재 배열이 오름차순인지 여부를 True로 초기화
            minSum = float("inf")                                   # 인접쌍 합의 최소값을 무한대로 초기화
            targetIndex = -1                                        # 최소 인접쌍 합이 나타난 왼쪽 인덱스를 저장할 변수 초기화

            for i in range(len(nums) - 1):                          # 모든 인접한 쌍 (i, i+1)을 순회
                pair_sum = nums[i] + nums[i + 1]                    # 현재 인접쌍의 합을 계산

                if nums[i] > nums[i + 1]:                           # 오름차순 조건(비내림차순)을 위반하는지 확인
                    isAscending = False                             # 위반이 있으면 오름차순이 아니므로 False로 변경

                if pair_sum < minSum:                               # 현재 인접쌍 합이 지금까지의 최소합보다 작으면
                    minSum = pair_sum                               # 최소합을 현재 합으로 갱신
                    targetIndex = i                                 # 최소합을 만든 쌍의 왼쪽 인덱스로 갱신

            if isAscending:                                         # 현재 배열이 이미 오름차순이면
                break                                               # 더 이상의 연산 없이 루프 종료

            count += 1                                              # 연산을 1회 수행하므로 카운트를 증가
            nums[targetIndex] = minSum                              # 선택된 인접쌍을 합친 값을 왼쪽 위치에 저장
            nums.pop(targetIndex + 1)                               # 오른쪽 원소를 제거하여 쌍을 하나의 원소로 축약

        return count                                                # 누적된 연산 횟수를 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: 매 단계 오름차순 여부 점검 + 최소 인접합 쌍 선택 후 합치기 시뮬레이션.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(n^2)  (매 단계 O(n) 스캔을 최대 O(n)번 수행)
#   - 공간: O(1)    (제자리 수정; pop로 리스트 크기 감소)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 인접쌍 합의 최소를 빠르게 찾기 위해 힙/연결리스트(또는 balanced structure)로 개선할 여지가 있다(개념만).
