# 3640_Trionic Array II.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3640. Trionic Array II
# 🏷️ 유형: 배열 / 구간 탐색 / 단조 구간 확장 / 최대 부분합(누적 최댓값)
#
# ✅ 문제 설명(요약):
#   - nums에서 “trionic 형태(증가 → 감소 → 증가)”를 만족하는 연속 구간을 잡아,
#     그 구간 원소 합의 최댓값을 구한다.
#   - 가능한 구간이 없으면 0을 반환한다.
#
# ✅ 입력 형식(요지):
#   - nums: List[int]
#
# ✅ 규칙 요약:
#   - 중심 구간은 엄격 감소(peak에서 내려가는 구간)이어야 한다.
#   - 중심 감소 구간의 왼쪽은 엄격 증가(peak로 올라오는 구간)이어야 한다.
#   - 중심 감소 구간의 오른쪽은 엄격 증가(valley에서 올라가는 구간)이어야 한다.
#   - 각 구간은 길이가 최소 1 이상이 되도록(실제 전환이 존재하도록) 체크한다.
#
# 🧠 핵심 불변식(Invariant):
#   - i는 “감소 구간의 시작 후보”를 나타내며, 각 반복에서 감소→증가 패턴을 찾으면 i를 b로 점프해 중복 탐색을 줄인다.
#   - (a..b)에서 b가 감소 구간 끝(최저점 후보)이며, net은 감소 구간 원소 합을 누적한다.
#   - 감소 구간 왼쪽으로 확장하며(엄격 증가 조건) left 누적합의 최대값(lx)을 유지해 “왼쪽 증가 구간의 최적 합”을 얻는다.
#   - 감소 구간 오른쪽으로 확장하며(엄격 증가 조건) right 누적합의 최대값(rx)을 유지해 “오른쪽 증가 구간의 최적 합”을 얻는다.
#   - 최종 후보 합은 lx + net + rx이며, 이를 res로 최대화한다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                                     # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def maxSumTrionic(self, nums: List[int]) -> int:                # trionic 형태 구간 합의 최댓값을 반환하는 함수
        n = len(nums)                                               # 배열 길이를 저장
        res = -float('inf')                                         # 가능한 최대 합을 저장할 변수(초기값은 -inf)
        i = 1                                                       # 감소 구간 시작 후보 인덱스를 1로 설정(왼쪽 확장 여지 확보)
        while i < n - 2:                                            # 감소+오른쪽 증가를 만들려면 최소 2칸 여유가 필요
            a = b = i                                               # a는 감소 구간 시작, b는 감소 구간 끝으로 확장될 포인터
            net = nums[a]                                           # 감소 구간 합(net)을 시작 원소로 초기화
            while b + 1 < n and nums[b + 1] < nums[b]:              # 엄격 감소가 유지되는 동안
                net += nums[b + 1]                                  # 감소 구간 합에 다음 원소를 누적
                b += 1                                              # 감소 구간 끝 포인터를 오른쪽으로 이동
            if b == a:                                              # 감소 구간 길이가 1이면(실제 감소가 없으면)
                i += 1                                              # 다음 시작 후보로 이동
                continue                                            # 이번 반복은 실패 처리
            
            c = b                                                   # c는 감소 구간 끝(최저점 후보) 위치를 저장
            left = right = 0                                        # 좌/우 증가 확장 누적합을 0으로 초기화
            lx = rx = -float('inf')                                 # 좌/우 증가 구간의 “최대 누적합”을 -inf로 초기화
            
            while a - 1 >= 0 and nums[a - 1] < nums[a]:             # 감소 구간 왼쪽으로 엄격 증가가 가능한 동안
                left += nums[a - 1]                                 # 왼쪽으로 확장한 원소를 left에 누적
                lx = max(lx, left)                                  # 왼쪽 증가 구간의 최대 합을 갱신
                a -= 1                                              # a를 왼쪽으로 이동하여 구간을 확장
            if a == i:                                              # 왼쪽 증가 구간이 형성되지 않았다면
                i += 1                                              # 다음 시작 후보로 이동
                continue                                            # 이번 반복은 실패 처리
            
            while b + 1 < n and nums[b + 1] > nums[b]:              # 감소 구간 끝에서 오른쪽으로 엄격 증가가 가능한 동안
                right += nums[b + 1]                                # 오른쪽으로 확장한 원소를 right에 누적
                rx = max(rx, right)                                 # 오른쪽 증가 구간의 최대 합을 갱신
                b += 1                                              # b를 오른쪽으로 이동하여 구간을 확장
            if b == c:                                              # 오른쪽 증가 구간이 형성되지 않았다면
                i += 1                                              # 다음 시작 후보로 이동
                continue                                            # 이번 반복은 실패 처리
                
            res = max(res, lx + rx + net)                           # 좌증가 최대합 + 감소구간합 + 우증가 최대합으로 결과 갱신
            i = b                                                   # 현재 패턴을 사용한 구간 끝으로 점프해 탐색 중복을 줄임
        return res if res != -float('inf') else 0                   # 가능한 패턴이 없으면 0, 있으면 최대 합 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: 감소 구간을 중심으로 좌/우 단조(증가) 확장, 각 확장에서 최대 누적합을 유지해 최댓값 조합 탐색.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(n)~O(n^2) 사이 동작 가능(인덱스 점프가 있어 평균적으로 줄이지만, 최악은 확장 반복이 겹칠 수 있음)
#   - 공간: O(1)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 각 위치를 peak/valley 후보로 두고, “증가 최대 부분합/감소 구간 합/증가 최대 부분합”을 미리 DP로 전처리하면 최악을 O(n)으로 고정할 수 있다(개념만).
