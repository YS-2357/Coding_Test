# 2975_Maximum Square Area by Removing Fences From a Field.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 2975. Maximum Square Area by Removing Fences From a Field
# 🏷️ 유형: 해시셋 / 조합(거리 차이) / 브루트포스
#
# ✅ 문제 설명(요약):
#   - 가로 m, 세로 n 크기의 직사각형 필드에 울타리(펜스) 위치들이 주어진다.
#   - 일부 울타리를 제거하여, 남는 울타리 두 개를 경계로 하는 정사각형을 만들 수 있다.
#   - 만들 수 있는 정사각형의 최대 넓이를 구하고, 10^9+7로 나눈 값을 반환한다.
#   - 정사각형을 만들 수 없다면 -1을 반환한다.
#
# ✅ 입력 형식(요지):
#   - m: 세로 방향 길이(가로 펜스 좌표의 최대값)
#   - n: 가로 방향 길이(세로 펜스 좌표의 최대값)
#   - hFences: 가로 펜스들의 좌표 리스트
#   - vFences: 세로 펜스들의 좌표 리스트
#
# ✅ 규칙 요약:
#   - 필드의 경계(1, m)와 (1, n)도 펜스로 간주되도록 포함한다.
#   - 정사각형 한 변 길이는 가로 방향 거리와 세로 방향 거리가 같아야 한다.
#   - 가능한 동일 거리 중 최대를 선택해 넓이를 계산한다.
#
# 🧠 핵심 불변식(Invariant):
#   - 두 가로 펜스 사이 거리들의 집합과 두 세로 펜스 사이 거리들 중 공통으로 존재하는 값이 “가능한 정사각형 변 길이”가 된다.
#   - 공통 거리의 최댓값을 ans로 잡으면, 최대 정사각형 넓이는 ans^2이다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                                                 # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:  # 최대 정사각형 넓이를 반환하는 함수
        hFences.extend([1, m])                                                  # 가로 펜스에 필드 상하 경계(1, m)를 추가
        vFences.extend([1, n])                                                  # 세로 펜스에 필드 좌우 경계(1, n)를 추가

        stt = set()                                                             # 가로 펜스 거리(가능한 변 길이 후보)를 저장할 집합 초기화
        ans = 0                                                                 # 가능한 최대 변 길이를 저장할 변수 초기화

        for i in range(len(hFences)):                                           # 가로 펜스의 모든 쌍을 만들기 위해 i를 순회
            for j in range(i + 1, len(hFences)):                                # i보다 큰 인덱스 j를 순회하며
                stt.add(abs(hFences[j] - hFences[i]))                           # 두 가로 펜스 사이의 거리를 집합에 추가
        
        for i in range(len(vFences)):                                           # 세로 펜스의 모든 쌍을 만들기 위해 i를 순회
            for j in range(i + 1, len(vFences)):                                # i보다 큰 인덱스 j를 순회하며
                val = abs(vFences[j] - vFences[i])                              # 두 세로 펜스 사이의 거리를 계산
                if val in stt:                                                  # 해당 거리가 가로 거리 집합에도 존재하면 정사각형 변 후보가 됨
                    ans = max(ans, val)                                         # 가능한 변 길이의 최댓값을 갱신
        
        if ans == 0:                                                            # 공통 거리가 없어서 정사각형을 만들 수 없는 경우
            return -1                                                           # 문제 요구에 따라 -1 반환
        return (ans * ans) % (10**9 + 7)                                        # 최대 변 길이의 제곱을 MOD로 나누어 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: 두 집합(가로/세로 거리)의 교집합에서 최댓값 찾기, 해시셋으로 빠른 포함 검사.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(H^2 + V^2)  (H=len(hFences), V=len(vFences) 기준의 모든 쌍 거리 계산)
#   - 공간: O(H^2)        (가로 거리 집합 저장)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 거리 후보를 전부 만들지 않고, 정렬 후 차이들을 효율적으로 생성/검사하는 방식이나,
#     입력 크기가 큰 경우 비트셋/좌표 압축 기반 최적화도 고려할 수 있다 (개념만).
