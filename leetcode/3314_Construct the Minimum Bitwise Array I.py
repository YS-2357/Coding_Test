# 3314_Construct the Minimum Bitwise Array I.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3314. Construct the Minimum Bitwise Array I
# 🏷️ 유형: 비트연산 / 그리디
#
# ✅ 문제 설명(요약):
#   - 각 nums[i]에 대해, 특정 비트 조건을 만족하는 “가장 작은 값”을 구성해 배열로 반환한다.
#   - 조건을 만족하는 값이 없으면 -1을 사용한다.
#
# ✅ 입력 형식(요지):
#   - nums: List[int]
#
# ✅ 규칙 요약:
#   - nums[i]의 비트 패턴에서, 최하위부터 연속된 1 비트 구간을 확인하며 후보를 만든다.
#   - (nums[i] & d) != 0 인 동안 d(1, 2, 4, ...)를 키우면서 nums[i] - d를 후보로 갱신한다.
#   - 처음으로 0 비트를 만나는 순간 반복을 멈추고, 마지막으로 갱신된 후보(res)를 결과로 사용한다.
#   - 후보가 한 번도 갱신되지 않으면(res가 -1이면) -1을 유지한다.
#
# 🧠 핵심 불변식(Invariant):
#   - d는 항상 2의 거듭제곱(단일 비트)이며, 현재 검사 중인 비트 위치를 나타낸다.
#   - while 루프는 nums[i]의 “연속된 1 비트(prefix of ones)”가 끝나는 지점에서 종료된다.
#   - res는 마지막으로 확인된 1 비트 위치 d에 대해 nums[i] - d로 갱신된 값이므로,
#     루프 종료 시점의 res가 이 로직이 선택한 최소 후보가 된다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                                     # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def minBitwiseArray(self, nums: List[int]) -> List[int]:        # 각 원소에 대한 최소 비트 조건 배열을 반환하는 함수
        for i in range(len(nums)):                                  # nums의 모든 인덱스 i를 순회
            res = -1                                                # 현재 원소의 결과 값을 -1로 초기화
            d = 1                                                   # 검사할 비트 마스크를 최하위 비트(1)로 초기화
            while (nums[i] & d) != 0:                               # 현재 비트가 1인 동안 반복
                res = nums[i] - d                                   # 해당 비트를 기준으로 nums[i] - d를 후보로 갱신
                d <<= 1                                             # 다음 비트를 검사하기 위해 마스크를 왼쪽으로 1칸 이동
            nums[i] = res                                           # 루프 종료 후 결정된 결과(res)를 nums[i]에 저장
        return nums                                                 # 수정된 nums 배열을 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: 비트 마스크로 최하위부터 연속된 1 비트 구간을 탐색하는 그리디 구성.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(n * b)  (b는 각 수에서 연속된 1 비트 길이; 최악 비트 수만큼)
#   - 공간: O(1)      (제자리 수정)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 연속된 1 비트의 마지막 위치를 비트 트릭으로 직접 구해 한 번에 계산하는 방식도 가능하다(개념만).
