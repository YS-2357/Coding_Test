# 3651_Minimum Cost Path with Teleportations.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3651. Minimum Cost Path with Teleportations
# 🏷️ 유형: DP / 값-그룹 스위프(텔레포트 전파) / 반복 완화
#
# ✅ 문제 설명(요약):
#   - grid에서 (0,0) → (m-1,n-1)로 이동할 때의 최소 비용을 구한다.
#   - 기본 이동은 위/왼쪽에서 현재 칸으로 오는 형태로 누적하며, 각 칸 비용(grid[i][j])이 더해진다.
#   - 추가로 최대 k번, 같은 값(=grid 값)을 가진 칸들 사이로 “텔레포트”가 가능한 효과를
#     값 내림차순 그룹 스위프로 모델링하여 dp를 완화한다.
#
# ✅ 입력 형식(요지):
#   - grid: List[List[int]]
#   - k: int
#
# ✅ 규칙 요약:
#   - dp[i][j]는 (0,0)에서 (i,j)까지 도달하는 최소 누적 비용을 의미한다.
#   - update()는 위/왼쪽 경로를 이용해 dp를 한 번 전체 완화(relax)한다.
#   - 텔레포트 단계는 값이 큰 그룹부터 작은 그룹으로 내려가며, 각 값 그룹의 dp를 “그 그룹의 최소 dp”로 평탄화한다.
#
# 🧠 핵심 불변식(Invariant):
#   - update() 이후 dp[i][j]는 “위/왼쪽 경로만” 고려한 최소값으로 단조 감소(개선)할 수 있다.
#   - 텔레포트 스위프는 같은 값 그룹 내부 dp를 최솟값으로 맞추며, 다음 update()에서 그 개선이 전파된다.
#   - 이 과정을 k번 반복하면 “텔레포트 사용 ≤ k”에 해당하는 완화가 반영된다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                                                 # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def minCost(self, grid: List[List[int]], k: int) -> int:                    # 격자에서 텔레포트를 최대 k번 고려한 최소 비용을 반환하는 함수
        m, n = len(grid), len(grid[0])                                          # 격자의 행/열 크기를 m, n으로 저장
        d = defaultdict(list)                                                   # 값별로 좌표들을 모아둘 딕셔너리를 초기화
        for i in range(m):                                                      # 모든 행 인덱스 i를 순회
            for j in range(n):                                                  # 모든 열 인덱스 j를 순회
                d[grid[i][j]].append((i, j))                                    # grid 값별로 (i, j) 좌표를 리스트에 추가
        
        inf = float('inf')                                                      # 무한대 값(초기화/경계 처리용)을 설정
        dp = [[inf] * n for _ in range(m)]                                      # dp 배열을 inf로 초기화(도달 비용 미정 상태)
        dp[0][0] = 0                                                            # 시작점 (0,0)의 누적 비용을 0으로 설정
        def update():                                                           # 위/왼쪽 기반 경로로 dp를 한 번 완화하는 내부 함수 정의
            for i in range(m):                                                  # 모든 행 i를 순회하며 dp를 갱신
                for j in range(n):                                              # 모든 열 j를 순회하며 dp를 갱신
                    temp = grid[i][j] + min(                                    # 현재 칸 비용 + (위/왼쪽에서 오는 최소 비용)으로 후보 계산
                        dp[i-1][j] if i else inf,                               # 위에서 오는 비용(첫 행이면 불가능 처리)
                        dp[i][j-1] if j else inf                                # 왼쪽에서 오는 비용(첫 열이면 불가능 처리)
                    )                                                           # 두 후보 중 작은 값을 선택
                    if temp < dp[i][j]: dp[i][j] = temp                         # 후보가 더 작으면 dp[i][j]를 갱신
        update()                                                                 # 초기 상태에서 위/왼쪽 이동만으로 dp를 한 번 계산

        keys = sorted(d, reverse=True)                                          # 값 그룹을 내림차순으로 정렬(스위프 순서 고정)
        for _ in range(k):                                                      # 텔레포트 완화 과정을 최대 k번 반복
            dist = inf                                                          # 현재까지의 “상위(큰 값) 그룹들에서의 최소 dp”를 저장할 변수
            for key in keys:                                                    # 큰 값부터 작은 값으로 각 그룹 key를 순회
                for i, j in d[key]:                                             # 현재 값 그룹의 모든 좌표를 순회
                    if dp[i][j] < dist: dist = dp[i][j]                         # dist를 (현재까지) 최소 dp로 갱신
                for i, j in d[key]:                                             # 현재 값 그룹의 모든 좌표를 다시 순회
                    dp[i][j] = dist                                             # 그룹 내부 dp를 dist로 평탄화(텔레포트 효과 반영)
            update()                                                             # 텔레포트로 낮아진 dp를 위/왼쪽 경로로 다시 전파
        return dp[-1][-1]                                                       # 도착점 (m-1,n-1)의 최소 비용을 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: dp 완화(update) + 값 내림차순 그룹 스위프를 통한 텔레포트 비용 전파.
#
# 📚 시간·공간 복잡도:
#   - 시간: O((k+1) * m * n) 수준(각 반복에서 그룹 순회 + update 전체 순회)
#   - 공간: O(m * n) (dp 및 값→좌표 그룹 저장)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 값 그룹 스위프와 전파를 더 엄밀한 그래프 최단경로(상태=텔레포트 사용 횟수)로 모델링할 수도 있다(개념만).
