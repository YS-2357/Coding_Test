# 1925_Count_Square_Sum_Triples.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 1925. Count Square Sum Triples
# -----------------------------------------------------
# ✅ 문제 설명(요약):
#   - 양의 정수 n이 주어졌을 때,
#     1 ≤ a, b, c ≤ n 을 만족하는 정수 (a, b, c) 중에서
#       a² + b² = c²
#     를 만족하는 순서쌍(ordered triple)의 개수를 구하는 문제이다.
#   - (a, b, c)는 순서가 있는 triplet이므로,
#     (a, b, c)와 (b, a, c)는 서로 다른 경우로 센다(조건만 만족하면 둘 다 카운트).
#
# ✅ 입력 형식(요지):
#   - n: int
#       · 1 ≤ n ≤ 250
#
# ✅ 규칙 요약:
#   - 1 ≤ a ≤ n, 1 ≤ b ≤ n, 1 ≤ c ≤ n
#   - a² + b² = c² 를 만족하면 정답 카운트 +1
#   - (a, b, c)와 (b, a, c)는 서로 다른 경우로 계산한다.
#
# -----------------------------------------------------
# ✅ 정답 코드(나의 풀이; 절대 수정 금지, 주석만 추가)
# -----------------------------------------------------

class Solution:
    def countTriples(self, n: int) -> int:
        ans = 0                              # 조건을 만족하는 (a, b, c) triplet 개수를 누적할 변수

        for a in range(1, n+1):              # a를 1부터 n까지 순회
            for b in range(1, n+1):          # b를 1부터 n까지 순회 (a와 독립적으로 전 범위 탐색)
                # a^2 + b^2 값에 대해, 그 근사 제곱근을 이용해 c를 추정
                # +1을 더한 후 sqrt를 취하는 것은 소수점 보정/안정성을 의도한 것으로 보이지만,
                # 실제로는 int(sqrt(a*a + b*b))만으로도 충분하다.
                c = int(sqrt(a * a + b * b + 1))

                # c가 범위 [1..n] 이내이고, c^2가 정확히 a^2 + b^2 와 같다면 조건을 만족하는 triplet
                if c <= n and c*c == a*a + b*b:
                    ans += 1                 # 유효한 (a, b, c) 하나를 찾았으므로 카운트 증가

        return ans                           # 최종적으로 찾은 triplet 개수 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 이중 반복문으로 모든 (a, b) 쌍을 탐색하면서,
#     sqrt를 이용해 c를 역으로 추정한 뒤 c^2 == a^2 + b^2 여부를 확인하는 방식.
#   - n ≤ 250 이므로 O(n^2) 탐색이 충분히 가능하며, 논리적으로는 정답을 구할 수 있다.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - (잠재적 이슈)
#       · 코드 상에서는 sqrt 함수에 대한 import가 없으므로,
#         실제 실행 시에는 NameError가 발생할 수 있다(실제 제출 시에는 math.sqrt를 import 필요).
#       · 또한 c 계산에서 +1을 더한 후 sqrt를 취하는 부분은
#         떠다니는 부동소수점 오차를 고려한 듯 보이지만, 이 문제 범위에서는
#         int(sqrt(a*a + b*b))만으로도 충분히 안전하게 검사 가능하다.
#   - 사용 개념:
#       1) 브루트 포스 탐색(brute force):
#          - a, b를 전 범위 순회하면서 가능한 모든 조합을 확인.
#       2) 피타고라스 정리 체크:
#          - a² + b² = c² 형태인지 확인.
#       3) 범위 제한:
#          - c ≤ n 조건을 통해 불필요한 카운트를 방지.
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도:
#       · a: 1..n, b: 1..n 이중 루프 → O(n^2)
#       · n ≤ 250 이므로 최대 62,500번의 검사로 충분히 빠름.
#   - 공간 복잡도:
#       · 추가적인 배열/자료구조 없이 ans, a, b, c 등만 사용 → O(1)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - c를 1..n 범위에서 먼저 고정하고, a를 1..c-1 범위에서 순회 후
#     b² = c² - a² 의 정수성 검사로 바꾸는 방식도 가능하다.
#   - 혹은 a ≤ b 조건을 강제해 중복을 절반으로 줄이고,
#     최종 결과에 2를 곱해 주는 식으로 최적화할 수 있다.
#   - 하지만 n이 작기 때문에 현재 O(n^2) 브루트 포스 방식도 충분히 효율적이다.
# -----------------------------------------------------
