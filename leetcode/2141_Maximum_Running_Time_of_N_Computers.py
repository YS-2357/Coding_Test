# 2141_Maximum_Running_Time_of_N_Computers.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 2141. Maximum Running Time of N Computers
#
# ✅ 문제 설명(요약):
#   - n대의 컴퓨터를 동시에 켜기 위해 여러 배터리를 자유롭게 교체·분배해 사용한다.
#   - 각 배터리의 용량이 batteries 리스트로 주어진다.
#   - n대를 동시에 켤 수 있는 "최대 연속 실행 시간 T"를 구하는 문제.
#
# ✅ 입력 형식(요지):
#   - n: 컴퓨터 개수 (int)
#   - batteries: 배터리 용량 리스트 (List[int])
#
# ✅ 규칙 요약:
#   - 한 배터리는 최대 자기 용량만큼만 기여할 수 있음.
#   - 시간 T가 가능하려면 Σ min(b[i], T) ≥ n * T 조건을 만족해야 함.
#   - T의 가능 여부가 단조적이므로 이분 탐색 사용 가능.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
class Solution:
    def maxRunTime(self, n: int, batteries: List[int]) -> int:
        ub = sum(batteries) // n          # 가능한 최대 상한: 총 배터리량/n
        lb = min(batteries)               # 가능한 최소 하한(0으로 잡아도 무방)

        while lb <= ub:
            mid = (lb + ub) // 2          # 현재 후보 실행 시간(mid)
            total = 0

            for b in batteries:
                total += min(b, mid)      # 각 배터리는 최대 mid까지 기여 가능

            if total >= n * mid:          # mid시간 동안 n대를 켤 수 있으면
                ans = mid                 # mid는 유효한 실행 시간
                lb = mid + 1              # 더 긴 시간이 가능한지 오른쪽 탐색
            else:
                ub = mid - 1              # mid 불가능 → 더 짧은 쪽으로 이동
        
        return ans                        # 가능한 최대 실행 시간

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 이분 탐색 구조와 가능 판별식이 정확하여 바로 정답 처리.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음. 핵심 아이디어는 Σ min(b, T) ≥ n * T 검증 후 이분 탐색.
#   - 사용 개념: 이분 탐색(Binary Search), 그리디 합산(min(b, T)), 배열 합 계산.
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도: O(n log S)
#       * S = sum(batteries)//n (탐색 범위)
#       * 각 mid에서 배터리 전체 순회 O(n)
#   - 공간 복잡도: O(1)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 그리디 + 정렬 기반으로도 접근 가능하지만, 최종적으로 이분 탐색 방식이 가장 명확함.
