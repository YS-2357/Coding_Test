# 1161_Maximum Level Sum of a Binary Tree.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 1161. Maximum Level Sum of a Binary Tree
# 🏷️ 유형: 트리 / BFS / 레벨 순회
#
# ✅ 문제 설명(요약):
#   - 이진 트리가 주어질 때,
#   - 각 레벨별 노드 값의 합을 계산하여
#   - 합이 최대가 되는 레벨 번호(1-indexed)를 반환한다.
#
# ✅ 입력 형식(요지):
#   - root: 이진 트리의 루트 노드
#
# ✅ 규칙 요약:
#   - 레벨 번호는 1부터 시작한다.
#   - 최대 합이 여러 레벨에서 같다면 가장 작은 레벨 번호를 반환한다.
#
# 🧠 핵심 불변식(Invariant):
#   - 큐에는 항상 같은 레벨의 노드들만 들어 있다.
#   - 한 번의 while 루프는 정확히 하나의 레벨을 처리한다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                                   # LeetCode 제출을 위한 Solution 클래스 정의
    def maxLevelSum(self, root: Optional[TreeNode]) -> int:       # 최대 레벨 합을 가지는 레벨 번호를 반환하는 함수
        ans = 1                                                   # 최대 합을 가진 레벨 번호를 저장할 변수 초기화
        cur_lvl = 1                                               # 현재 탐색 중인 레벨 번호 초기화
        cur_max = -10**6                                          # 레벨 합의 최댓값을 저장할 변수 초기화
        
        q = deque([root])                                         # BFS를 위한 큐에 루트 노드를 초기 상태로 삽입

        while q:                                                  # 큐가 빌 때까지 레벨 단위로 반복
            cur_sum = 0                                           # 현재 레벨의 노드 값 합을 저장할 변수
            cur_size = len(q)                                     # 현재 레벨에 포함된 노드 개수 저장

            for _ in range(cur_size):                             # 현재 레벨의 모든 노드를 처리
                node = q.popleft()                                # 큐에서 하나의 노드를 꺼냄
                cur_sum += node.val                               # 해당 노드의 값을 현재 레벨 합에 더함

                if node.left:                                     # 왼쪽 자식이 존재하는 경우
                    q.append(node.left)                           # 다음 레벨 탐색을 위해 큐에 추가
                if node.right:                                    # 오른쪽 자식이 존재하는 경우
                    q.append(node.right)                          # 다음 레벨 탐색을 위해 큐에 추가
                
            if cur_sum > cur_max:                                 # 현재 레벨 합이 기존 최대값보다 큰 경우
                cur_max = cur_sum                                 # 최대 합을 현재 레벨 합으로 갱신
                ans = cur_lvl                                     # 최대 합을 만든 레벨 번호로 갱신
            
            cur_lvl += 1                                          # 다음 레벨로 이동하기 위해 레벨 번호 증가

        return ans                                                # 최대 레벨 합을 가진 레벨 번호 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: BFS를 이용한 레벨 순회(Level Order Traversal).
#
# 📚 시간·공간 복잡도:
#   - 시간: O(n)  (모든 노드를 정확히 한 번 방문)
#   - 공간: O(n)  (큐에 최악의 경우 한 레벨의 노드 저장)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - DFS로 각 노드의 깊이를 기록하며 레벨별 합을 누적하는 방식도 가능하다.
