# 717_1_bit_and_2_bit_Characters.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 717. 1-bit and 2-bit Characters
# ✅ 문제 설명(요약):
#   - 비트 배열 bits가 주어졌을 때, 전체 비트 스트림이 다음 두 종류의 문자들로만 구성된다고 가정한다.
#     1) 1-bit 문자: 0
#     2) 2-bit 문자: 10 또는 11
#   - bits를 왼쪽부터 규칙에 맞게 문자 단위(1비트/2비트)로 나누어 해석했을 때,
#     마지막 비트 bits[-1]이 "1-bit 문자(0) 하나만으로 구성된 문자"인지 여부를 반환하는 문제이다.
#
# ✅ 입력 형식(요지):
#   - bits: List[int]
#     - 각 원소는 0 또는 1
#     - bits는 위 두 규칙(0, 10, 11)로만 해석 가능한 유효한 비트 스트림이라고 가정
#
# ✅ 규칙 요약:
#   - 1-bit 문자: 0  → 비트 하나로 문자 하나
#   - 2-bit 문자: 10, 11 → 항상 두 비트가 붙어서 한 문자
#   - bits를 왼쪽에서부터 차례로 읽으면서
#     - 0을 만나면 한 칸(i += 1)
#     - 1을 만나면 두 칸(i += 2)
#   - 최종적으로 마지막 비트가 "1비트 문자"의 시작이자 끝(단독 0)인지를 판별해야 한다.
#
# ✅ 정답 코드(나의 원본 풀이; 절대 수정 금지)
#   - 아래 코드는 비트 스트림을 실제 문자 단위(0, 10, 11)로 파싱한 뒤,
#     마지막 파싱 결과가 0인지(=1-bit 문자) 여부로 정답을 판별하는 방식이다.

class Solution:
    def isOneBitCharacter(self, bits: List[int]) -> bool:
        if bits[-1] == 1:                # 마지막 비트가 1이면, 1-bit 문자(0)로 끝날 수 없으므로 바로 False
            return False

        n = len(bits)                    # 비트 배열의 길이
        i = 0                            # 현재 읽고 있는 인덱스(포인터)
        scan = []                        # 파싱된 문자들을 저장할 리스트 (0, 10, 11 형태로 저장)

        while i < n:                     # 비트 스트림 전체를 왼쪽에서 오른쪽으로 한 번 순회
            if bits[i] == 1:             # 현재 비트가 1이면, 반드시 2-bit 문자(10 또는 11)의 시작
                scan.append(bits[i] * 10 + bits[i+1])
                # 예: bits[i]=1, bits[i+1]=0 → 10, bits[i+1]=1 → 11 형태로 정수로 저장
                i += 2                   # 2비트를 하나의 문자로 소비했으므로 인덱스를 두 칸 전진
            else:
                scan.append(bits[i])     # bits[i]가 0이면 1-bit 문자이므로 그대로 0을 저장
                i += 1                   # 한 비트만 사용했으므로 한 칸 전진
        
        # print(scan)                    # 디버깅용: 파싱된 문자 리스트(0, 10, 11)를 확인하기 위한 출력 (주석 처리)

        return True if scan[-1] == 0 else False
        # 파싱된 문자들 중 마지막 문자가 0이면 → 마지막 문자가 1-bit 문자(0)이므로 True
        # 마지막 문자가 10 또는 11이면 → 마지막 비트는 2-bit 문자에 포함된 것이므로 False


# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 비트 스트림을 실제 문자 단위(0, 10, 11)로 완전히 파싱한 뒤,
#     마지막 파싱 결과가 0인지 여부로 정답을 판별하는 방식이다.
#   - 마지막 비트가 1인 경우는 애초에 마지막 문자가 1-bit 문자(0)가 될 수 없으므로
#     초기에 바로 False를 반환하는 조건을 둠으로써 불필요한 파싱을 줄였다.
#   - 전체 파싱 로직은 문제의 정의(0, 10, 11로만 구성)를 정확히 반영하고 있어
#     다양한 테스트 케이스에 대해 논리적으로 일관된 결과를 낸다.

# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 이 풀이 자체는 문제 정의에 맞추어 올바르게 동작하며, 알고리즘적 오류는 없다.
#   - 다만 scan 리스트에 모든 문자(0, 10, 11)를 저장하고 마지막 원소만 사용하는 구조라
#     공간 측면에서 최적은 아니고, 마지막 문자가 0인지 여부만 필요하다는 점을 고려하면
#     "마지막 도달 위치"만 추적하는 구현으로 더 단순화할 수는 있다.
#   - 사용한 개념:
#     - 비트 스트림 파싱(Parsing): 규칙(0, 10, 11)에 맞추어 왼쪽에서부터 순차적으로 문자를 끊어 나감.
#     - 그리디 스캔(Greedy scan): 앞에서부터 가능한 한 빨리 규칙에 맞는 가장 긴 단위를 선택하며 진행.
#     - 인덱스 기반 시뮬레이션: 포인터 i를 1칸 또는 2칸씩 이동시키며 실제 해석 과정을 그대로 모사.

# 📚 시간·공간 복잡도:
#   - 시간 복잡도: O(n)
#     - i가 0에서 시작해 매 반복마다 1 또는 2씩 증가하므로, 각 비트는 최대 한 번만 읽힌다.
#     - 따라서 전체 순회 횟수는 비트 개수 n에 비례한다.
#   - 공간 복잡도: O(n)
#     - scan 리스트에 파싱한 문자들을 모두 저장하므로,
#       최악의 경우 각 문자가 0(길이 1)인 경우 n개의 원소가 들어갈 수 있다.
#     - 실제로는 마지막 원소만 필요하므로, 이 부분은 O(1)로 줄일 수 있는 여지가 있다.

# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 더 효율적인(공간 측면에서 최적) 접근:
#     - scan 리스트를 만들지 않고, 단순히 인덱스 i를 이동시키는 방식으로 해결할 수 있다.
#     - 예를 들어,
#       - i를 0에서 시작해 bits의 마지막 인덱스 직전까지만(i < n-1) 순회하면서
#         - bits[i]가 0이면 i += 1
#         - bits[i]가 1이면 i += 2
#       - 순회가 끝난 뒤 i가 정확히 n-1에 도달하면 마지막 문자는 1-bit 문자(0),
#         그렇지 않다면 마지막 비트는 이전 2-bit 문자에 포함된 것이 된다.
#     - 이 방식은 여전히 시간 복잡도는 O(n)이지만, 추가 공간을 사용하지 않으므로 공간 복잡도는 O(1)이다.
