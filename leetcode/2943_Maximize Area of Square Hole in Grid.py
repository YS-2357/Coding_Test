# 2943_Maximize Area of Square Hole in Grid.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 2943. Maximize Area of Square Hole in Grid
# 🏷️ 유형: 정렬 / 연속 구간(런 길이) / 그리디
#
# ✅ 문제 설명(요약):
#   - n×m 격자에서 일부 가로/세로 바(막대)를 제거할 수 있을 때,
#   - 제거된 연속 막대 구간이 만들어내는 “가장 큰 정사각형 구멍”의 넓이를 구한다.
#
# ✅ 입력 형식(요지):
#   - n, m: 격자 크기 관련 정수
#   - hBars: 제거되는 가로 바 인덱스 리스트
#   - vBars: 제거되는 세로 바 인덱스 리스트
#
# ✅ 규칙 요약:
#   - 연속으로 제거된 가로 바의 최대 길이와 세로 바의 최대 길이를 구한다.
#   - 만들 수 있는 정사각형 한 변 길이는 min(가로연속, 세로연속) + 1 이다.
#   - 넓이는 (한 변 길이)^2 이다.
#
# 🧠 핵심 불변식(Invariant):
#   - 정렬 후 인접 원소가 1 차이면 “연속 제거” 구간이 이어진다.
#   - 최대 연속 길이(hmax, vmax)를 구하면 정사각형의 최대 한 변 길이는 min(hmax, vmax) + 1로 결정된다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                                                 # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def maximizeSquareHoleArea(self, n: int, m: int, hBars: List[int], vBars: List[int]) -> int:  # 최대 정사각형 구멍 넓이를 반환하는 함수
        hBars.sort()                                                            # 가로 바 제거 인덱스를 정렬하여 연속 구간을 쉽게 찾음
        vBars.sort()                                                            # 세로 바 제거 인덱스를 정렬하여 연속 구간을 쉽게 찾음
        hmax, vmax = 1, 1                                                       # 가로/세로의 최대 연속 제거 길이를 1로 초기화
        hcur, vcur = 1, 1                                                       # 현재 연속 구간 길이를 추적하는 변수 초기화

        for i in range(1, len(hBars)):                                          # 가로 바 리스트에서 인접 원소를 비교하며 순회
            if hBars[i] == hBars[i - 1] + 1:                                    # 현재 값이 이전 값보다 1 크면 연속 구간 유지
                hcur += 1                                                       # 현재 가로 연속 길이를 1 증가
            else:                                                                # 연속이 끊기면
                hcur = 1                                                        # 현재 연속 길이를 1로 초기화
            hmax = max(hmax, hcur)                                              # 가로 최대 연속 길이를 갱신
        
        for i in range(1, len(vBars)):                                          # 세로 바 리스트에서 인접 원소를 비교하며 순회
            if vBars[i] == vBars[i - 1] + 1:                                    # 현재 값이 이전 값보다 1 크면 연속 구간 유지
                vcur += 1                                                       # 현재 세로 연속 길이를 1 증가
            else:                                                                # 연속이 끊기면
                vcur = 1                                                        # 현재 연속 길이를 1로 초기화
            vmax = max(vmax, vcur)                                              # 세로 최대 연속 길이를 갱신
        
        return (min(hmax, vmax) + 1) ** 2                                       # 가능한 최대 정사각형 한 변 길이로 넓이를 계산해 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: 정렬 후 연속 구간 길이(런 길이) 계산, 한 변은 min(가로, 세로)로 결정되는 그리디.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(h log h + v log v)  (정렬 비용, h=len(hBars), v=len(vBars))
#   - 공간: O(1)                  (정렬이 제자리 정렬 기준일 때 추가 공간은 상수)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 정렬 대신 boolean 배열/비트셋으로 표시한 뒤 연속 구간을 스캔하는 방법도 가능하나,
#     입력 크기에 따라 메모리 비용이 커질 수 있다.
