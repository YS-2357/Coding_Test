# 0712_Minimum ASCII Delete Sum for Two Strings.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 712. Minimum ASCII Delete Sum for Two Strings
# 🏷️ 유형: DP / LCS 변형
#
# ✅ 문제 설명(요약):
#   - 두 문자열 s1, s2를 같게 만들기 위해 문자를 삭제할 수 있다.
#   - 삭제 비용은 삭제한 문자의 ASCII 값(= ord)이며, 총 삭제 비용의 최솟값을 구한다.
#
# ✅ 입력 형식(요지):
#   - s1: 문자열
#   - s2: 문자열
#
# ✅ 규칙 요약:
#   - 삭제만 가능하며, 남겨진 문자들의 순서는 유지된다.
#   - 두 문자열에서 공통으로 남길 부분수열을 선택하는 관점으로 볼 수 있다.
#
# 🧠 핵심 불변식(Invariant):
#   - dp[i][j]는 s1의 앞 i글자와 s2의 앞 j글자에서 만들 수 있는 “공통 부분수열의 ASCII 합”의 최댓값이다.
#   - 최솟 삭제 합 = (s1 전체 ASCII 합 + s2 전체 ASCII 합) - 2 * (공통으로 남길 ASCII 합의 최댓값) 이다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                              # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def minimumDeleteSum(self, s1: str, s2: str) -> int:      # 두 문자열을 같게 만들기 위한 최소 ASCII 삭제 합을 구하는 함수
        n, m = len(s1), len(s2)                               # s1, s2의 길이를 각각 n, m으로 저장

        dp = [[0] * (m+1) for _ in range(n+1)]                # dp 테이블을 0으로 초기화하여 공통 ASCII 합 최대값을 저장

        for i in range(n):                                    # s1의 각 인덱스를 순회하며
            for j in range(m):                                # s2의 각 인덱스를 순회하며
                if s1[i] == s2[j]:                            # 현재 문자가 서로 같다면
                    dp[i+1][j+1] = dp[i][j] + ord(s1[i])      # 공통 부분수열에 이 문자를 추가한 ASCII 합으로 갱신
                else:                                         # 현재 문자가 서로 다르다면
                    dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j])# 한쪽 문자를 건너뛴 경우 중 공통 ASCII 합이 큰 값을 선택
        
        total = sum(ord(c) for c in s1) + sum(ord(c) for c in s2)  # 두 문자열 전체 ASCII 합을 계산
        
        return total - 2 * dp[n][m]                            # 전체 합에서 공통으로 남길 최대 ASCII 합을 2번 빼서 최소 삭제 합 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: LCS(최장 공통 부분수열) DP를 “길이”가 아닌 “ASCII 합” 최대로 변형한 DP.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(n*m)  (2중 루프 DP)
#   - 공간: O(n*m)  (dp 테이블)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - dp를 1차원으로 압축하여 O(m) 공간으로 줄이는 최적화도 가능하다 (개념만).
