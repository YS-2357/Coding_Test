# 3606_coupon_code_validator.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3606 - Coupon Code Validator
#
# ✅ 문제 설명(요약):
#   - 쿠폰 코드, 비즈니스 라인, 활성 여부가 각각 배열로 주어진다.
#   - 특정 규칙을 만족하는 쿠폰 코드만 유효하다고 판단한다.
#   - 유효한 쿠폰들을 비즈니스 라인 우선순위에 따라 정렬하여 반환한다.
#
# ✅ 입력 형식(요지):
#   - code: 쿠폰 코드 문자열 리스트
#   - businessLine: 각 쿠폰의 비즈니스 라인 문자열 리스트
#   - isActive: 각 쿠폰의 활성 여부(Boolean) 리스트
#
# ✅ 규칙 요약:
#   - 쿠폰 코드 문자열은 비어 있으면 안 된다.
#   - 쿠폰은 활성 상태(isActive == True)여야 한다.
#   - 쿠폰 코드는 영문자/숫자/언더스코어(_)만 포함해야 한다.
#   - 비즈니스 라인은 미리 정의된 4개 중 하나여야 한다.
#   - 유효한 쿠폰만 추출 후, 비즈니스 라인 우선순위 기준으로 정렬한다.
#
# -----------------------------------------------------
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
#   - 아래 코드는 사용자가 제출한 최종 코드이며,
#     로직은 변경하지 않고 주석으로만 설명을 추가한다.

class Solution:
    def validateCoupons(self, code: List[str], businessLine: List[str], isActive: List[bool]) -> List[str]:
        # 비즈니스 라인별 우선순위 정의 (숫자가 작을수록 우선순위 높음)
        priority = {
            "electronics": 0,
            "grocery": 1,
            "pharmacy": 2,
            "restaurant": 3,
        }

        ans = []  # (우선순위, 쿠폰코드) 형태로 담을 리스트

        # 세 리스트를 동시에 순회하며 각 쿠폰을 검사
        for c, b, a in zip(code, businessLine, isActive):
            # 유효성 조건:
            # 1) 쿠폰 코드가 비어 있지 않을 것
            # 2) 활성 상태일 것
            # 3) 쿠폰 코드가 영문자/숫자/_ 로만 구성될 것
            # 4) 비즈니스 라인이 priority에 정의된 값일 것
            if c and a and all(s.isalnum() or s == "_" for s in c) and b in priority:
                # 조건을 만족하면 (우선순위, 쿠폰코드) 형태로 저장
                ans.append((priority[b], c))

        # 우선순위(첫 번째 원소)를 기준으로 정렬
        ans.sort()

        # 정렬된 결과에서 쿠폰 코드만 추출하여 반환
        return [c for _, c in ans]

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 문자열 검증과 정렬 조건을 동시에 만족시키는 간단한 필터링 문제.
#   - zip을 활용해 입력 배열 간 동기화된 순회가 명확하게 이루어짐.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 핵심 개념:
#       - 문자열 검증: all + isalnum 조합으로 허용 문자 집합 확인
#       - 우선순위 정렬: (priority, value) 튜플 정렬
#   - 주의 포인트:
#       - 언더스코어(_)는 isalnum()에 포함되지 않으므로 별도 조건 필요
#       - 비즈니스 라인 문자열이 사전에 정의된 집합에 속하는지 확인 필수
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도:
#       - 유효성 검사: O(n * L) (n = 쿠폰 수, L = 평균 쿠폰 코드 길이)
#       - 정렬: O(n log n)
#       - 전체: O(n * L + n log n)
#   - 공간 복잡도:
#       - 결과 리스트 ans: O(n)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 비즈니스 라인 우선순위가 고정되어 있으므로,
#     bucket sort(라인별 리스트)에 담아 순서대로 합치는 방식도 가능하다.
#   - 다만 n이 크지 않다면 현재 방식이 가장 직관적이고 충분히 효율적이다.
