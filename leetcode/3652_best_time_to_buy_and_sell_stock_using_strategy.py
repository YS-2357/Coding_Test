# 3652_best_time_to_buy_and_sell_stock_using_strategy.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3652 - Best Time to Buy and Sell Stock using Strategy
#
# ✅ 문제 설명(요약):
#   - prices와 strategy가 주어졌을 때, 기본 수익(base)을 계산한다. (base = sum(prices[i] * strategy[i]))
#   - 길이 k의 연속 구간을 하나 선택해 전략을 특정 규칙으로 변경하여 수익을 최대로 만든다.
#   - 변경으로 인한 이득(변화량 diff)의 최댓값을 구해 base + diff를 반환한다.
#
# ✅ 입력 형식(요지):
#   - prices: 각 시점의 가격 배열
#   - strategy: 각 시점의 전략 값 배열 (-1, 0, 1)
#   - k: 변경할 연속 구간 길이
#
# ✅ 규칙 요약:
#   - 선택한 길이 k 구간에 대해, 구간 전/후반(h = k//2)로 나뉘며,
#     기존 전략에 의한 기여(old)와 변경 후 기여(new)의 차이(new-old)를 최대화한다.
#   - 최종 답은 base + max(0, new-old)의 최댓값.
#
# -----------------------------------------------------
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
#   - 아래는 사용자가 제출/채택한 최종 정답 코드이며,
#     이 단계에서는 코드 내용을 변경하지 않고,
#     각 줄마다 설명 주석만 추가한다.

class Solution:
    def maxProfit(self, prices: List[int], strategy: List[int], k: int) -> int:
        ps = [p * s for p, s in zip(prices, strategy)]  # 기본 전략 기여값 배열 ps[i] = prices[i] * strategy[i]
        n = len(prices)                                 # 전체 길이

        base = sum(ps)                                  # 기본 수익(전략 변경 전 총합)
        h = k // 2                                      # 구간을 전/후반으로 나누는 기준 (앞 절반 길이)

        old = sum(ps[:k])                               # 초기 윈도우(0..k-1)에서의 "기존 전략 기여" 합
        new = sum(prices[h:k])                          # 초기 윈도우에서 "변경 후 기여"로 계산되는 부분 합
                                                       # (구간 후반 [h..k-1]을 +1로 본 기여로 해석되는 합)

        diff = max(0, new - old)                        # 첫 윈도우에서의 이득(변화량) 후보 (이득이 음수면 0)

        # 오른쪽 끝을 k부터 n-1까지 이동시키며 길이 k 슬라이딩 윈도우 수행
        for right in range(k, n):
            left = right - k + 1                        # 현재 윈도우의 왼쪽 인덱스

            # old 갱신:
            # - 윈도우에 새로 들어온 ps[right]를 더하고
            # - 윈도우에서 빠져나간 ps[left-1]를 뺀다
            old += ps[right] - ps[left - 1]

            # new 갱신:
            # - 변경 후 기여에서 새로 포함되는 prices[right]를 더한다
            # - 변경 후 기여에서 제외되어야 하는 prices[left - 1 + h]를 뺀다
            #   (윈도우가 한 칸 이동하면 후반 구간도 함께 한 칸 이동하므로, 그에 맞춰 빠지는 항을 제거)
            new += prices[right]
            new -= prices[left - 1 + h]

            # 현재 윈도우에서의 이득(new-old)이 지금까지의 최대 diff보다 크면 갱신
            if new - old > diff:
                diff = new - old

        return base + diff                               # 기본 수익 + 최대 변화량(이득) 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 변화량을 매번 O(k)로 재계산하지 않고,
#     old(기존 기여 합)과 new(변경 후 기여 합)을 슬라이딩 윈도우로 O(1) 갱신하여 최적화.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 사용한 개념:
#       - 슬라이딩 윈도우: 길이 k 구간을 한 칸씩 이동하며 합을 누적 갱신
#       - 변화량(diff) 최대화: 각 윈도우에서 (변경 후 - 변경 전)을 계산해 최대값 유지
#   - 주의 포인트:
#       - new에서 빠져야 하는 인덱스(left - 1 + h)가 정확히 윈도우 후반 시작점 이동과 일치해야 함.
#       - diff는 음수면 적용하지 않는 것이 유리하므로 max(0, ...) 형태로 처리.
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도:
#       - ps 계산: O(n)
#       - 초기 합 계산: O(k)
#       - 슬라이딩 윈도우 순회: O(n)
#       - 전체: O(n + k)
#   - 공간 복잡도:
#       - ps 배열: O(n)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - ps를 별도 배열로 만들지 않고 바로 누적합(prefix sum)으로 old를 관리하면,
#     메모리를 O(1) 수준으로 줄이는 변형도 가능하다(문제 제약에 따라 선택).
