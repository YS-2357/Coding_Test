# 3370_Smallest_Number_with_All_Set_Bits.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3370. Smallest Number With All Set Bits
# ✅ 문제 설명(요약):
#   정수 n이 주어질 때, n보다 크거나 같은 수 중에서
#   모든 비트가 1로 설정된(즉, 2^k - 1 형태인) 수 중 가장 작은 값을 반환하라.
#
# ✅ 입력 형식(요지):
#   - n: 정수 (1 ≤ n ≤ 10^9)
#
# ✅ 규칙 요약:
#   - 이진수 표현에서 모든 비트가 1인 수는 1, 3, 7, 15, 31, 63 ... (2^k - 1 꼴)
#   - n의 비트 길이를 구하고, 그 길이만큼의 모든 비트를 1로 세운 값을 반환한다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
class Solution:
    def smallestNumber(self, n: int) -> int:
        b = bin(n)[2:]            # n을 2진 문자열로 변환 후 '0b' 제거
        l = len(b)                # 비트 길이 계산
        ans = 0                   # 결과 초기화
        for i in range(l):        # 비트 길이만큼 반복
            ans += 2 ** i         # 하위 비트부터 1로 채워서 누적 (2^0 + 2^1 + ... + 2^(l-1))
        return ans                # 결과 반환 (즉, 2^l - 1)
# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 대부분의 테스트케이스에서 정답 일치.
#   - 동작 자체는 정확하며, 2^l - 1 값을 직접 계산한 것과 동일한 결과를 냄.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 사용 개념: 비트 연산 및 이진수 변환.
#   - 반복문으로 등비수열의 합을 직접 계산했으나, 실제로는 (1 << l) - 1로 한 줄에 표현 가능.
#   - 불필요한 반복문으로 상수항 증가(O(l)) → O(1) 수식으로 단축 가능.
#
# 📚 시간·공간 복잡도:
#   - 시간복잡도: O(l) ≈ O(log n) (비트 길이만큼 루프)
#   - 공간복잡도: O(1)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 문자열 변환 없이 비트 길이를 직접 구해 즉시 계산 가능:
#       l = n.bit_length()
#       ans = (1 << l) - 1
#       if ans < n:
#           ans = (1 << (l + 1)) - 1
#       return ans
#   - 위 방식은 반복문과 문자열 변환을 제거해 실제 실행 속도는 더 빠르다(O(1)).
