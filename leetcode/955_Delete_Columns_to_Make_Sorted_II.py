# 955_Delete_Columns_to_Make_Sorted_II.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 955. Delete Columns to Make Sorted II
# ✅ 문제 설명(요약):
#   - 동일 길이의 문자열 배열 strs가 주어진다.
#   - 몇 개의 열(column)을 삭제하여, 최종적으로 문자열 배열이 사전식(lexicographic) 비내림차순이 되게 만든다.
#   - 즉, 삭제 후 결과에서 strs[0] <= strs[1] <= ... <= strs[n-1] 를 만족해야 한다.
#   - 최소 삭제 열 개수를 반환한다.
#
# ✅ 입력 형식(요지):
#   - strs: 길이가 같은 문자열들의 리스트 (n개 문자열, 각 길이 m)
#
# ✅ 규칙 요약:
#   - 사전식 비교는 왼쪽에서 오른쪽으로 진행되며, 어떤 인접 쌍(i, i+1)은
#     - 가장 먼저 다른 문자가 등장한 열에서 크기 관계가 “확정”된다.
#   - 이미 확정된 인접 쌍은 이후 열 비교에서 더 이상 신경 쓸 필요가 없다.
#   - 어떤 열 j에서, 아직 확정되지 않은 인접 쌍 중 하나라도 strs[i][j] > strs[i+1][j]이면
#     - 그 열은 반드시 삭제해야 한다(삭제하지 않으면 정렬 조건 위반).
#   - 열을 삭제하지 않는 경우, strs[i][j] < strs[i+1][j]가 성립하는 (미확정) 인접 쌍은 그 열에서 정렬 관계가 확정된다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
#   - 아래는 사용자가 제출/채택한 최종 정답 코드이며,
#     이 단계에서는 코드 내용을 변경하지 않고,
#     각 줄마다 설명 주석만 추가한다.

class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        n, m = len(strs), len(strs[0])                          # n: 문자열 개수(행), m: 문자열 길이(열 개수)
        well_sorted = [False] * (n-1)                           # well_sorted[i]: (strs[i], strs[i+1])의 순서가 이미 확정되었는지
        ans = 0                                                 # 삭제한 열 개수 누적

        for j in range(m):                                      # 왼쪽 열부터 오른쪽 열까지 순회
            not_sorted = False                                  # 현재 열 j를 삭제해야 하는지 여부

            # 1) 현재 열 j가 "삭제가 필요한 열"인지 검사
            #    - 아직 확정되지 않은 인접 쌍들만 확인한다.
            for i in range(n-1):
                if not well_sorted[i] and ord(strs[i][j]) > ord(strs[i+1][j]):  # 미확정 쌍에서 내림차순(위배) 발생
                    not_sorted = True                           # 이 열은 삭제해야 함
                    break                                       # 하나라도 위배면 즉시 종료(삭제 결정)

            if not_sorted:                                      # 삭제가 필요하다면
                ans += 1                                        # 삭제 열 개수 증가
                continue                                        # 이 열은 삭제되므로 확정 상태 업데이트 없이 다음 열로

            # 2) 삭제하지 않는 경우, 이 열에서 새롭게 "확정"되는 인접 쌍을 표시
            #    - 미확정 쌍에서 strs[i][j] < strs[i+1][j]라면, 이 열이 최초 차이점이 될 수 있으므로 순서 확정
            for i in range(n-1):
                if not well_sorted[i] and ord(strs[i][j]) < ord(strs[i+1][j]):  # 엄격히 증가하면
                    well_sorted[i] = True                        # (i, i+1) 쌍은 이제 정렬 관계가 확정됨

            # 3) 모든 인접 쌍이 확정되었으면, 이후 열은 더 볼 필요가 없다(사전식 비교에서 더 이상 영향 없음)
            if all(well_sorted):
                break

        return ans                                               # 최소 삭제 열 개수 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - (기록 없음) 본 풀이는 표준적인 "사전식 정렬 확정 상태 추적" 접근으로 정답 처리 가능.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 955에서 흔한 오답 원인:
#     - 열을 독립적으로 세로 정렬(944 방식)처럼 판단하여,
#       이미 왼쪽 열에서 순서가 확정된 인접 쌍까지 계속 비교해 불필요하게 열을 삭제함.
#   - 사용한 핵심 개념:
#     - 사전식 정렬의 “확정(pair fixed)” 개념 추적
#     - 열을 왼쪽에서 오른쪽으로 스캔하며:
#       1) 미확정 인접 쌍에서 위배가 있으면 해당 열 삭제
#       2) 삭제하지 않으면, 증가가 관측된 미확정 쌍을 확정 처리
#     - 모든 인접 쌍이 확정되면 조기 종료 가능
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도: O(n * m)
#     - 각 열마다 최대 (n-1) 쌍을 검사하고, 다시 (n-1) 쌍을 업데이트
#   - 공간 복잡도: O(n)
#     - well_sorted 배열만 사용(입력 제외)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 개념적으로는 동일하며, 비교를 ord() 없이 문자 직접 비교로도 처리 가능하다(코드 변경 필요).
#   - n이 매우 큰 경우, all(well_sorted) 체크를 매번 수행하는 대신
#     확정된 쌍 개수를 카운트로 관리해 상수항을 줄이는 최적화가 가능하다(코드 변경 필요).
