# 3010_Divide an Array Into Subarrays With Minimum Cost I.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3010. Divide an Array Into Subarrays With Minimum Cost I
# 🏷️ 유형: 그리디 / 최소값 선택
#
# ✅ 문제 설명(요약):
#   - 길이 n인 배열 nums가 주어진다.
#   - 첫 원소 nums[0]은 반드시 선택되고,
#   - 나머지 원소들 중 서로 다른 두 원소를 추가로 선택하여 총 비용을 최소화한다.
#   - 총 비용은 선택된 세 원소의 합이다.
#
# ✅ 입력 형식(요지):
#   - nums: List[int]
#
# ✅ 규칙 요약:
#   - 항상 nums[0]은 포함된다.
#   - nums[1:]에서 가장 작은 두 값을 고르는 것이 최적이다.
#
# 🧠 핵심 불변식(Invariant):
#   - nums[0]은 고정이므로, 최소 비용을 만들려면 나머지 구간에서 최소 두 값만 고르면 된다.
#
# =====================================================
# ✅ 정답 코드 (나의 풀이; 절대 수정 금지)
# =====================================================

class Solution:                                                     # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def minimumCost(self, nums: List[int]) -> int:                 # 최소 비용을 반환하는 함수
        n = len(nums)                                              # 배열 길이를 저장
        if n == 3:                                                 # 길이가 정확히 3이면
            return sum(nums)                                       # 모든 원소를 더한 값이 정답
        
        min1, min2 = 51, 51                                        # 문제 제약보다 큰 값으로 최소값 두 개 초기화
        for i in range(1, n):                                      # nums[1:] 구간을 순회
            if nums[i] < min1:                                     # 현재 값이 최소값보다 작으면
                min2 = min1                                       # 기존 최소값을 두 번째 최소값으로 이동
                min1 = nums[i]                                    # 최소값 갱신
            elif nums[i] < min2:                                   # 두 번째 최소값보다 작으면
                min2 = nums[i]                                    # 두 번째 최소값 갱신
            
            if min1 == 1 and min2 == 1:                            # 더 이상 줄일 수 없는 최솟값 조합이면
                break                                              # 조기 종료
        
        return nums[0] + min1 + min2                               # 첫 원소 + 최소 두 값의 합을 반환

# =====================================================
# ✅ 정답 코드 (다른 풀이; 참고용)
# =====================================================

class Solution:                                                     # 동일 문제에 대한 대안 Solution 클래스
    def minimumCost(self, nums: List[int]) -> int:                 # 최소 비용을 반환하는 함수
        first = nums[0]                                            # 반드시 포함되는 첫 번째 원소
        rest = nums[1:]                                            # 나머지 원소들
        
        rest.sort()                                                # 나머지 원소를 오름차순 정렬
        
        return first + rest[0] + rest[1]                           # 가장 작은 두 값과 first의 합을 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 두 풀이 모두 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: 그리디(최소값 선택).
#
# 📚 시간·공간 복잡도:
#   - 나의 풀이: 시간 O(n), 공간 O(1)
#   - 다른 풀이: 시간 O(n log n), 공간 O(n)
#
# -----------------------------------------------------
