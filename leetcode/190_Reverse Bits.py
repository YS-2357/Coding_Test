# 190_Reverse Bits.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 190. Reverse Bits
# 🏷️ 유형: 비트 연산 / 시뮬레이션
#
# ✅ 문제 설명(요약):
#   - 32비트 부호 없는 정수 n이 주어질 때,
#   - 비트 순서를 뒤집은 정수를 반환한다.
#   - 예: ...abc → ...cba (총 32비트 기준으로 반전)
#
# ✅ 입력 형식(요지):
#   - n: int (32비트 unsigned integer로 간주)
#
# ✅ 규칙 요약:
#   - 정확히 32번 반복하며,
#   - 매 단계에서 n의 최하위 비트를 꺼내어 결과의 왼쪽으로 붙인다.
#   - 오른쪽으로는 n을 한 칸씩 시프트한다.
#
# 🧠 핵심 불변식(Invariant):
#   - i번째 반복이 끝났을 때, res에는 “원래 n의 하위 i비트가 뒤집힌 상태”가 저장된다.
#   - n은 매 반복마다 한 비트씩 오른쪽으로 이동하며 아직 처리되지 않은 비트들만 남는다.
#   - 32회 반복 후 res에는 전체 비트가 정확히 반전되어 들어 있다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                                     # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def reverseBits(self, n: int) -> int:                           # 32비트 정수 n의 비트를 뒤집어 반환하는 함수
        res = 0                                                     # 뒤집힌 비트를 누적할 결과 변수 초기화
        for i in range(32):                                         # 32비트 모두 처리하기 위해 32번 반복
            res = (res << 1) | (n & 1)                              # 결과를 왼쪽으로 한 칸 밀고, n의 최하위 비트를 붙임
            n >>= 1                                                 # n을 오른쪽으로 한 칸 이동시켜 다음 비트를 준비
        return res                                                  # 뒤집힌 비트 결과를 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: 비트 시프트(<<, >>)와 AND(&), OR(|) 연산을 이용한 비트 단위 처리.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(1)  (32회 고정 반복)
#   - 공간: O(1)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 비트를 2비트/4비트/8비트 단위로 스왑하는 비트 마스크 최적화 기법도 존재한다(개념만).
