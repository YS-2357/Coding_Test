# 1975_Maximum Matrix Sum.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 1975. Maximum Matrix Sum
# 🏷️ 유형: 그리디 / 행렬
#
# ✅ 문제 설명(요약):
#   - 정수 행렬이 주어질 때, 임의의 횟수만큼 행 또는 열을 선택해
#   - 해당 행/열의 모든 원소의 부호를 바꿀 수 있다.
#   - 만들 수 있는 행렬 원소 합의 최댓값을 구한다.
#
# ✅ 입력 형식(요지):
#   - matrix: 2차원 정수 배열
#
# ✅ 규칙 요약:
#   - 행 또는 열 단위로 부호 반전 연산을 수행할 수 있다.
#   - 연산 횟수에는 제한이 없다.
#
# 🧠 핵심 불변식(Invariant):
#   - 전체 절댓값의 합은 항상 유지되거나 증가 방향으로만 조정 가능하다.
#   - 음수의 개수가 짝수면 모두 양수로 만들 수 있다.
#   - 음수의 개수가 홀수면, 절댓값이 가장 작은 원소 하나는 음수로 남아야 한다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                             # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def maxMatrixSum(self, matrix: List[List[int]]) -> int: # 행렬에서 만들 수 있는 최대 합을 계산하는 함수
        cnt = 0                                             # 음수 원소의 개수를 세기 위한 변수
        ans = 0                                             # 모든 원소 절댓값의 합을 누적할 변수
        min_val = 10**6                                     # 원소 절댓값 중 최솟값을 저장할 변수 초기화
        
        for row in matrix:                                  # 행렬의 각 행을 순회
            for val in row:                                 # 각 행의 원소를 하나씩 순회
                ans += abs(val)                             # 현재 원소의 절댓값을 전체 합에 더함
                if val < 0:                                 # 현재 원소가 음수인 경우
                    cnt += 1                                # 음수 개수를 1 증가
                min_val = min(abs(val), min_val)           # 절댓값의 최소값을 갱신
        
        if cnt % 2 != 0:                                    # 음수 개수가 홀수인 경우
            ans -= 2 * min_val                              # 가장 작은 절댓값을 두 번 빼서 하나를 음수로 유지
        
        return ans                                          # 계산된 최대 행렬 합을 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: 그리디 접근, 부호 조작의 불변성 활용.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(n*m)  (행렬 전체 순회)
#   - 공간: O(1)    (상수 개 변수만 사용)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 모든 원소를 1차원으로 펼친 뒤 동일한 논리를 적용해도 결과는 같다.
#   - 핵심은 “음수 개수의 홀짝성”과 “최소 절댓값”이다.
