# 2654_Minimum_Number_of_Operations_to_Make_All_Array_Elements_Equal_to_1.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 2654. Minimum Number of Operations to Make All Array Elements Equal to 1
# ✅ 문제 설명(요약):
#   - 길이 n의 배열 nums가 주어진다.
#   - 연산: 인접한 두 원소의 GCD를 그 중 한 원소의 자리로 대체할 수 있다.
#   - 목표: 가능한 최소 연산으로 모든 원소를 1로 만드는 것.
#
# ✅ 입력 형식(요지):
#   - nums: List[int], 1 ≤ nums[i] ≤ 10^6
#
# ✅ 규칙 요약:
#   - 배열 내 인접 원소의 GCD만을 이용해 값을 줄인다.
#   - 결국 배열 어딘가에서 “1”을 한 번만 만들어내면,
#     나머지는 인접 확장으로 n-1번의 연산으로 모두 1이 된다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        def gcd(a, b):                     # 유클리드 호제법
            while b:
                a, b = b, a % b
            return a
        
        n = len(nums)
        ones = nums.count(1)               # 이미 1인 원소 개수
        if ones:                           # 1이 존재하면, 나머지를 1로 바꾸는 연산만 필요
            return n - ones                # 각 비-1 원소당 1번의 연산으로 인접 1로 변환

        cnt = 10 ** 6                      # 1을 만들기 위한 최소 구간 길이(초기값: 매우 큼)
        for i in range(n):                 # 모든 시작 위치 i 탐색
            g = nums[i]                    # 구간의 시작 GCD
            for j in range(i + 1, n):      # 오른쪽으로 확장
                g = gcd(g, nums[j])        # 누적 GCD 계산
                if g == 1:                 # 구간 [i, j]의 GCD가 1이면,
                    cnt = min(cnt, j - i)  # 그 구간 길이(j - i)가 1을 만드는 최소비용 후보
                    break                  # 더 확장해도 최소 길이는 늘어남 → 중단

        if cnt == 10 ** 6:                 # GCD가 1인 구간이 단 한 번도 없으면
            return -1                      # 어떤 방법으로도 1 생성 불가능
        return cnt + n - 1                 # (1 만드는 데 cnt회) + (전체를 1로 확장하는 n-1회)
# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 예제 모두 통과.
#   - 이미 1이 있으면 바로 답 = n - ones.
#   - 없을 때 GCD가 1인 최소 구간을 찾아 cnt + n - 1 반환.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 사용 개념: GCD 누적, 최소 구간 탐색, 유클리드 호제법.
#   - 핵심 논리:
#       1) 전체 GCD가 1이 아니면 1을 만들 수 없음.
#       2) GCD가 1인 구간의 최소 길이 = 1 생성 최소 연산 수 (L-1).
#       3) 이후 남은 n-1개 원소는 인접 확장으로 각각 1번씩 변환 가능.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(n² · log A), A = 최대 원소값 (최대 10⁶ 정도까지 가능)
#   - 공간: O(1)
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 전체 GCD가 1이 아니면 즉시 -1 반환 (추가 최적화 가능).
#   - GCD 구간 계산을 미리 누적 테이블/세그먼트 트리로 하면 O(n log A)에 개선 가능.
