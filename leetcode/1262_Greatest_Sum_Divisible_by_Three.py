# 1262_Greatest_Sum_Divisible_by_Three.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 1262. Greatest Sum Divisible by Three
# ✅ 문제 설명(요약):
#   - 정수 배열 nums가 주어졌을 때, 몇 개의 원소를 골라 만든 부분집합의 합이
#     3으로 나누어떨어지도록 하면서, 그 합이 최대가 되도록 하고 싶다.
#   - 부분집합은 비어 있지 않아도 되고, 모든 원소를 다 골라도 된다.
#   - 결과적으로 얻을 수 있는 "3의 배수인 최대 합"을 반환하는 문제이다.
#
# ✅ 입력 형식(요지):
#   - nums: List[int]
#     - 정수 배열
#
# ✅ 규칙 요약:
#   - 선택된 원소들의 합 S에 대해 S % 3 == 0 을 만족해야 함.
#   - S를 최대로 만들고 싶으므로, 기본적으로는 전체 합을 최대한 활용하되
#     3으로 나누어떨어지지 않는 경우 "최소 손실"이 되는 값만 빼는 전략이 필요.
#   - 핵심 관찰:
#       - 전체 합 total의 나머지에 따라,
#         - total % 3 == 0 → 그대로 사용
#         - total % 3 == 1 → (mod 1인 원소 1개) 또는 (mod 2인 원소 2개) 빼기
#         - total % 3 == 2 → (mod 2인 원소 1개) 또는 (mod 1인 원소 2개) 빼기
#       - 이때 각각의 나머지 그룹에서 "가장 작은 값들"만 알고 있으면 충분하다.

# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
#   - nums의 전체 합(ans)을 구하고,
#   - 3으로 나눈 나머지가 1 또는 2인 원소들에 대해
#     각 나머지 그룹별로 "가장 작은 2개 값"을 mins에 저장한다.
#   - 이후 ans % 3에 따라, 빼야 할 최소 값(또는 두 값의 합)을 선택해
#     결과를 ans - best로 계산한다.
#   - 만약 적절히 뺄 수 있는 원소가 존재하지 않으면 0을 반환한다.

class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        n = len(nums)                         # 배열 길이 (실제로는 사용되지 않지만 정보용 변수)
        ub = 10 ** 5                          # 초기 상한값(무한대 대용) — nums[i] 최대값보다 크거나 같은 값으로 설정
        mins = [[ub, ub], [ub, ub], [ub, ub]]
        # mins[r] = [가장 작은 값, 두 번째로 작은 값] (mod 3 == r 인 원소들에 대한 정보)
        # - mins[0]은 실제로 사용할 필요는 없지만, 인덱스 통일을 위해 함께 둔다.
        # - mins[1]: 나머지가 1인 수들 중 최소값 2개
        # - mins[2]: 나머지가 2인 수들 중 최소값 2개

        ans = 0                               # nums 전체 합을 누적할 변수

        for num in nums:                      # 모든 원소를 순회
            r = num % 3                       # 현재 숫자의 3으로 나눈 나머지
            if r != 0:
                # 나머지가 1 또는 2인 경우에만 mins를 갱신
                a, b = mins[r]                # 현재까지 기록된 (최소값, 두 번째 최소값)
                if num < a:
                    # num이 가장 작은 값이 되는 경우:
                    # 기존 가장 작은 a는 두 번째 최소값 b로 밀려난다.
                    b = a
                    a = num
                elif num < b:
                    # a보다는 크지만 기존 b보다는 작은 경우:
                    # 두 번째 최소값만 num으로 갱신.
                    b = num
                mins[r] = [a, b]              # 갱신된 (최소값 2개)를 저장
            ans += num                        # 전체 합을 누적

        # 이제 ans % 3 값에 따라 "얼마를 빼야 하는지"를 결정한다.
        if ans % 3 == 1:
            # 전체 합의 나머지가 1인 경우:
            #   1) 나머지 1인 수 하나를 빼거나
            #   2) 나머지 2인 수 두 개를 빼서 (2+2=4 ≡ 1 mod 3) 맞출 수 있다.
            remove1 = mins[1][0] if mins[1][0] != ub else ub
            # 후보1: mod 1 중 가장 작은 원소 1개 제거 (없으면 ub 그대로)
            remove2 = mins[2][0] + mins[2][1] if mins[2][1] != ub else ub
            # 후보2: mod 2 중 가장 작은 두 원소의 합 제거 (두 번째 최소값이 없으면 불가능)
            best = min(remove1, remove2)      # 둘 중 더 적게 빼는 쪽이 손실 최소
            return 0 if best == ub else ans - best
            # best == ub라면 양쪽 후보 모두 존재하지 않는다는 뜻 → 나머지를 0으로 맞출 수 없으므로 0 반환

        elif ans % 3 == 2:
            # 전체 합의 나머지가 2인 경우:
            #   1) 나머지 2인 수 하나를 빼거나
            #   2) 나머지 1인 수 두 개를 빼서 (1+1=2 ≡ 2 mod 3) 맞출 수 있다.
            remove1 = mins[2][0] if mins[2][0] != ub else ub
            # 후보1: mod 2 중 가장 작은 원소 1개 제거
            remove2 = mins[1][0] + mins[1][1] if mins[1][1] != ub else ub
            # 후보2: mod 1 중 가장 작은 두 원소의 합 제거
            best = min(remove1, remove2)      # 둘 중 더 적게 빼는 쪽 선택
            return 0 if best == ub else ans - best
            # 마찬가지로, 두 경우 모두 불가능하면 0 반환

        else:
            # ans % 3 == 0 인 경우:
            # 이미 3으로 나누어떨어지므로 전체 합 ans가 곧 최댓값이다.
            return ans

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - nums 전체 합(ans)을 기본값으로 설정하고, 각 원소의 나머지에 따라
#     mod 1, mod 2 그룹에서 가장 작은 두 값만 추적하는 그리디 구조로 해결했다.
#   - 이후 ans % 3에 따른 3가지 경우를 분리하여,
#     "빼야 하는 최소 값"을 선택함으로써 합을 3의 배수로 만들면서 손해를 최소화했다.
#   - 로직 자체가 명확하고, 구현도 O(n) 시간에 가능하다.

# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용한 알고리즘/수학적 개념:
#       1) 모듈러 연산(mod 3) 기반 케이스 분류:
#          - 전체 합의 나머지에 따라 어떤 유형의 원소를 얼마나 빼야 하는지 결정.
#       2) 그리디(minimal removal) 전략:
#          - 가능한 한 큰 합을 유지하면서 나머지 조건만 맞추기 위해,
#            mod 1/2 그룹에서 "가장 작은 수들"만 제거 대상으로 삼는다.
#       3) 최소값 2개 추적:
#          - mod 1, mod 2 각각에 대해 "가장 작은 것 2개"만 있으면,
#            나머지 보정(1 또는 2를 맞추기 위한 제거) 시 항상 최적의 선택을 할 수 있다.

# 📚 시간·공간 복잡도:
#   - 시간 복잡도:
#       - nums를 한 번 순회하며 mins와 ans를 갱신 → O(n)
#       - 이후 상수 시간 분기 처리 → O(1)
#       - 전체: O(n)
#   - 공간 복잡도:
#       - mins 배열과 상수 변수들만 사용 → O(1)

# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - DP 접근:
#       - dp[0], dp[1], dp[2]를 각각 "나머지가 0,1,2가 되는 최대 합"으로 두고,
#         각 숫자를 순회하며 새 상태를 갱신하는 방식도 존재한다.
#       - 이 경우 역시 O(n) 시간, O(1) 공간에 해결 가능하며,
#         모듈러 상태 기반 DP의 전형적인 예제로 사용된다.
#   - 하지만 현재 그리디 풀이 역시 최적해를 주며,
#     구현과 직관이 모두 간단하다는 장점이 있다.
