# 3379_Transformed Array.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3379. Transformed Array
# 🏷️ 유형: 배열 / 모듈러 인덱싱
#
# ✅ 문제 설명(요약):
#   - 길이 n의 배열 nums가 주어질 때, 각 인덱스 i에 대해
#   - 새로운 배열 ans[i] = nums[(i + nums[i]) mod n] 로 변환한 결과를 반환한다.
#   - nums[i]가 음수일 수 있으므로 인덱스가 음수가 되지 않도록 모듈러를 안전하게 처리한다.
#
# ✅ 입력 형식(요지):
#   - nums: List[int]
#
# ✅ 규칙 요약:
#   - 각 i에 대해 이동량 nums[i]만큼 인덱스를 이동한 위치의 값을 가져온다.
#   - 인덱스는 원형으로 순환하므로 n으로 나눈 나머지를 사용한다.
#   - 음수 이동도 허용되므로, 최종 인덱스를 0..n-1 범위로 정규화한다.
#
# 🧠 핵심 불변식(Invariant):
#   - 어떤 정수 x에 대해서도 ((x % n) + n) % n 은 0..n-1 범위의 인덱스로 정규화된다.
#   - 리스트 컴프리헨션은 각 i에 대해 독립적으로 위 규칙을 적용해 ans를 구성한다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                                     # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def constructTransformedArray(self, nums):                      # 변환된 배열을 반환하는 함수
        n = len(nums)                                               # 배열 길이 n을 저장
        return [nums[((i + nums[i]) % n + n) % n] for i in range(n)] # 각 i에 대해 안전한 모듈러로 인덱스를 정규화해 값 선택

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: 모듈러 연산으로 원형 인덱싱 처리.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(n)  (한 번 순회)
#   - 공간: O(n)  (결과 배열 생성)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - Python에서는 (i + nums[i]) % n 만으로도 음수 정규화가 되므로 식을 단순화할 수 있다(개념만).
