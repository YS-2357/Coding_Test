# 3713_Longest Balanced Substring I.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 3713. Longest Balanced Substring I
# 🏷️ 유형: 브루트포스 / 해시맵(빈도) / 부분문자열 탐색
#
# ✅ 문제 설명(요약):
#   - 문자열 s에서 “balanced substring”의 최대 길이를 구한다.
#   - 코드 기준으로 balanced의 의미는:
#     - 부분문자열 내에 등장하는 모든 문자들의 등장 횟수가 서로 같으면 balanced이다.
#   - 모든 부분문자열을 검사해 조건을 만족하는 최대 길이를 반환한다.
#
# ✅ 입력 형식(요지):
#   - s: str
#
# ✅ 규칙 요약:
#   - 부분문자열은 연속 구간이다.
#   - cnt는 현재 부분문자열에서 각 문자의 빈도를 저장한다.
#   - cnt.values()의 값들이 모두 동일하면 balanced이다.
#
# 🧠 핵심 불변식(Invariant):
#   - i를 시작점으로 고정하고 j를 확장하면서, cnt[s[j]]를 1씩 누적하면 현재 부분문자열의 빈도 상태가 유지된다.
#   - len(set(cnt.values())) == 1 이면, 모든 문자 빈도가 동일하다는 뜻이다.
#   - balanced 조건을 만족할 때마다 길이(j - i + 1)로 ans를 갱신한다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)

class Solution:                                                     # LeetCode 제출 형식에 맞춘 Solution 클래스 정의
    def longestBalanced(self, s: str) -> int:                       # balanced 부분문자열의 최대 길이를 반환하는 함수
        n = len(s)                                                  # 문자열 길이를 저장
        ans = 0                                                     # 최대 길이를 저장할 변수 초기화

        for i in range(n):                                          # 시작점 i를 0..n-1까지 순회
            cnt = defaultdict(int)                                  # 현재 시작점 i에 대한 문자 빈도 딕셔너리 초기화
            
            for j in range(i, n):                                   # 끝점 j를 i..n-1까지 확장하며 모든 부분문자열을 검사
                cnt[s[j]] += 1                                      # s[j] 문자의 빈도를 1 증가
                if len(set(cnt.values())) == 1:                     # 모든 문자의 빈도가 동일하면
                    ans = max(ans, j - i +1)                        # 현재 부분문자열 길이로 최대값을 갱신

        return ans                                                  # 최종 최대 길이를 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 제출 코드 기준: 정답 처리됨 (Accepted).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 오답 없음.
#   - 사용 개념: 모든 부분문자열을 브루트포스로 탐색하며, 해시맵으로 빈도를 유지하고 “빈도 값 일치”를 검사.
#
# 📚 시간·공간 복잡도:
#   - 시간: O(n^2 * u)  (u는 부분문자열 내 서로 다른 문자 수; set(cnt.values()) 생성 비용이 포함됨)
#   - 공간: O(u)        (빈도 딕셔너리)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 알파벳/문자 종류가 제한적이라면, 빈도 벡터를 상태로 압축하거나 길이별 검증으로 가지치기를 추가할 수 있다(개념만).
