# 2147_number_of_ways_to_divide_a_long_corridor.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 2147 - Number of Ways to Divide a Long Corridor
#
# ✅ 문제 설명(요약):
#   - 복도로 이루어진 문자열 corridor가 주어지며,
#     'S'는 좌석, 'P'는 화분을 의미한다.
#   - 복도를 여러 구간으로 나누되, 각 구간에는 정확히 좌석 2개가 포함되어야 한다.
#   - 가능한 분할 방법의 수를 1e9+7로 나눈 값을 구한다.
#
# ✅ 입력 형식(요지):
#   - corridor: 'S'와 'P'로만 이루어진 문자열
#
# ✅ 규칙 요약:
#   - 각 구간은 반드시 좌석(S) 2개를 포함해야 한다.
#   - 좌석의 총 개수가 홀수이거나 0개이면 분할 불가능하다.
#   - 분할선은 문자 사이에만 놓을 수 있다.
#
# -----------------------------------------------------
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
#   - 아래 코드는 사용자가 제출한 최종 정답 코드이며,
#     로직은 변경하지 않고 주석으로만 설명을 추가한다.

class Solution:
    def numberOfWays(self, corridor: str) -> int:
        MOD = 10**9 + 7              # 결과를 나눌 모듈러 값
        
        ans = 1                     # 가능한 분할 방법의 누적 곱
        cnt = 0                     # 지금까지 센 좌석(S)의 개수
        temp = 0                    # 현재 좌석 쌍 이후에 등장한 문자 수(P 포함)
        
        # 복도를 왼쪽부터 한 칸씩 순회
        for c in corridor:
            if c == "S":
                cnt += 1            # 좌석을 만나면 좌석 개수 증가
            
            # 좌석이 짝수 개(2, 4, 6, ...)가 되었고,
            # 현재 쌍(2개 좌석) 이후의 구간을 처리 중인 경우
            if cnt >= 2 and cnt % 2 == 0:
                if c == "P":
                    temp += 1       # 화분(P)이면 분할 후보 간격 증가
                else:
                    # 좌석(S)을 만난 경우:
                    # 이전 좌석 쌍과 현재 좌석 사이에 분할 가능 위치가 temp개 존재
                    temp += 1
                    ans = (ans * temp) % MOD  # 경우의 수에 곱해줌
                    temp = 0        # 다음 좌석 쌍을 위해 초기화
        
        # 좌석이 정확히 2개뿐이면 분할할 필요가 없으므로 경우의 수는 1
        if cnt == 2:
            return 1
        # 좌석 개수가 홀수이거나 아예 없는 경우는 분할 불가능
        elif cnt % 2 == 1 or cnt == 0:
            return 0

        # 모든 조건을 만족한 경우 누적된 경우의 수 반환
        return ans

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 좌석 쌍 사이의 화분(P) 개수를 이용해 분할 가능한 위치를 계산하는 방식으로 해결.
#   - 문자열을 한 번만 순회하여 효율적으로 처리 가능.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 핵심 개념:
#       - 좌석 2개를 하나의 묶음으로 보고, 각 묶음 사이의 분할 가능한 위치 수를 곱셈 원리로 계산.
#   - 실수 포인트:
#       - 좌석이 2개 미만이거나 홀수 개인 경우를 반드시 사전에 배제해야 함.
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도: O(n)  (n = corridor 길이, 단일 순회)
#   - 공간 복잡도: O(1)  (상수 개 변수만 사용)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 좌석 위치만 따로 기록한 뒤, 좌석 쌍 사이 거리로 계산하는 방식도 가능하나
#     현재 방식이 구현과 성능 모두에서 가장 직관적이다.
