# 0003_longest_substring_without_repeating_characters.py
# -----------------------------------------------------
# ✅ 제목: Longest Substring Without Repeating Characters
# ✅ 문제 설명(요약):
# - 문자열 s가 주어질 때, 같은 문자가 두 번 이상 등장하지 않는 '가장 긴 부분문자열'의 길이를 구한다.
#
# ✅ 입력 형식(요지):
# - s: str (ASCII/유니코드 가능)
#
# ✅ 규칙 요약:
# 1) 부분문자열은 연속된 구간이어야 한다.
# 2) 부분문자열 내에 중복 문자가 없어야 한다.
# 3) 길이만 반환한다.
#
# ✅ 입출력 예시(1개):
# - s = "abba"  →  2   (예: "ab", "ba")
#
# ✅ 정답 코드(너의 풀이; 한 줄마다 주석):
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        last = {}                      # 문자별 '마지막 등장 인덱스'를 저장할 해시맵
        left = 0                       # 현재 윈도우의 왼쪽 경계(포함)
        answer = 0                     # 정답(가장 긴 길이)

        for right, ch in enumerate(s): # 오른쪽 경계를 0..n-1로 확장하며 순회
            if ch in last and last[ch] >= left:
                left = last[ch] + 1    # 중복 발견: 윈도우를 바로 점프해 중복 제거
            last[ch] = right           # 현재 문자 ch의 마지막 위치를 갱신
            answer = max(answer, right - left + 1)  # 윈도우 길이 갱신

        return answer                  # 최종 최대 길이 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
# - O(n^2) 완전탐색으로 부분문자열을 전부 확인하여 시간초과 발생.
#
# 🔧 오답 및 실수(무엇을 틀렸고 어떻게 고쳤는지):
# - (이전) 모든 구간 s[i:j]에 대해 set으로 중복 검사 → 중복 계산 반복으로 비효율.
#   → (수정) '마지막 인덱스 맵'을 두고, 중복 문자를 만나면 left를 last[ch]+1로 점프.
#   → 각 문자는 최대 1번 윈도우에 들어오고 1번만 점프에 기여하므로 O(n) 달성.
#
# 📚 사용된/필수 개념(최소):
# - 슬라이딩 윈도우(가변 크기), 투 포인터, 해시맵(문자→마지막 인덱스)
# - 시간복잡도: O(n), 공간복잡도: O(min(n, 문자종류))
