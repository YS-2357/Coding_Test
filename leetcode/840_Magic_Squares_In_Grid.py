# 840_Magic_Squares_In_Grid.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 840. Magic Squares In Grid
# ✅ 문제 설명(요약):
#   - 정수 격자 grid가 주어진다.
#   - grid 내부의 모든 3x3 부분 격자 중에서 "마방진(magic square)"인 개수를 센다.
#   - 3x3 마방진의 조건:
#     - 1~9가 정확히 한 번씩 등장
#     - 각 행의 합, 각 열의 합, 두 대각선의 합이 모두 동일(3x3에서는 15)해야 한다.
#
# ✅ 입력 형식(요지):
#   - grid: List[List[int]] (n행 m열)
#
# ✅ 규칙 요약:
#   - 3x3 부분 격자를 모두 검사한다.
#   - 값은 1~9 범위이며 중복이 없어야 한다.
#   - 3x3 마방진(1~9 사용)에서는 중앙이 항상 5이고, 목표 합은 항상 15이다.
#
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
#   - 아래는 사용자가 제출/채택한 최종 정답 코드이며,
#     이 단계에서는 코드 내용을 변경하지 않고,
#     각 줄마다 설명 주석만 추가한다.

class Solution:
    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:
        n, m = len(grid), len(grid[0])                    # n: 행 개수, m: 열 개수
        ans = 0                                           # 마방진 개수 누적

        if n < 3 or m < 3:                                # 3x3을 만들 수 없으면
            return 0                                      # 결과는 0

        for r in range(n-2):                              # 3x3의 좌상단 행 인덱스 r
            for c in range(m-2):                          # 3x3의 좌상단 열 인덱스 c
                nums = [False] * 10                       # 1~9 사용 여부 체크(인덱스 0은 사용 안 함)
                stop = False                               # 현재 3x3이 조건 위반인지 표시

                # 1) 3x3 내 모든 값이 1~9 범위이고 중복이 없는지 검사
                for x in range(3):                        # 3x3 내부 행 오프셋
                    for y in range(3):                    # 3x3 내부 열 오프셋
                        v = grid[r+x][c+y]                # 현재 값
                        if v < 1 or v > 9 or nums[v]:     # 범위 밖이거나 이미 등장한 값이면
                            stop = True                   # 실패 처리
                            break                         # 내부 루프 탈출
                        nums[v] = True                    # 값 v 사용 표시
                    if stop:                               # 중간에 실패하면
                        break                              # 바깥 루프도 탈출
                if stop:                                   # 값/중복 검사에서 실패면
                    continue                               # 다음 3x3로 넘어감

                # 2) 3x3 마방진(1~9)에서 중앙값은 반드시 5라는 성질로 빠른 가지치기
                if grid[r+1][c+1] != 5:
                    continue

                # 3) 행 합 검사(각 행의 합이 15인지)
                for x in range(3):
                    if grid[r+x][c] + grid[r+x][c+1] + grid[r+x][c+2] != 15:
                        stop =True                         # 조건 위반 표시(즉시 break는 하지 않음)

                # 4) 열 합 검사(각 열의 합이 15인지)
                for y in range(3):
                    if grid[r][c+y] + grid[r+1][c+y] + grid[r+2][c+y] != 15:
                        stop = True                        # 조건 위반 표시

                # 5) 주대각선 합 검사
                if grid[r][c] + grid[r+1][c+1] + grid[r+2][c+2] != 15:
                    stop = True

                # 6) 부대각선 합 검사
                if grid[r][c+2] + grid[r+1][c+1] + grid[r+2][c] != 15:
                    stop = True

                if not stop:                               # 모든 조건을 만족하면
                    ans += 1                               # 마방진 개수 증가

        return ans                                         # 최종 개수 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 첫 제출에서 정답 처리됨(3x3 모든 부분 격자에 대해 조건 검사).
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 사용한 핵심 알고리즘/개념:
#     - 완전탐색(3x3 윈도우 슬라이딩) + 조건 검증
#     - 집합/방문 배열을 통한 1~9 중복 검사
#     - 수학적 가지치기: 1~9 마방진의 중앙은 5, 목표 합은 15
#   - 주의 포인트(일반적):
#     - 1~9가 아닌 값이 섞인 경우, 합만 맞춰도 마방진이 아니므로 반드시 범위/중복을 먼저 확인해야 한다.
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도: O((n-2)*(m-2)) = O(n*m)
#     - 각 3x3에 대해 상수(최대 9칸 + 합 검사) 연산
#   - 공간 복잡도: O(1)
#     - nums 배열은 크기 10으로 상수
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 중앙이 5가 아니면 바로 제외하는 가지치기를 더 앞단에 두는 것도 가능하다(상수항 감소, 코드 X).
#   - 3x3 마방진의 가능한 패턴(8가지 회전/대칭)을 미리 템플릿으로 두고 비교하는 방식도 가능하다(개념만, 코드 X).
