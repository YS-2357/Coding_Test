# 2110_number_of_smooth_descent_periods_of_a_stock.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 2110 - Number of Smooth Descent Periods of a Stock
#
# ✅ 문제 설명(요약):
#   - 주식 가격 배열 prices가 주어진다.
#   - 연속한 구간에서, 매일의 가격이 바로 전날보다 정확히 1씩 감소하면
#     해당 구간을 "smooth descent period"라고 한다.
#   - 길이가 1인 구간도 항상 유효한 descent period로 센다.
#   - 가능한 모든 smooth descent period의 개수를 구한다.
#
# ✅ 입력 형식(요지):
#   - prices: 각 날짜의 주식 가격을 나타내는 정수 배열
#
# ✅ 규칙 요약:
#   - 연속 구간 [l, r]에 대해
#       prices[i] - prices[i+1] == 1  (l ≤ i < r)
#     를 만족해야 한다.
#   - 단일 원소 구간도 항상 포함한다.
#
# -----------------------------------------------------
# ✅ 정답 코드(나의 풀이; 절대 수정 금지)
#   - 아래 코드는 사용자가 제출한 최종 정답 코드이며,
#     로직은 변경하지 않고 주석으로만 설명을 추가한다.

class Solution:
    def getDescentPeriods(self, prices: List[int]) -> int:
        n = len(prices)        # 가격 배열의 길이
        ans, prev = 1, 1       # ans: 전체 descent period 수
                               # prev: 현재 인덱스에서 끝나는 descent period의 길이
        
        # 두 번째 원소부터 순회하며 이전 가격과의 차이를 확인
        for i in range(1, n):
            # 바로 전날 가격이 오늘 가격보다 정확히 1 큰 경우
            if prices[i-1] - prices[i] == 1:
                prev += 1      # 이전 descent 구간에 이어서 길이 증가
            else:
                prev = 1       # 조건이 깨지면 새 구간 시작 (길이 1)
            ans += prev        # 현재 위치에서 끝나는 모든 descent 구간을 누적
        
        return ans             # 전체 smooth descent period 개수 반환

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 연속 감소 구간의 길이를 누적해 더하는 방식으로 한 번의 순회만에 해결.
#   - 별도의 추가 자료구조 없이 안정적으로 통과 가능.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - 핵심 개념:
#       - i에서 끝나는 smooth descent period의 개수는
#         직전 값과의 관계에 따라 1 또는 (이전 길이 + 1)로 갱신됨.
#       - 각 위치에서의 기여도를 누적하면 전체 경우의 수가 됨.
#   - 전형적인 1차원 DP / 누적 카운팅 문제.
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도: O(n)  (배열 1회 순회)
#   - 공간 복잡도: O(1)  (상수 변수만 사용)
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 감소 구간의 길이를 먼저 분리해 각 구간마다
#     k*(k+1)/2로 계산하는 방식도 가능하지만,
#     현재 방식이 구현과 직관 모두에서 가장 간결하다.
