# 1523_Count_Odd_Numbers_in_an_Interval_Range.py
# -----------------------------------------------------
# ✅ 제목: LeetCode 1523. Count Odd Numbers in an Interval Range
# -----------------------------------------------------
# ✅ 문제 설명(요약):
#   - 정수 low, high 가 주어질 때,
#     닫힌 구간 [low, high] 안에 존재하는 홀수(odd number)의 개수를 구하는 문제이다.
#   - 범위 내의 모든 정수를 직접 검사하지 않고,
#     수학적 규칙을 이용해 빠르게 계산하는 것이 핵심이다.
#
# ✅ 입력 형식(요지):
#   - low: int  (구간 시작)
#   - high: int (구간 끝)
#   - low ≤ high
#
# ✅ 규칙 요약:
#   - 구간 길이 = high - low + 1
#   - 길이가 짝수이면, 홀수 개수 = (length / 2)
#   - 길이가 홀수이면,
#       · low가 홀수이면 홀수가 하나 더 포함됨 → (length // 2 + 1)
#       · low가 짝수이면 홀수 개수는 (length // 2)
#   - 이는 “홀수/짝수는 2개 단위로 반복된다”는 규칙을 이용한 단순 수학 계산.
#
# -----------------------------------------------------
# ✅ 정답 코드 (나의 풀이; 절대 수정 금지, 주석만 추가)
# -----------------------------------------------------

class Solution:
    def countOdds(self, low: int, high: int) -> int:
        ran = high - low + 1          # 전체 구간의 길이

        if ran % 2 == 0:              # 구간 길이가 짝수이면
            return ran // 2           # 홀수와 짝수가 정확히 절반씩 존재
        else:                         # 구간 길이가 홀수이면
            if low % 2 == 1:          # 시작점 low가 홀수라면
                return ran // 2 + 1   # 홀수가 하나 더 추가됨
            else:
                return ran // 2       # low가 짝수라면 홀수 개수는 절반

# -----------------------------------------------------
# 🔍 첫 시도 결과:
#   - 구간 내 홀수 개수를 직접 반복문으로 세지 않고,
#     구간 길이가 짝수/홀수일 때의 규칙을 수학적으로 나누어 해결.
#   - 기본적인 수학적 관찰만으로 O(1) 시간에 문제를 해결하는 정답을 얻음.
#
# 🔧 오답 이유 및 사용한 알고리즘 개념:
#   - (가능한 오답 시도) 모든 숫자에 대해 %2 연산을 수행하면 O(high-low) 시간이 필요.
#   - 본 풀이는 다음 원리 사용:
#       1) 정수의 홀짝은 2개 패턴(짝→홀 또는 홀→짝)이 반복되는 구조.
#       2) 길이가 짝수이면 항상 홀수와 짝수는 동일 개수 존재.
#       3) 길이가 홀수일 때는 시작점의 홀짝 여부가 전체 홀수 개수를 결정.
#
# 📚 시간·공간 복잡도:
#   - 시간 복잡도: O(1)
#       · 단순 산술 연산만 사용.
#   - 공간 복잡도: O(1)
#       · 추가 배열이나 구조 없음.
#
# -----------------------------------------------------
# (선택) 다른 효율적 풀이 또는 알고리즘 제안:
#   - 다른 표현식: (high + 1) // 2 - (low // 2)
#       · 이 수식도 동일하게 구간 내 홀수 개수를 계산함.
#   - 그러나 현재 풀이는 직관적으로 이해하기 쉬운 구조로 작성됨.
# -----------------------------------------------------
